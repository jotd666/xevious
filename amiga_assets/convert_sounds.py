import subprocess,os,struct,glob,tempfile
import shutil

sox = "sox"

if not shutil.which("sox"):
    raise Exception("sox command not in path, please install it")
# BTW convert wav to mp3: ffmpeg -i input.wav -codec:a libmp3lame -b:a 330k output.mp3

#wav_files = glob.glob("sounds/*.wav")

wav_files = ["credit.wav"]
outfile = "../src/amiga/sounds.68k"
sndfile = "../src/amiga/sound_entries.68k"

snd_header = r"""
FXFREQBASE = 3579564
SOUNDFREQ = 22050

    .macro    SOUND_ENTRY    sound_name,size,channel,soundfreq,volume
\sound_name\()_sound:
    .long    \sound_name\()_raw
    .word   \size
    .word   FXFREQBASE/\soundfreq,\volume
    .byte    \channel
    .byte    1
    .endm

"""

sound_channel_dict = {}
sampling_rate = 16000
# 512k version assets can be generated by tuning down sampling freq
# and changing it in the code as well
#sampling_rate = 12000
raw_file = os.path.join(tempfile.gettempdir(),"out.raw")
with open(sndfile,"w") as fst,open(outfile,"w") as fw:
    fst.write(snd_header)

    fw.write("\t.datachip\n")
    for wav_file in wav_files:
        wav_name = os.path.splitext(wav_file)[0]
        fw.write("\t.global\t{}_raw\n".format(wav_name))


    for wav_file in wav_files:
        wav_name = os.path.basename(wav_file)

        def get_sox_cmd(sr,output):
            return [sox,"--volume","1.0",wav_file,"--channels","1","--bits","8","-r",str(sr),"--encoding","signed-integer",output]
        used_sampling_rate = sampling_rate

        cmd = get_sox_cmd(used_sampling_rate,raw_file)

        subprocess.check_call(cmd)
        with open(raw_file,"rb") as f:
            contents = f.read()

        # compute max amplitude so we can feed the sound chip with a amped sound sample
        # and reduce the replay volume. this gives better sound quality than replaying at max volume
        signed_data = [x if x < 128 else x-256 for x in contents]
        maxsigned = max(signed_data)
        minsigned = min(signed_data)

        amp_ratio = max(maxsigned,abs(minsigned))/128

        wav = os.path.splitext(wav_name)[0]
        channel = sound_channel_dict.get(wav,2)
        fst.write("    SOUND_ENTRY {},{},{},SOUNDFREQ,{}\n".format(wav,len(signed_data)//2,channel,int(64*amp_ratio)))
        maxed_contents = [int(x/amp_ratio) for x in signed_data]

        signed_contents = bytes([x if x >= 0 else 256+x for x in maxed_contents])
        # pre-pad with 0W, used by ptplayer for idling
        if signed_contents[0] != b'\x00' and signed_contents[1] != b'\x00':
            # add zeroes
            signed_contents = struct.pack(">H",0) + signed_contents
        with open(raw_file,"rb") as f:
            contents = f.read().rstrip(b"\x00")
        # pre-pad with 0W, used by ptplayer for idling
        if contents[0] != b'\x00' and contents[1] != b'\x00':
            # add zeroes
            contents = b'\x00\x00' + contents

        fw.write("{}_raw:   | {} bytes".format(wav,len(contents)))
        n = 0
        for c in contents:
            if n%16 == 0:
                fw.write("\n\t.byte\t0x{:x}".format(c))
            else:
                fw.write(",0x{:x}".format(c))
            n += 1
        fw.write("\n")

