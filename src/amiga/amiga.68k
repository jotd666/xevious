*
*	Amiga-specific portions of Xevious
*
* (c) JOTD 2023
*

.include "../src/xevious.inc"
.include "custom.i"
.include "exec_lvos.i"
.include "dos_lvos.i"
.include "graphics_lvos.i"


STATE_ACTIVE = 2
STATE_DO_NOT_UPDATE_SHADOW = 1
STATE_INACTIVE = 0

SCORE_FILE_SIZE = 16*5

SPRITE_LIFETIME = 2

NB_VISIBLE_ROWS = 36

	.ifdef	RELEASE
OPT_ENABLE_PROFILING = 0
OPT_ENABLE_LOGGING = 0
ONE_TICK = 1
	* check most used options in release mode
	* to avoid creating a version with cheats on!
	.ifne	OPT_INVINCIBLE
	.error	"cheat option in release mode"
	.endif
	.ifne	OPT_START_AREA-1
	.error	"level select option in release mode"
	.endif
	.ifne	OPT_START_SCORE
	.error	"nonzero score option in release mode"
	.endif
	.ifne	OPT_REVEAL_SOL_TOWER
	.error	"reveal sol tower option in release mode"
	.endif
	.ifne	OPT_REVEAL_BONUS_FLAG
	.error	"reveal bonus flag option in release mode"
	.endif
	.else
OPT_ENABLE_LOGGING = 1
OPT_ENABLE_PROFILING = 0
* set to higher values than 1 to speed game up
ONE_TICK = 1
* Xevious still has some strange sprite/clut combinations
* we choose to ignore them as they're completely bogus
* (ex: 95,12: yellow part of andor genesis, makes no sense,
* Mark says that it happens when starting at level > 1 as
* game isn't designed to do this)

	.endif
	
* double-buffering is really needed here, else blits fail
* to race the beam and flicker is very frequent
OPT_ENABLE_DOUBLE_BUFFERING = 1

* empiric values of number of 16x16 bob objects
* currently displayed. Allows to adapt framerate
* and avoid flicker/slowdowns
* >= 64 is useless as 64 sprites are updated per frame
*MEDIUM_SPRITES_THRESHOLD = 24
*HIGH_SPRITES_THRESHOLD = 48

MEDIUM_SPRITES_THRESHOLD = 36
HIGH_SPRITES_THRESHOLD = 50

_custom = 0xDFF000


BASE_BPLCON3_VALUE = (1<<12)|(1<<10)
NB_PLAYFIELD_PLANES = 4
FG_DIRTY_TILES_SIZE = 0x800
TOTAL_NB_COLORS = 32   | 16+16
NB_BYTES_PER_ROW = 40
NB_BYTES_PER_FG_ROW = 32
NB_LINES = 288
Y_MAX = NB_LINES-2     | last visible
NB_PLAYFIELD_LINES = 512
* scrollable planes
BG_SCREEN_PLANE_SIZE = NB_BYTES_PER_ROW*NB_PLAYFIELD_LINES*2
BG_SCREEN_SIZE =  BG_SCREEN_PLANE_SIZE*NB_PLAYFIELD_PLANES
* non-scrollable planes, add a few lines for safety
FG_SCREEN_PLANE_SIZE = NB_BYTES_PER_ROW*(NB_LINES+32)
FG_SCREEN_SIZE =  FG_SCREEN_PLANE_SIZE*NB_PLAYFIELD_PLANES

NB_SPRITES_TO_UPDATE = 32
NB_SPRITES_TOTAL = 64

BLANK_FG_TILE_ID = 0x24

* sprite backup structure
* total struct size = 32*2, one or two sprites
actsprite_y_clipping = 2
actsprite_orig_ptr = 4
actsprite_copperlist_ptr = 8    | points on first SPRPTL instruction: so +2.W, +6.W are half pointers
actsprite_saved_line = 12       | ends at 12+16 = 28
actsprite_second_sprite = 32   | second sprite... etc... everything repeated

ACTIVE_SPRITE_STRUCT_BITS = 6    | 1<<6 = 64: can hold a slb struct

	move.l	a7,old_stack
	bra	_user

| write current PC value to some address
.macro LOGPC	address
	.ifndef	RELEASE
     bsr    .next_\@
.next_\@:
      addq.l    #6,(a7) | skip this & next instruction
      move.l    (a7)+,0x\address
	.endif
.endm

.macro	WAIT_BLIT
	move.w	#0x8400,dmacon+_custom
wait\@:
	BTST	#6,dmaconr+_custom
	BNE.S	wait\@
	move.w	#0x0400,dmacon+_custom
.endm

.macro MUL_TABLE value,len
mul\value\()_table:
	.set    mulv,0
	.rept	\len
	dc.w	mulv
	.set	mulv,mulv+\value
	.endr
.endm

* internal macro
.macro GXY_PREP

	
	.endm
	
* < D0 as native game offset
* > D0,D1 as amiga X,Y
.macro GET_XY_FROM_OFFSET
	move.w	d0,d1
	subq.w	#2,d1
	and.w	#0x3F,d1	| Y is computed
	lsr.w	#6,d0
	neg.w	d0
	add.w	#32,d0	| mirror: X is computed
.endm

* < D0,D1 as amiga X,Y
* > D0 as plane offset
* > D1 recieves original D1*240 (can be tested against the limit
* for post-processing)
.macro	GET_PLANE_OFFSET_FROM_XY
	* now multiply D1 by 240
	lea		mulNB_BYTES_PER_ROW_table(pc),a1
	.ifdef	NO68020
	add.w	d1,d1
	move.w	(a1,d1.w),d1
	.else
	move.w	(a1,d1.w*2),d1		| times 40
	.endif
	lsl.w	#3,d1		| times 8
	* add y offset to screen data	
	add.w	d1,d0	
	.endm
.macro GET_XY_ADDRESS  base_address
	GET_XY_FROM_OFFSET
	GET_PLANE_OFFSET_FROM_XY	
	* add x offset to screen data
	lea		(\base_address,d0.w),a1
.endm

	
* the non shifted version is just so simple...
* huge thanks to dual playfield and bplcon1 x-shift!
.macro	SET_FG_BYTE
	move.b	(a0)+,(offset,a1)
	.endm


.macro   PREP_FG_MASK_LOOP
	moveq	#2,d3
	subq.w	#8,a0
	lea		not_mask(pc),a2
	move.l	(a0)+,d0
	not.l	d0
	move.l	d0,(a2)
	move.l	(a0),d0
	not.l	d0
	move.l	d0,(4,a2)
	.endm
	
* debug macro that colors the screen until LMB pressed
.macro 	blitz_bypass
	move.w	d0,-(a7)
	clr.w	d0
loop\@:
	move.w	#BASE_BPLCON3_VALUE,_custom+bplcon3	| really color 0
	move.w	d0,_custom+color
	btst	#6,0xbfe001
	beq.b	out\@
	addq.w	#1,d0
	bra.b	loop\@
out\@:
	move.w	(a7)+,d0
	nop
.endm

* same thing but if LMB is pressed when entering, macro waits for release)
.macro blitz
w\@:
	btst	#6,0xbfe001
	beq.b	w\@
	blitz_bypass
.endm

* exports

    .global _jp_config
    .global _us_config
    .global _sp_config
   	.global DUMMY
	  .global _user
		.global _player_start
		.global _demo_end

* osd layer		
		.global osd_enable_vblank_interrupt
		.global osd_ack_vblank_interrupt
		.global osd_disable_vblank_interrupt
		.global osd_kick_wdog
		.global osd_w_fg_colorram
		.global osd_w_bg_colorram
		.global osd_w_fg_videoram
		.global osd_w_bg_videoram
		.global osd_update_scroll_hw
		.global osd_update_sprite_shadow
		.global osd_update_32_sprite_hw
		.global osd_read_dipswitches
		.global osd_read_p1_inputs
		.global osd_read_p2_inputs
		.global osd_read_high_scores
		.global osd_write_high_scores
		.global osd_read_coin
		.global osd_read_start
		.global osd_sound_stop
		.global osd_sound_start
		.global	osd_sound_mute
		.global	osd_sound_unmute

* debugging only
    .global osd_debug1
    .global osd_debug2
    .global osd_debug_hook
    .global	scb1_shadow
    .global scb3_shadow
    .global scb4_shadow
    .global _end_of_ng_code
    .global _end_of_ng_data
    
	
	.include	"ReadJoypad.i"
	.include	"whdload_funcs.i"
		.text


.list

    .align 4
_jp_config:
_us_config:
_sp_config:
    .ascii    "XEVIOUS         "
    .word     0xffff
    .word     0xffff
    .byte     0xff
    .byte     0xff
    .byte     0x38                | bonus life (20,60,*60)
    .byte     0x24                | lives (3)
    .byte     0x02                | flags award bonus life (yes)
    .byte     0x14								| difficulty (normal)
    .byte     0x02                | cabinet
    .byte     0x00
    .byte     0x00
    .byte     0x00
    .byte     0x00
    .byte     0x00
* item names are 12 characters    
    .ascii    "BONUS LIFE  "      | item 5
    .ascii    "10K 40K *40K"
    .ascii    "10K 50K *50K"
    .ascii    "20K 50K *50K"
    .ascii    "20K 60K *60K"
    .ascii    "20K 70K *70K"
    .ascii    "20K 80K *80K"
    .ascii    "20K 60K only"
    .ascii    "NONE        "
    .ascii    "LIVES       "      | item 6
    .ascii    "3           "
    .ascii    "1           "
    .ascii    "2           "
    .ascii    "5           "
    .ascii    "FLAGS LIFE  "      | item 7
    .ascii    "YES         "
    .ascii    "NO          "
    .ascii		"DIFFICULTY  "			| item 8
    .ascii    "NORMAL      "
    .ascii    "EASY        "
    .ascii    "HARD        "
    .ascii    "HARDEST     "
    .ascii    "CABINET     "      | item 9
    .ascii    "VERTICAL    "
    .ascii    "HORIZONTAL  "

	.align 4
IRQ1:
	
	rte
    
	.align 4
IRQ3:
	
	rte

DUMMY:
	rte
	    
TRAP:
	rte

	.ifne	OPT_ENABLE_PROFILING
	* init profiling if enabled
	.include	"profiler.68k"
	.endif

	    
_user:
    * if D0 contains "WHDL"
    * A0 contains resload
        
    cmp.l   #0x05748444c,D0	| WHDL
    bne.b   .standard
    move.l a0,_resload
    *move.b  d1,_keyexit

	move.l	a0,a2
	lea	(_tag,pc),a0
	jsr	(resload_Control,a2)
	
    bra		.no_forbid
.standard:
	
    * open dos library, graphics library
    move.l  0x4.W,a6
    lea dosname(pc),a1
    moveq.l #0,d0
    jsr _LVOOpenLibrary(a6)
    move.l  d0,_dosbase

	move.l	#read_args_string,d1
	move.l	#program_args,d2
	moveq.l	#0,d3
	move.l	_dosbase,A6
	jsr	_LVOReadArgs(a6)

	move.l	d0,rdargs_struct		| NULL is OK
	bne	0f
	jmp		_LVOExit(a6)
0:	
	lea		program_args,a0
	move.l	(A0)+,D0	| STARTLIVES/K/N
	beq.b	1f
	move.l	d0,a1
	move.l	(a1),d0
	and.l	#3,d0
	move.l	d0,start_lives
1:
	move.l	(A0)+,D0	| SKILL/K/N
	beq.b	1f
	move.l	d0,a1
	move.l	(a1),d0
	and.l	#3,d0
	move.l	d0,difficulty_level
1:
	* bit 0: DSW flag awards bonus life
	* bit 1: no looped music

	move.l	(A0)+,D0	| FLAGXTRA/S
	beq.b	1f
	or.l	#1,misc_flags
1:
	move.l	(A0)+,D0	| NOMUSIC/S
	beq.b	1f
	or.l	#2,misc_flags
1:
	move.l	(A0)+,D0	| SUPER
	beq.b	1f
	or.l	#4,misc_flags
1:
	move.l	(A0)+,D0	| STARTAREA/K/N
	beq.b	1f
	move.l	d0,a1
	move.l	(a1),d0
	subq.l	#1,d0
	and.l	#0xF,d0
	move.l	d0,start_area_option
1:
	move.l	(A0)+,D0	| INVINCIBLE/S
	beq.b	1f
	or.l	#1,cheat_flags
1:
	move.l	(A0)+,D0	| INFLIVES/S
	beq.b	1f
	or.l	#2,cheat_flags
1:
	move.l	(A0)+,D0	| REVSOL/S
	beq.b	1f
	or.l	#4,cheat_flags
1:
	move.l	(A0)+,D0	| REVBFLAG/S
	beq.b	1f
	or.l	#8,cheat_flags
1:



	move.l	rdargs_struct,d1
	jsr		_LVOFreeArgs(a6)

	bsr		store_system
	
	lea		_custom,a5
	lea		debug_copperlist,a0
	move.l	a0,cop1lc(a5)

	move.l	4.W,A6
	lea graphicsname(pc),a1
    moveq.l #0,d0
    jsr _LVOOpenLibrary(a6)
    move.l  d0,_gfxbase
    move.l	d0,a6
	move.l	38(a6),old_syscoplist
	move.l	34(A6),old_actiview		| gb_ActiView

	sub.l	a1,a1
	jsr	_LVOLoadView(a6)
	jsr	_LVOWaitTOF(a6)
	jsr	_LVOWaitTOF(a6)

	bsr		load_highscores

    * check if "floppy" file is here
    
    move.l  _dosbase(pc),a6
    move.l   #floppy_file,d1
    move.l  #1005,d2   | MODE_OLDFILE
    jsr     _LVOOpen(a6)
    move.l  d0,d1
    beq.b   .no_floppy
    
    * "floppy" file found
    jsr     _LVOClose(a6)
    * wait 2 seconds for floppy drive to switch off
    move.l  #100,d1
    jsr     _LVODelay(a6)
.no_floppy:

.startup:

* no multitask
    tst.l   _resload
    bne.b   .no_forbid
    *move.l  _gfxbase(pc),a4
    *move.l StartList(a4),gfxbase_copperlist

    move.l  4,a6
    jsr _LVOForbid(a6)

    
	sub.l	A1,A1
	jsr	_LVOFindTask(a6)		| find ourselves
	move.l	D0,A0
	move.l	#-1,184(A0)	| pr_WindowPtr no more system requesters (insert volume, write protected...)

.no_forbid:
	move.l	start_lives(pc),d2
	neg.w	d2
	addq	#3,d2
	lsl.w	#5,d2
	move.w	d2,start_lives_dsw
	
	move.l	difficulty_level(pc),d2
	neg.w	d2
	addq	#3,d2
	lsl.w	#5,d2
	move.w	d2,difficulty_level_dsw
	
	
	jsr	 _detect_controller_types 


		moveq			#2,d0
		*move.b		(BIOS_USER_REQUEST),d0
		lsl.w			#2,d0
    movea.l   1f(pc,d0.w),a0
    jmp       (a0)
    .align 4
1:	.long			startup_init
		.long			eye_catcher
		.long			demo_game
		.long			title_display

startup_init:
		rts

eye_catcher:
* we're not doing things the NeoGeo way
		rts

load_highscores:
    lea hiscorename(pc),a0
    move.l  _resload(pc),d0
    bne.b   1f

    move.l  _dosbase(pc),a6
    move.l  a0,d1
    move.l  #1005,d2
    jsr     (_LVOOpen,a6)
    move.l  d0,d1
    beq.b   1f
    move.l  d1,d4
    move.l  #SCORE_FILE_SIZE,d3
    move.l  #high_score_buffer,d2
    jsr (_LVORead,a6)
    move.l  d4,d1
    jsr (_LVOClose,a6)   
	st.b	highscore_loaded
1:
    rts

save_highscores:
	tst.l	_resload
	bne.b	1f
    tst.b   highscore_needs_saving
    beq.b   1f
    move.l  _dosbase(pc),a6
	lea		hiscorename(pc),a0
    move.l  a0,d1
    move.l  #1006,d2
    jsr     (_LVOOpen,a6)
    move.l  d0,d1
    beq.b   1f
    move.l  d1,d4
    move.l  #SCORE_FILE_SIZE,d3
    move.l  #high_score_buffer,d2
    jsr (_LVOWrite,a6)
    move.l  d4,d1
    jsr (_LVOClose,a6)   
1:	
    rts
    
	
* To get the core to run, you just need to jump to xevious_reset after
* you've initialised the platform (Amiga) stuff. That essentially does a
* Z80 reset. You also need to call xevious_im1_irq from the Amiga vblank
* routine. They are the only 2 entry points required for the core to run,
* even if there's no other I/O.


demo_game:
		move		#0x4000,_custom+intena						| disable interrupts
		move		#0x7FFF,_custom+intreq						| ack all interrupts
		bsr			platform_init					| amiga-specific init
		move.l	misc_flags(pc),d0
		btst	#2,d0
		sne		is_super_xevious
		move.l	cheat_flags(pc),d0
		btst	#0,D0
		sne		invincible_flag
		btst	#1,D0
		sne		infinite_lives_flag
		btst	#2,D0
		sne		reveal_sol_tower_flag
		btst	#3,D0
		sne		reveal_bonus_flag_flag
		
0:
		move.w	start_area_option+2,start_area
		jmp			xevious_reset					| pass control to the xevious core
		
title_display:
* we're not doing things the NeoGeo way
    rts

_player_start:
* we're not doing things the NeoGeo way
		rts
				
_demo_end:
* we're not doing things the NeoGeo way
		rts
	
				
_vblank:
    movem.l d0-d7/a0-a6,-(a7)
	move.w	_custom+intreqr,d0
	btst	#5,d0
	beq.b		1f

	move.l	_joypad_state(pc),d1
	moveq	#1,d0
	jsr	_read_joystick
	move.l	d0,_joypad_state
	btst	#JPB_BTN_PLAY,d0
	beq.b	0f
	btst	#JPB_BTN_PLAY,d1
	bne.b	0f
	bsr		toggle_pause
0:

	* if music loops, no need to play it again and again
	* ticks aren't important either
	tst.b	music_loops
	bne.b	13f
	* here music doesn't loop. We have to stop it when it ends
	move.w	music_tick(pc),d1
	beq.b	13f
	subq.w	#1,d1
	move.w	d1,music_tick
	bne.b	13f
	* only music that doesn't loop: intro music
	* now it's over so let other tunes play
	clr.b	sound_lock
	move.l	misc_flags(pc),d2
	btst	#1,d2
	beq.b	13f
	* don't play in-game loop
	move.w	#SOLVALOU_SND,d0
	bsr		osd_sound_stop
13:
	move.w	#0x20,_custom+intreq	
	bra.b	3f
1:
	* has to be copper
	* we're going to ack copper interrupt now
	move.w	#0x10,_custom+intreq
	
	moveq	#ONE_TICK,d1
    move.w  vbl_counter(pc),d0
    addq.w  #1,d0
    cmp.w   #5,d0
    bne.b   22f
    * update a second time, simulate 60Hz
	moveq	#ONE_TICK*2,d1
	clr.w d0    
22:
	move.b	d1,vb_ticks_count
    move.w  d0,vbl_counter
	
	tst.b	pause_flag
	bne.b	23f
	
	jsr		xevious_im1_irq
	.ifne  OPT_ENABLE_DOUBLE_BUFFERING
	bsr		switch_screen_buffers
	.endif
23:
	* now we check copper interrupt again
	move.w	_custom+intreqr,d0
	btst	#4,d0
	beq.b	3f		| clear: ok
	* copper interrupt has been called, which means that
	* rendering was so slow that we couldn't cope within a frame
	* skip a tick and ack again, we lose one update frame
	addq.b	#ONE_TICK,vb_ticks_count
	move.w	#0x10,_custom+intreq
3:
    movem.l (a7)+,d0-d7/a0-a6
	
    rte


osd_sound_mute:
	st.b	sound_muted
	rts
	
osd_sound_unmute:
	clr.b	sound_muted
	rts
	
osd_sound_start:
	movem.l	d0/a0/a6,-(a7)
	tst.b	sound_lock
	bne.b	1f
	* coin sound overrides muted sound
	* (but not locked sound when start music is playing)
	cmp.w	#COIN_SND,d0
	beq.b	0f
	tst.b	sound_muted
	bne.b	1f
0:	
	lea		_custom,a6
	lsl.w	#3,d0
	lea		sound_table(pc),a0
	move.w	(a0,d0.w),d1	| sound type
	beq.b	1f		| no sound

	cmp.w	#SOLVALOU_SND*8,d0
	bne.b	10f
	move.l	misc_flags(pc),d2
	btst	#1,d2
	beq.b	2f
	bra.b	1f		| don't play annoying sound loop
10:
	cmp.w	#ANDOR_GENESIS_SND*8,d0
	bne.b	11f
	* andor genesis is also special, we need to workaround
	* the constant replay and let the replayer "loop"
	move.w	andor_genesis_cnt(pc),d2
	beq.b	12f
	subq.w	#1,d2
	move.w	d2,andor_genesis_cnt
	bra.b	1f
12:
	* andor not playing: play (not perfect, but does the job)
	move.w	#50,andor_genesis_cnt
	bra.b	2f
11:
	cmp.w	#MAIN_THEME_SND*8,d0
	bne.b	2f
	* special case: we have to lock solvalou
	* looped music (and all other sounds!!)
	* until this one has ended
	st.b	sound_lock
2:
	cmp.w	#1,d1
	bne.b	3f		| music module
	move.l	(4,a0,d0.w),a0
	lea		_custom,a6
	jsr		_mt_playfx
1:
	movem.l	(a7)+,d0/a0/a6
	rts
3:
	* don't play if already playing
	* (music_tick value is not important for looped tunes
	* as long as it's not zero)
	tst.w	music_tick
	bne.b	4f
	* play the proper module pattern
	* load up the countdown if loop
	move.w	(2,a0,d0.w),d1	| pattern number in .mod file
	move.w	(4,a0,d0.w),d2
	move.b	(6,a0,d0.w),music_volume
	move.b	(7,a0,d0.w),music_loops
	move.w	d1,music_pattern
	move.w	d2,music_duration
	* since it's not zero, next vbl tick will play the music
	move.w	d2,music_tick
	move.w	d1,d0
	bsr		play_music
4:
	bra.b	1b

andor_genesis_cnt:
	.word	0
	
* sound stop is only called on sounds that are
* actually tunes. It's also called on bomb but we'll skip it
* that since it's harmful to music replay
osd_sound_stop:
	movem.l	d0/a6,-(a7)
	cmp.w	#BOMB_SND,d0
	beq.b	0f		| stop bomb sound makes no sense and stops the music!!
	lea		_custom,a6
    clr.w   music_tick   | not playing anymore
	clr.b	music_playing
    jsr		_mt_end
0:
	movem.l	(a7)+,d0/a6
	rts
	
* < D0: track start number
play_music:
    movem.l d0-a6,-(a7)
    lea _custom,a6
    lea	xevious_tunes,a0
	move.w	d0,music_track_start_number
    sub.l   a1,a1		| samples are in the module
    jsr _mt_init
    * set master volume a little less loud if needed
    moveq	#0,d0
	move.b	music_volume(pc),d0
    jsr	_mt_mastervol
	st.b	music_playing
0:
    jsr _mt_start
    movem.l (a7)+,d0-a6
    rts
	
osd_kick_wdog:
    rts
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING
switch_screen_buffers:	
	* let's switch screen buffers
	* toggle fg planes (double buffering)
	lea		fg_drawed_screen_ptr(pc),a0
	lea		fg_displayed_screen_ptr(pc),a4
	lea		fg_screen_data_1,a1
	lea		fg_screen_data_2,a5
	* also switch previous state memory
	lea		previous_sprite_state_1(pc),a3
	lea		previous_sprite_state_ptr(pc),a2
	cmp.l	(a0),a1
	bne.b	2f
	* screen data 1 is displayed screen
	* set it to drawn screen
	exg		a1,a5
	lea		previous_sprite_state_2(pc),a3
2:
	move.l	a3,(a2)
	move.l	a1,(a0)
	move.l	a5,(a4)
	bra		set_fg_bitplanes
	.endif
	
store_system:
	tst.l	_resload
	beq.b	0f
	rts
0:
	* system copper
	
	move.l	4,a6
	lea	zero_vbr(pc),a5
	jsr		_LVOSupervisor(a6)

	lea	_custom,a6
	move.w	intenar(a6),old_intena
	move.w	dmaconr(a6),old_dmacon
	lea		old_sysvectors,a0
	move.l	0x64.w,(a0)+
	move.l	0x68.w,(a0)+
	move.l	0x6c.w,(a0)+
	move.l	0x70.w,(a0)+
	move.l	0x74.w,(a0)+
	move.l	0x78.w,(a0)+
	rts

restore_system:
	lea	_custom,a6
	jsr		_mt_remove_cia

	move.w	#0x4000,intena(a6)	| ints off
	lea		old_sysvectors,a0

	move.l	(a0)+,0x0064
	move.l	(a0)+,0x0068
	move.l	(a0)+,0x006c
	move.l	(a0)+,0x0070
	move.l	(a0)+,0x0074
	move.l	(a0)+,0x0078


	bclr	#6,0xbfee01

	move.l	old_vbr,d0
	movec	D0,vbr

	lea	_custom,a6
	move.w	old_intena,d0			| get old val
	and.w	#0x3fff,d0
	eor.w	#0x3fff,d0
	move.w	d0,intena(a6)		| clr bits
	eor.w	#0x3fff,d0
	or.w	#0xc000,d0		
	move.w	d0,intena(a6)		| set bits and main

	move.w	old_dmacon,d0			| get old val
	and.w	#0x3fff,d0
	eor.w	#0x3fff,d0

***		and.w	#0xfff0,d0		| preserve sound dma for now

	move.w	d0,dmacon(a6)		| clr bits



	eor.w	#0x3fff,d0
	or.w	#0xc000,d0		
	move.w	d0,dmacon(a6)		| set bits and main

	move.l	old_syscoplist,cop1lc(a6)
	move.l	_gfxbase,a6
	move.l	old_actiview,a1
	jsr	_LVOLoadView(a6)


	moveq	#0,d0
	rts

quit_to_os:
	bsr		restore_system
	move.w	#0,SR
	move.l	old_stack(pc),a7
	bsr		save_highscores
	moveq	#0,d0
	rts
	
zero_vbr:
	movec	vbr,d0
	move.l	d0,old_vbr
	moveq	#0,d0
	movec	D0,vbr
	rte

platform_init:
	bsr		store_system
	
	lea		_custom,a5
	move.w	#0x7FFF,dmacon(a5)
	* set blitter parameters once and for all
	.ifndef	VARIABLE_BLITTER_MASKS_AND_MODS
    move.l  #-1,bltafwm(a5)
	clr.w	bltamod(a5)		|A modulo=bytes to skip between lines
	clr.w	bltbmod(a5)		|B modulo=bytes to skip between lines
	.endif
	
	* restrict borders: we don't see bobs on the borders!
    move.w #0x1C99,diwstrt(a5)
    move.w #0x3881-8,diwstop(a5)
    move.w #0x0038,ddfstrt(a5)
    move.w #0x00D0,ddfstop(a5)
    #move.w #0x0210,bplcon0(a5)  
    move.w #0x0610,bplcon0(a5) | 8 bitplanes, dual playfield
	
    move.w #0xf,fmode(a5)  		| AGA fastest fetch mode for bitplanes & sprites
	
	* there's a 2-pixel shift between foreground layer
    * and background layer, can be seen in the title
	* screen with XEVIOUS bg/fg tiles
    move.w #2<<4,bplcon1(a5)    | foreground tiles shifted by 2 pixels
	* 2nd (foreground tiles & sprites) playfield has priority
	* solvalou sprites (0-1) have priority on sprites, others (andor/bragza) don't
    move.w #0x004f,bplcon2(a5)
    move.w #BASE_BPLCON3_VALUE,bplcon3(a5)	| color bank offset for playfield 2
	move.w	#0x32,bplcon4(a5)	| odd sprites palette start at color 48, even at 32
	move.w	#-8,d0
    move.w d0,bpl1mod(a5)
    move.w d0,bpl2mod(a5)

	bsr		create_direction_table
	bsr		set_fg_bitplanes
	bsr		set_bg_bitplanes

	
	* set copperlist
	move.l	#copperlist,cop1lc(a5)
	* load palette
	lea		palette(pc),a0
	clr.w	d0
	bsr		set_aga_color_registers	
	move.w	#0x200,d0	| LOCT: 1
	bsr		set_aga_color_registers	
	
    * init sprite, bitplane, whatever dma
	* now it's no longer possible to change
	* palette dynamically because copperlist
	* changes banks & LOCT flag on top of the frame
    move.w #0x83E0,dmacon(a5)

	* install keyboard and vblank/copper handler
	pea		level2_interrupt(pc)
	move.l	(a7)+,0x68.W
	pea		_vblank(pc)
	move.l	(a7)+,0x6C.W

	* soundfx lib
	lea		_custom,a6
	sub.l	a0,a0	| we know vbr=0
	moveq	#1,d0	| PAL
	jsr		_mt_install_cia

	.ifne	OPT_ENABLE_PROFILING
	* init profiling if enabled
	lea		0x180000,a0
	move.l	#0x20000,d0
	lea		0x100,a1
	bsr		init_fixed_address
	bsr		install_profiler_vbl_hook
	.endif

	
    rts

load_ingame_tile_palette:
	lea		palette,a0
	clr.w	d0
	bsr		load_first_16_colors
	add.w	#32,a0	| skip 16 colors
	move.w	#0x200,d0
	bsr		load_first_16_colors
	rts
	
load_title_tile_palette:
	lea		title_palette,a0
	clr.w	d0
	bsr		load_first_16_colors
	move.w	#0x200,d0
	bsr		load_first_16_colors
	rts
	
* D0: LOCT 0/0x200
* A0: out updated by 32
load_first_16_colors:
	movem.l	d0-d1/a1,-(a7)
	lea		_custom,a5
	* shut off dma to avoid conflicts with copperlist
	move.w	#0x4000,dmacon(a5)
    or.w  #BASE_BPLCON3_VALUE,d0
	move.w	d0,bplcon3(a5)
	move.w	#15,d0
	lea		color(a5),a1
1:
	move.w	(a0)+,(a1)+
	dbf		d0,1b
	move.w	#BASE_BPLCON3_VALUE,bplcon3(a5)
	move.w	#0x8000,dmacon(a5)
	movem.l	(a7)+,d0-d1/a1
	rts
	
* < a0: source palette
* < d0: LOCT mask 0 or 0x200
set_aga_color_registers:
	move.w	#TOTAL_NB_COLORS,d1
	moveq	#0,d2
	lea		_custom,a5
	move.w	d2,d7
	move.w	d0,d2
	move.w	d1,d0
    lsr.w   #5,d1   | divide by 32
    and.w   #0x1F,d0
    beq.b   1f
    addq.w   #1,d1  | not a multiple of 32
1:
    * set AGA color bank
    move.w  d7,d0
    lsl.w   #8,d0
    lsl.w   #5,d0
	or.w	d2,d0
	or.w	#BASE_BPLCON3_VALUE,d0
    move.w  d0,bplcon3(a5)
    lea color(a5),a1
    * now set the colors for that bank
    move.w  #31,d0 
2:
    move.w  (a0)+,(a1)+
    dbf d0,2b
    addq.w  #1,d7
    cmp.w   d1,d7
    bne.b   1b
    
    * reset bank so copperlist can work on base ECS bank
    move.w  #BASE_BPLCON3_VALUE,bplcon3(a5)
    rts

* 60Hz VBLANK interrupt (also keyboard)
osd_enable_vblank_interrupt:
	move.w	#0xC038,_custom+intena
	rts

osd_ack_vblank_interrupt:
	move.w	#0x30,_custom+intreq
 	rts
		
osd_disable_vblank_interrupt:
	move.w	#0x0030,_custom+intena
	rts
		
* d0=offset (preserved), d1=attribute (preserved)
osd_w_fg_colorram:
    .ifeq OPT_DISABLE_FG_LAYER
	movem.l	d0-d7/a0-a1,-(a7)
	lea		fg_colorram,a1
	move.b	d1,(a1,d0.w)	| store color X/Y flip attribute in fg table
	lea		fg_videoram,a1
	move.b	d1,d2
	move.b	(a1,d0.w),d1	| fetch tile from character grid
	* now update tile to reflect the color change
	moveq	#FG_TILE_DRAW_COLOR,d3
	bsr	update_fg_tile
	movem.l	(a7)+,d0-d7/a0-a1
   .endif | OPT_DISABLE_FG_LAYER
	rts

		
* the first 4 rows are not visible, then the next 36 rows
* are visible. Screen is 32 tiles wide but only 28 visible.
*  Bottom 6 bits of D0 is the row, upper 5 bits are the column.
* d0=offset (preserved), d1=tile (preserved)
osd_w_fg_videoram:
    .ifeq OPT_DISABLE_FG_LAYER
	movem.l	d0-d7/a0-a2,-(a7)
	lea		fg_videoram,a2
	* optimization: if wants to write the same tile, just don't
	* also avoids that sprites are (too much) trashed on the top row
	* because of perpetually redrawing "1UP" line
	*
	* color changes are handled in colorram routine (and use dynamic color 17)
	*
	cmp.b	(a2,d0.w),d1
	beq.b	1f
	move.b	d1,(a2,d0.w)	| update logical grid
	lea		fg_colorram,a1
	move.b	(a1,d0.w),d2	| color & X/Y flip data
	moveq	#FG_TILE_DRAW_FULL,d3
	bsr		update_fg_tile
1:
	movem.l	(a7)+,d0-d7/a0-a2
    .endif | OPT_DISABLE_FG_LAYER
	rts

* d0=offset (preserved), d1=attribute (preserved)
osd_w_bg_colorram:
    .ifeq OPT_DISABLE_BG_LAYER
	movem.l	d0-d1/d7/a0-a1,-(a7)
	lea		bg_colorram,a1
	move.b	d1,(a1,d0.w)	| store attribute in bg table
	lea		bg_videoram,a1
	move.b	d1,d2
	move.b	(a1,d0.w),d1	| fetch tile from character grid
	bsr.b	update_bg_tile
	movem.l	(a7)+,d0-d1/d7/a0-a1
   .endif | OPT_DISABLE_BG_LAYER
	rts

* d0=offset (preserved), d1=tile (preserved)
* must preserve A0 and D7 too
osd_w_bg_videoram:
    .ifeq OPT_DISABLE_BG_LAYER
	movem.l	d0-d1/a0,-(a7)
	lea		bg_videoram,a1
	* dump both tables (color+char): S bg_data <address@0x110> $1000
	add.w	d0,a1
	cmp.b	(a1),d1
	beq.b	0f		| already the proper value
	move.b	d1,(a1)	| update logical grid
	lea		bg_colorram,a1
	move.b	(a1,d0.w),d2	| color & X/Y flip data
	bsr.b		update_bg_tile
0:
	movem.l	(a7)+,d0-d1/a0
    .endif | OPT_DISABLE_BG_LAYER
	rts

	
.macro	CLEAR_TILE
	.set	offset,0
	.rept	8
	clr.b	(offset,a1)
	clr.b	(offset,a2)
 	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	.endm
.macro	CLEAR_TILE_NO_MIRROR
	.set	offset,0
	.rept	8
	clr.b	(offset,a1)
 	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	.endm
.macro	STRAIGHT_BG_TILE
	.set	offset,0
	.rept	2
	move.l	(a0)+,d0
	move.b	d0,(3*NB_BYTES_PER_ROW+offset,a1)
	.ifne	BG_MIRROR
	move.b	d0,(3*NB_BYTES_PER_ROW+offset,a2)
	.endif
	lsr.l	#8,d0
	move.b	d0,(2*NB_BYTES_PER_ROW+offset,a1)
	.ifne	BG_MIRROR
	move.b	d0,(2*NB_BYTES_PER_ROW+offset,a2)
	.endif
	lsr.l	#8,d0
	move.b	d0,(1*NB_BYTES_PER_ROW+offset,a1)
	.ifne	BG_MIRROR
	move.b	d0,(1*NB_BYTES_PER_ROW+offset,a2)
	.endif
	lsr.w	#8,d0
	move.b	d0,(offset,a1)
	.ifne	BG_MIRROR
	move.b	d0,(offset,a2)
	.endif
	.set	offset,4*NB_BYTES_PER_ROW
	.endr
	.endm
	
.macro	FLIPPED_BG_TILE
	.set	offset,NB_BYTES_PER_ROW*4
	.rept	2
	* get all planes at once in d0
	* then shift bits to get individual bytes
	move.l	(a0)+,d0
	move.b	d0,(offset,a1)
	.ifne	BG_MIRROR
	move.b	d0,(offset,a2)
	.endif
	lsr.l	#8,d0
	move.b	d0,(1*NB_BYTES_PER_ROW+offset,a1)
	.ifne	BG_MIRROR
	move.b	d0,(1*NB_BYTES_PER_ROW+offset,a2)
	.endif
	lsr.l	#8,d0
	move.b	d0,(2*NB_BYTES_PER_ROW+offset,a1)
	.ifne	BG_MIRROR
	move.b	d0,(2*NB_BYTES_PER_ROW+offset,a2)
	.endif
	lsr.w	#8,d0
	move.b	d0,(3*NB_BYTES_PER_ROW+offset,a1)
	.ifne	BG_MIRROR
	move.b	d0,(3*NB_BYTES_PER_ROW+offset,a2)
	.endif
	.set	offset,0
	.endr
	.endm
	
* d0: offset
* d1: tile code (0-256 but extends to 512 with bit 0 of attribute)
* d2: attribute (0-255, color is in bits 0-5, X/Y flip in 6:7)
update_bg_tile:
	* first check if we must toggle lower 16 palette between title
	* and in-game
	* (also changes behaviour of the buttons)
	cmp.b	#0xCD,bg_videoram+0x60E
	beq.b	2f
	* in-game
	tst.b	ingame_palette_loaded
	bne.b	3f
	bsr		load_ingame_tile_palette
	st.b	ingame_palette_loaded
	bra.b	3f
2:
	* title
	tst.b	ingame_palette_loaded
	beq.b	3f
	bsr		load_title_tile_palette
	clr.b	ingame_palette_loaded	
3:	
	* discard everything not in column range
	move.w	d0,d3
	lsr.w	#6,d3
	neg.w	d3
	add.w	#32-3,d3	| mirror
	bmi.b		0f
	cmp.w	#28,d3
	bcs.b	1f
0:
	rts
1:
	lea		_bg_tile,a0
	and.l	#0xFF,d1
	btst	#0,d2
	beq.b	2f
	bset	#8,d1	| upper part of background tile code
2:
	.ifne  OPT_ENABLE_LOGGING
	move.l	a0,0x120
	* log the tile, use start address in 0x114 then
	* S bg_tile_log <address> !64*!512
	lea		bg_tile_log,a1
	move.l	a1,0x114
	movem.l	d1/d2,-(a7)

	lsl.w	#6,d1		| times 64, 128 cluts but depend on bit 4
	add.w	d1,a1

	and.w	#0x3F,d2	| significant color bits
	move.b	#0xDD,(a1,d2.w)
	movem.l	(a7)+,d1/d2
	.endif

	* compute clut index in d3
	* by descrambling the bizarre encoding
	move.b	d2,d3
	and.w	#0x3F,d3	| keep only 5:0 bits
	lsr.b	#2,d3
	move.b	d2,d4
	and.b	#3,d4
	lsl.b	#5,d4	| high color bits
	or.b	d4,d3	| add them back
	btst	#7,d1
	beq.b	22f
	* bit 4 of the colour is derived from bit 7 of the videoram byte
	bset	#4,d3	| add bit 4 if tile id & 0x80 != 0 (????)
22:

	* now d3 is the index, mul by 2 to get row pointer offset
	add.w	d3,d3
	* d1 times 256 (<<8) is the row start pointer
	lsl.l	#8,d1
	
	add.l	d1,a0		| row offset
	add.w	d3,a0		| col offset
	tst.w	(a0)
	bne.b	7f
	* tile is not known with that CLUT configuration: flash
	**move.w	#0,bplcon3+_custom
	**move.w	#0xF00,color+_custom
	lsr.l	#8,d1
	lsr.l	#1,d3		| column
	lea		_bg_tile,a1
	
	tst.b	unknown_tile_found
	bne.w	9f
	st.b	unknown_tile_found
	bra.w	9f
7:
	move.w	(a0),a0
	move.w	d0,d1
	subq.w	#2,d1
	bmi		update_bg_tile_out

	moveq	#NB_PLAYFIELD_PLANES-1,d3

	;;and.w	#0x3F,d1		| row
	cmp.w	#NB_VISIBLE_ROWS,d1
	bcc.w	bg_no_mirror
	* convert coords to address
	GET_XY_ADDRESS		bg_screen_data-NB_BYTES_PER_ROW*4
	* duplicate display (scrolling)
	lea		(BG_SCREEN_PLANE_SIZE/2.W,a1),a2

	cmp.w	#1,a0
	beq		8f		| blank (optim)

	add.l	#bg_picbase,a0   | pointer on tile data
	btst	#7,d2			 | X-flip?
	beq.b	3f
	addq.w	#4,a0			 | mirror version
3:	
	move.l	(a0),a0			 | tile data
	* draw
	btst	#6,d2    | Y-flip
	jne	5f

4:
	tst.b	(a0)+
	jeq	6f
BG_MIRROR=1
	STRAIGHT_BG_TILE
1:
    lea   (BG_SCREEN_PLANE_SIZE.W,a1),a1
    lea   (BG_SCREEN_PLANE_SIZE.W,a2),a2
    dbf d3,4b
	rts
6:
	CLEAR_TILE
	bra.b	1b
	
5:   | y-flip
	tst.b	(a0)+
	beq.b	6f


	FLIPPED_BG_TILE
BG_MIRROR = 0
1:
	lea		(BG_SCREEN_PLANE_SIZE.W,a1),a1
	lea		(BG_SCREEN_PLANE_SIZE.W,a2),a2
    dbf		d3,5b
update_bg_tile_out:
	rts

6:
	CLEAR_TILE
	bra.b	1b

8:	
	CLEAR_TILE
   lea   (BG_SCREEN_PLANE_SIZE.W,a1),a1
   lea   (BG_SCREEN_PLANE_SIZE.W,a2),a2
    dbf d3,8b
9:
	rts
	
	* same thing but without updating the mirror plane
	* as it will never be displayed (used only to simulate
	* the tile display hardware wrap so no need to go until
	* 64 rows for the mirror, only 36 are enough
bg_no_mirror:
	* convert coords to address with proper shift vs foreground
	GET_XY_ADDRESS		bg_screen_data-NB_BYTES_PER_ROW*4

	cmp.w	#1,a0
	beq		8f		| blank (optim)

	add.l	#bg_picbase,a0   | pointer on tile data
	btst	#7,d2			 | X-flip?
	beq.b	3f
	addq.w	#4,a0			 | mirror version
3:	
	move.l	(a0),a0			 | tile data
	* draw
	btst	#6,d2    | Y-flip
	bne	5f
4:
	tst.b	(a0)+
	jeq	6f
	STRAIGHT_BG_TILE
1:
    lea   (BG_SCREEN_PLANE_SIZE.W,a1),a1
    dbf d3,4b
	rts
6:
	CLEAR_TILE_NO_MIRROR
	bra.b	1b
	
5:   | y-flip
	tst.b	(a0)+
	beq.b	6f

	FLIPPED_BG_TILE
1:
	lea		(BG_SCREEN_PLANE_SIZE.W,a1),a1
    dbf		d3,5b
	rts

6:
	CLEAR_TILE_NO_MIRROR
	bra.b	1b

8:	
	CLEAR_TILE_NO_MIRROR
   lea   (BG_SCREEN_PLANE_SIZE.W,a1),a1
    dbf d3,8b
9:
	rts
		
FG_TILE_DRAW_COLOR = 0
FG_TILE_DRAW_FULL = 1
FG_TILE_CLEAR = 2

* d0: offset
* d1: tile code
* d2: attribute (note: vertical flip attribute isn't
*     used, only for cocktail mode, so not tested here)
* d3: draw mode (see FG_TILE_DRAW... above)
* most other registers are killed

update_fg_tile:
	and.w	#0xFF,d1
	lea		_fg_tile,a0
	cmp.w	#BLANK_FG_TILE_ID,d1
	bne.b		0f
	move.w	#FG_TILE_CLEAR,d3
	move.w	d0,d1	
	bra.b	2f
0:
	move.w	d1,d6		| save tile ID unchanged
	lsl.w	#4,d1			| *16 (each tile+mirror tile has 8+8 bytes)
	btst	#6,d2			| X-flip?
	beq.b	1f
	add.w	#8,d1			| mirror version
1:
	add.w	d1,a0
	move.w	d0,d1
2:
	and.w	#0x3F,d1		| row
	subq.w	#4,d1
	bmi.w	3f

	cmp.w	#36,d1		| limit to 36th row, rest is not displayed
	bcc.w	3f
	cmp.w	#FG_TILE_CLEAR,d3
	beq	4f
	
	move.w	d2,d4
	* decode color
	and.w	#0x3F,d2	| drop flip x/y bits
	move.w	d2,d5
	lsr.w	#2,d2		| 5:2 => 3:0
	and.w	#0x3,d5		| keep 5:4
	lsl.w	#4,d5		| at proper position
	or.w	d5,d2		| combine
	lea		original_palette(pc),a1	| original palette (upper nibble)
	.ifdef	NO68020
	add.w	d2,d2
	move.w	(a1,d2.w),d2
	.else
	move.w	(a1,d2.w*2),d2
	.endif
	* update color for that row
	lea	_fg_color_table,a1
	tst	d1
	beq.b	0f		| don't update row 0
	.ifdef	NO68020
	move.w	d1,d5
	add.w	d5,d5
	add.w	d5,d5
	move.l	(a1,d5.w),a1
	.else
	move.l	(a1,d1.w*4),a1	
	.endif
	move.w	d2,(a1)			| color palette index
	
0:
	cmp.w	#FG_TILE_DRAW_COLOR,d3
	bne.b	4f
	* no need to draw tile, called from color change
	* (saves cycles)
	rts
4:
	* convert D0 (native game offset, difficult to work with)
	* into X,Y (native amiga)
	GET_XY_FROM_OFFSET
	subq.w	#2,d1
	add.w	d1,d1		| Y *= 2
	* mark tile row as modified, must be checked 3 times
	lea		fg_refresh_tile_row_table(pc),a1
	move.b	#3,(1,a1,d1.w)
	* mark tile as modified in our amiga-friendly table (32x64,
	* transposed compared to original table)
	*
	* code:
	*
	* 0: no need to draw anything 
	* > 0: need to delete zone a number of times 
	*       (double buffering!, decreased by consumer of that table)
	* 0xFF: need to delete then update with bitmap data
	lea		fg_refresh_tile_table(pc),a1
	* X/Y offsets
	move.w	d1,d4
	lsl.w	#4,d4	| Y*2*16
	add.w	d4,a1
	
	st	d4
	cmp.w	#FG_TILE_CLEAR,d3
	bne.b	41f
	* set number of times to clear the zone
	* 2 is the minimum to update both layers (double buffering)
	* but 3 is safer on slow configurations just in case it skips
	* a frame
	moveq	#3,d4
41:
	move.b	d4,(a1,d0.w)	| modify flag for that tile
	
	* we have amiga D0=X,D1=Y*2 now get plane offset to change tile data
	* now multiply D1 by 32*4

	lsl.w	#7,d1
	* add y offset to screen data	
	add.w	d1,d0		

	lea		fg_tile_layer,a1
	add.w	d0,a1
	cmp.w	#FG_TILE_DRAW_FULL,d3
	bne.b	5f   | tile clear

	
	* draw
	.set	offset,0
	.rept		8
	SET_FG_BYTE
	.set	offset,offset+NB_BYTES_PER_FG_ROW
	.endr
3:
	rts

5:

	* clear

	.set	offset,0
	.rept		8
	clr.b	(offset,a1)
	.set	offset,offset+NB_BYTES_PER_FG_ROW
	.endr
	rts

not_mask:
	.long	0,0
		
* row/screen fg tile flags. Part of highly optimized tile refresh
* to avoid 1) redrawing everything 2) scanning for changes in 36*32 cells
* all the time, when most of the time row is empty or not changing
*
* list of row flags. 2 bytes per row.
* first byte: refresh flags. Bit 0: must clear, bit 1: must redraw too
* second byte: number of times row must be checked (because of
* double buffering, this has to be >= 2). This allows to avoid checking row
* status if nothing has changed in the row.

fg_refresh_tile_row_table:
	ds.b	64*2

* flags in a matrix. Row is fully checked when a tile is written somewhere
* in the row (setting the counter flag in fg_refresh_tile_row_table to do it
* only a few number of times, after that no need to recompute row status)
fg_refresh_tile_table:
	ds.b	0x800
	
* d6 = bg_scroll_x_shadow
osd_update_scroll_hw:
	move.w	d6,scroll_offset
	* add to planes offset & change copperlist
	bra		set_bg_bitplanes



* a5=obj_tbl
osd_update_sprite_shadow:
	lea       sprite_shadow_msb,a2
	lea		current_sprite_state(pc),a4
	* a4 is the internal sprite structure which is updated
	* in this routine. Each sprite structure occupies 16 bytes
	moveq			#NB_SPRITES_TOTAL-1,d7
1:
	move.b	(_STATE,a5),d0
	cmp.b	#STATE_INACTIVE,d0
	bne.b	11f
	* deactivate
    move.b    #0xef,(0,a2)   | code from Mark to avoid spurious
    move.b    #(8>>1),(1,a2) | explosions when creating objects
	 
	move.b	#STATE_DO_NOT_UPDATE_SHADOW,(_STATE,a5)
	clr.w	(_X,a5)
	clr.w	(_Y,a5)
	move.b	d0,(a4)	| inactive
	bra.b	3f
11:
	cmp.b	#STATE_DO_NOT_UPDATE_SHADOW,d0
	beq.b	3f
	move.b	d0,(a4)+
	move.b	(_ATTR,a5),(a4)+
	move.b	(_CODE,a5),(a4)+
	move.b	(_COLOUR,a5),(a4)+
	move.w	(_Y,a5),d2
	lsr.w	#5,d2		| d2: Y[7:0]
    *** THIS IS MANDATORY IN EVERY PORT
	* (copied from neogeo code, not sure of how or why it works)
    move.b    #0xef,d3                          | arcade adjustment
    sub.b     d2,d3                             | arcade adjustment
    move.b    d3,(a2)+                          | store Y[7:0] for hit-box calcs
    *** END OF MANDATORY

	move.w	(_X,a5),d1
	lsr.w	#5,d1
    move.w    d1,d3
    *** THIS IS MANDATORY IN EVERY PORT
    addq.w    #8,d3    
    lsr.w     #1,d3
    move.b    d3,(a2)+                          | store X[8:1] for hit-box calcs
    *** END OF MANDATORY
	move.w	d1,(a4)+

	* mirror prior to store Y for amiga display
	neg.w	d2
	add.w	#32*8,d2
	move.w	d2,(a4)+
	addq.w	#4,a4		| skip 4 last bytes of the structure
2:	
	lea		(_OBJSIZE.W,a5),a5
	dbf				d7,1b
	rts
3:
	lea	(SPRITE_MEM_SIZE.W,a4),a4
	addq.w	#2,a2
	bra.b	2b
	
	*.include	"ag_test.68k"

out:
	rts
	
* d0 = base sprite number (0/32)
*
* Since sprites aren't really sprites but BOBs
* updating only the relevant half of
* the sprites trashes the other half when pre-erasing
* the latter sprites if some sprites had been previously
* drawed here. This and also leftovers of BOBs when player
* is killed. So, too complicated, let's update everything
* just store the previous positions only by half (because the
* others aren't updated anyway)

	.include	"hw_sprite_types.68k"


osd_update_32_sprite_hw:
	move.w	d0,d7
	bne.b	0f
	* reset number of active bobs only at first call
	clr.w	nb_active_bobs
	* clear first plane (fg tiles) prior to sprite draw. Because we're going to
	* apply blitted OR in the end, so if something changes, we need to remove it
	* also, if a tile is cleared, it's cleared here, and not redrawn
	*
	* we can clobber all registers here (we're going to need them)
	.ifeq	OPT_DISABLE_FG_LAYER
	move.l	d7,-(a7)
	jbsr	clear_fg_tiles	
	move.l	(a7)+,d7
	.endif
0:
	.ifeq		OPT_DISABLE_SPRITES
	lea		current_sprite_state(pc),a4
	.ifne	OPT_ENABLE_LOGGING
	move.l	a4,0x140
	.endif
	
	** S sprite_log <address> !12*!64
	**lea		ag_sprites(pc),a4
	move.l		previous_sprite_state_ptr(pc),a5
	lea			is_hw_sprite_table,a6
	
	* first clear playfield behind the previous
	* positions of the previously active objects
	* only if D0=0 (ground objects pass)
	tst.w	d7
	bne.w	12f
	movem.l	d2-d5/a0-a2/a5,-(a7)
	move.w	#NB_SPRITES_TOTAL-1,d3
2:
	cmp.b	#STATE_INACTIVE,(a5)
	beq.w	11f
	clr		d0
	move.b	(2,a5),d0    | sprite tile code (8 first bits)
	tst.b		(1,a5)   | sprite attributes	
	bpl.b	222f
	* second bank: add 256 to sprite tile code
	bset	#8,d0
222:
	tst.b	(a6,d0.w)
	bne.w	11f		| real sprite: skip erase
	* erase previous sprite position (but not if sprite type
	* is hardware sprite)
	move.w	(4,a5),d1   | Y
	* 32 first Y pos aren't displayed
	* also add -2 y offset to allow proper erase too
	sub.w	#4*8+2,d1
	bpl.b		3f
	moveq	#0,d1		| fix issues with non deleted objects at top	
3:
	
	move.w	#4,d2	| width
	* depending on double height/width properties, double amounts
	move.b	(1,a5),d0	| attributes
	* it's better to optimize erase height
	* but doing that when d1 = 0 causes issues so skip
	* the height change in that case (and also if double width
	* and height)
	*
	* the erase optimization is already very efficient with
	* solvalou shots and enemy bullets which have a small height
	*
	tst.w	d1
	beq.b	30f
	and.b	#3,d0
	beq.b	310f	| not double height, not double width: can optimize height
30:
    move.w  #16,d4		| max single size height
	
	btst	#0,d0		| double width (height on rotated display)
	beq.b	31f
	* add to max height (add 1 to make up for remaining pixels not
	* erased at the bottom when solvalou explodes, not sure
	* why it's needed, probably doesn't hurt...)
	add.w	#17,d4
31:
	btst	#1,d0		| double height (width on rotated display)
	beq.b	32f
	add.w	#2,d2
	bra.b	32f
	* simple width & height
	* we optimize height & y-start
310:
	* add Y-offset (possibly 0, but > 0 for shots & small object)
	add.w	(8,a5),d1
	* set exact height (may be smaller than 16)
	move.w	(10,a5),d4
	addq.w	#2,d4
32:
	move.w	(6,a5),d0
	subq.w	#8,d0		| sprite X offset

	movem.l	d3/a5,-(a7)
    lea _custom,a5

	move.l	fg_drawed_screen_ptr(pc),a1
	moveq	#4,d3
	bsr		clear_planes_any_blitter_internal
	movem.l	(a7)+,d3/a5
11:
	lea		(SPRITE_MEM_SIZE.W,a5),a5
	dbf		d3,2b
	movem.l	(a7)+,d2-d5/a0-a2/a5
12:
	* then update the active sprites
	lea		sprite_picbase,a3
	move.l	a4,-(a7)
	move.w	#NB_SPRITES_TO_UPDATE-1,d4
	tst		d7
	beq.b	4f
	* second half
	lea		(SPRITE_MEM_SIZE*NB_SPRITES_TO_UPDATE.W,a4),a4
	* sprite loop
4:
	cmp.b	#STATE_INACTIVE,(a4)
	beq		2f
41:
	move.w	(6,a4),d5	| prepare X
	cmp.w	#31*8,d5
	jcc		2f			| too much on the right
	
	move.w	(4,a4),d1
	sub.w	#4*8,d1		| apply Y offset
	bpl.b	42f
	* explosion too high on screen, probably game
	* bug which reuses previous slot, don't show
	* explosion tiles (113 to 127)
	cmp.w	#113,d0
	bcs.b	42f
	cmp.w	#128,d0
	jcs	2f
42:
	* at this point, Y can be negative, but
	* we allow this as blitter routine is able
	* to perform Y-clipping in that case
	moveq	#0,d3			| clear D3 MSB
	move.w	d1,d3			| save y
	moveq	#0,d0
	move.b	(2,a4),d0	    | sprite code
	move.b	(3,a4),d1	    | sprite color
	move.b		(1,a4),d2   | sprite attributes	
	bpl.b	5f
	* second bank
	bset	#8,d0
5:
* to test a given tile, replace solvalou by that sprite
*	cmp.w	#80,d0
*	bne.b	666f
*	move.w	#248,d0  | tank
*	moveq	#2,d1    | clut 2
*666:
	* fixes glitch: sometimes sprite code + 256 > 320
	* ex: code = 0x7C, attribute = 0x80, X = 0xC0, Y = 0
	* which triggers strange behaviour afterwards
	* like andor quickly flashing...
	cmp.w	#320,d0
	jcc		2f		| bug: second bank but sprite too high
	clr.w	d6
	* tile type (bob, sprite and which sprite type)
	move.b	(a6,d0.w),d6
	
	* uncomment to test bridge (51f), jet (52-54f)
	**bne		51f
	
	cmp.w	#HW_OTHER,d6
	jle		60f		| bob or 16x16 sized sprite: skip specific sprite part

	
	cmp.b	#HW_MASKED_TILE,d6
	jeq		2f
	cmp.b	#HW_BRIDGE,d6
	jeq		51f
	cmp.b	#HW_FLYING_JET_1,d6
	jeq		52f
	cmp.b	#HW_FLYING_JET_2,d6
	jeq		53f
	cmp.b	#HW_FLYING_JET_0,d6
	jeq		54f

	* andor genesis or bridge sprite
	* left or right part
	* D1 is the color code
	
	* for the sprite backup table
	lsl.w	#ACTIVE_SPRITE_STRUCT_BITS,d0

	moveq	#0,d2	| default: no y clipping offset
	
	* debugging that gives strange results. Andor is first displayed at
	* y=$FFE0 the first tile (-32 but first 4 tiles aren't visible so it's more like -64, still
	* not -96 like we would expect so it triggers a bogus display), then it switches to $77A->$7DF, then
	* $FFE0->$FFFF->0 now it's positive...
	* we have to filter out the first appearance where $FFE0 is just bogus.
	* filtering FFE0 all the time leads to a nasty flash when
	* FFE0 is legit (appearing, offset = 32)...	
	* this is handled in "show_sprite" instead
	
	and.w	#0x7FF,d3
	
	cmp.w	#0x700,d3
	blt.b	49f		| okay, upper tile in screen
	* it looks like Y was masked with 0x7FF at some point... restore
	* the negative value, which is at start too high on screen (0xFF7A)
	*
	* this is not very logical but doesn't matter much as we cannot attack
	* the andor when it's appearing, scrolling down, only visuals matter
	or.w	#0xFF00,d3
	* now the value is negative Y, make it a positive offset
	neg.w	d3
	cmp.w	#96,d3
	jbgt		2f		| too high
	move.w	d3,d2
	clr.w	d3		| and displays clipped at y = 0
49:
	cmp.w	#Y_MAX,d3
	jbge	2f			| too low to be seen

	
	cmp.b	#HW_ANDOR_FIRST,d6
	bne.b	50f
	* first left part
	* may be off screen (too high)
	move.l	a3,-(a7)

	lea		andor_genesis_left,a3
	bsr		draw_andor_sprite
	move.l	(a7)+,a3
	jra		2f
50:
	cmp.b	#HW_ANDOR_SECOND,d6
	bne.b	51f
	* second right part
	move.l	a3,-(a7)
	lea		andor_genesis_right,a3
	bsr		draw_andor_sprite
	move.l	(a7)+,a3
	bra.b	2f
51:
	move.l	a3,-(a7)
	lea		bridge,a3
	bsr		draw_32x32_hw_sprite
	move.l	(a7)+,a3
	bra.b	2f
52:
	move.l	a3,-(a7)
	lea		flying_jet_1,a3
	bsr		draw_32x32_hw_sprite
	move.l	(a7)+,a3
	bra.b	2f
53:
	move.l	a3,-(a7)
	lea		flying_jet_2,a3
	bsr		draw_32x32_hw_sprite
	move.l	(a7)+,a3
	bra.b	2f
54:
	move.l	a3,-(a7)
	lea		flying_jet_0,a3
	bsr		draw_32x32_hw_sprite
	move.l	(a7)+,a3
	bra.b	2f

60:
	* BOB or 16x16 sprite (not a special hardware sprite)
	cmp.w	#NB_LINES-15,d3
	bgt.w	2f		| too low

	.ifne  OPT_ENABLE_LOGGING
	* log the sprite, use start address in 0x110 then
	* S sprite_tile_log <address> !128*!320
	* then run the "convert_graphics.py" script
	* to discover the new sprite configurations
	
	lea		sprite_tile_log,a1
	move.l	a1,0x110
	movem.l	d0-d2,-(a7)
	lsl.w	#7,d0		| times 128
	add.l	d0,a1
	and.w	#0x7F,d1	| significant color bits
	bset	#4,d2		| so it's not 0
	move.b	d2,(a1,d1.w)
	movem.l	(a7)+,d0-d2
	.endif

	move.w	(6,a4),d5	| prepare X
	move.w	d2,d6
	and.w	#3,d6
	lea		sprite_draw_jump_table(pc),a0
	.ifdef	NO68020
	add.w	d6,d6
	add.w	d6,d6
	move.l	(a0,d6.w),a0
	jsr		(a0)
	.else
	jsr		([a0,d6.w*4])
	.endif
	
2:
	lea		(SPRITE_MEM_SIZE.W,a4),a4		| next sprite
	dbf		d4,4b

	* now restore all foreground tiles behind the previous
	* positions of the previously active objects
		
	* then back up current object state (X,Y,STATE) for next update
	move.l	(a7)+,a4
	move.w	#NB_SPRITES_TO_UPDATE-1,d0	| 32*SPRITE_MEM_SIZE bytes
	* d7 is 0 or 32
	tst.w	d7
	beq.b	3f
	* second half of sprite data (*8 bytes, /2)
	lea		(NB_SPRITES_TO_UPDATE*SPRITE_MEM_SIZE.W,a4),a4
	lea		(NB_SPRITES_TO_UPDATE*SPRITE_MEM_SIZE.W,a5),a5
3:
	* copy one sprite backup structure (multiple of 4 bytes) 32 times
	** | 12/4 change if SPRITE_MEM_SIZE changes!!
	movem.l	(a4)+,d1/d2/d3
	movem.l	d1/d2/d3,(a5)
	lea		(12,a5),a5

	dbf		d0,3b
	tst.w	d7
	bne.b	31f
	rts
	
31:
	lea		active_hw_sprite_lifetime(pc),a0
	moveq	#7,d7
6:
	move.w	(a0),d0
	beq.b	9f
	subq	#1,d0
	move.w	d0,(a0)
	bne.b	9f
	* sprite lifetime elapsed: hide it
	move.l	(2,a0),a1	| sprite tile number
	* end of life for that sprite
	bsr		hide_sprite
9:
	addq.w	#8,a0
	dbf		d7,6b
	
	.ifeq	OPT_DISABLE_FG_LAYER
	jbsr		redraw_fg_tiles
	.endif

	
	* after displaying real hardware sprite, we scan the possible sprites
	* and decrease the life counter.
	* if the life counter is zero, clear the sprite positions
	* this is required because we cannot rely on the previous state to know that


	.endif  | OPT_DISABLE_SPRITES
	*clr.w	_custom+color
	
	rts
zzz:
			blitz
			rts

BLANK_FG_ROW_START = 3
BLANK_FG_ROW_END = 9

redraw_fg_tiles:
	* in the second pass (D0=32), redraw all foreground tiles
	* where row was marked as "to draw"
	lea		fg_refresh_tile_row_table(pc),a6
	moveq	#0,d7	| row counter (2 by 2, we only need flags)
	moveq	#0,d6	| "in dirty block" flag
	bra.b	11f
	* 2 passes: first compute the first dirty tile
10:
	tst		d6
	beq.b	11f
	move.b	(a6,d7.w),d0
	bne.b	19f		| still dirty
	* this row is clean: compute refresh height
	move.w	d7,d3
	lsr.w	#1,d3	| divide as d7 is doubled
	sub.w	d4,d3	| nb dirty rows
	* D4: first dirty row
	* D5: nb of dirty rows
	clr	d6		| ack flag
	* now refresh screen
	lea		fg_tile_layer,a0
	moveq	#0,d0
	move.w	d4,d1
	lsl.w	#3,d1	| times 8 (y)
	lsl.w	#3,d3	| times 8 (height)
	move.w	d1,d4
	lsl.w	#5,d4
	add.w	d4,a0	| offset for source
	move.w	#NB_BYTES_PER_FG_ROW,d2
	* special case for last row: blit 4 pixels higher
	* as amiga can only display 285 lines (PAL) and not 288
	* (this allows to see lives & credits fully, not affecting
	* layout too much)
	cmp.w	#NB_LINES-8,d1
	bne.b	111f
	subq.w	#4,d1
111:
	jbsr	blit_fg_layer
	* previous rows were clean: looking for a dirty row
11:
	move.b	(a6,d7.w),d0
	beq.b	20f		| clean, next tile
	* dirty row found (D7)
	* mark start
	move.w	d7,d4
	lsr.w	#1,d4	| divide as d7 is doubled	
	* flag as "looking for clean tile"
	st	d6
19:
	* tile has been accounted for, but must leave
	* dirty flag until the whole row is clear
20:
	addq.w	#2,d7
	* one more row, else it misses the last one
	cmp.w	#BLANK_FG_ROW_START*2,d7
	bne.b	21f
	move.w	#BLANK_FG_ROW_END*2,d7	| skip rows
	clr		d6
	bra.b	10b
21:
	cmp.w	#(NB_VISIBLE_ROWS+1)*2,d7
	bne.b	10b
	rts
	
clear_fg_tiles:
	* in the first pass (D0=0), clear all foreground tiles
	* where row was marked as "to clear", then reset the clear flag

	* first condense row info into a single flag
	* and clean up rows to avoid clearing / blitting again and again
	* if row is empty
	lea		fg_refresh_tile_row_table(pc),a6
	lea		fg_refresh_tile_table(pc),a5
	moveq	#0,d7	| row counter
	moveq	#0,d6	| column counter
	move.w	#32,d4	| preload 32
	move.w	#28,d5	| preload 28
0:
	move.b	(1,a6),d0
	subq.b	#1,d0
	bpl.b	1f
	* row hasn't been modified since scanned: skip it
	add.w	d4,a5	| add 32 to A5
	bra.b	31f
1:
	*move.b	d0,(1,a6)
	* row has been written to (bitmap or empty)
	* optimized scan of the table. Most of the time, cells
	* are zeroed so we use post-increment counter, and fix
	* offsets if something is non-zero. Also read longwords
	move.l	(a5)+,d0
	beq.b	3f
	* loop 3 times
	moveq	#3,d3
100:
	tst.b	d0
	beq.b	21f
	bpl.b	2f
	* negative: bitmap: mark as dirty and that's it
	bset	#1,(a6)  | note down that there's some bitmap in that line
	* advance tile table to next row
	add.w	d5,a5	| 32 minus 4 as (a5)+ added 4
	sub.w	d6,a5	| remove current column counter
	bra.b	31f
2:
	* positive: this value counts how many times we have
	* to erase that cell. After a while, if no bitmaps are on that row
	* everything is zero and there's no need to refresh
	subq.b	#1,d0
	move.b	d0,(-4,a5,d3.w)	| update
	* space: mark row as dirty : needs clearing
	bset	#0,(a6)
21:
	lsr.l	#8,d0	| data for next column (reverted)
	dbf		d3,100b
3:
	* next column
	addq	#4,d6
	cmp.w	d4,d6   | == 32 ?
	bne.b	1b
	* we reached that point without finding a bitmap:
	* row is devoid of bitmap now: convert to "clear"
	bclr	#1,(a6)
31:
	* next row
	addq.w	#1,d7
	cmp.w	#BLANK_FG_ROW_START,d7
	bne.b	32f
	* skip rows 2-10
	move.w	#BLANK_FG_ROW_END,d7
	add.w	#(BLANK_FG_ROW_END-BLANK_FG_ROW_START)*2,a6
	add.w	#(BLANK_FG_ROW_END-BLANK_FG_ROW_START-1)*32,a5
	bra.b	33f
32:
	cmp.w	#NB_VISIBLE_ROWS+1,d7
	beq.b	4f
	addq.w	#2,a6
33:
	moveq	#0,d6
	bra.b	0b
4:
	lea		fg_refresh_tile_row_table(pc),a6

	* then use the condensed info to clear rows. This info will also be
	* used afterwards to OR back non-empty fg tiles
	* make sure it finds a block end
	clr.b	((NB_VISIBLE_ROWS+1)*2,a6)
	lea		_custom,a5
	moveq	#0,d7	| row counter
	moveq	#0,d6	| "in dirty block" flag
	bra.b	11f
	* 2 passes: first compute the first dirty tile
10:
	tst		d6
	beq.b	11f
	move.b	(a6,d7.w*2),d0
	bne.b	19f		| still dirty
	* this row is clean: compute refresh height
	move.w	d7,d3
	sub.w	d4,d3	| nb dirty rows
	* D4: first dirty row
	* D3: nb of dirty rows
	clr	d6		| ack flag
	* now refresh screen
	move.l	fg_drawed_screen_ptr(pc),a1
	move.w	#16,d0
	move.w	d4,d1
	lsl.w	#3,d1	| times 8 (start y)
	lsl.w	#3,d3	| times 8 (height)
	move.w	d3,d4
	move.w	#NB_BYTES_PER_ROW-8,d2	| no need to clear hidden columns
	cmp.w	#NB_LINES-8,d1
	bne.b	100f
	* adjust last line clear (as amiga can't display up to 288)
	subq.w	#4,d1
100:
	* clear only first plane
	movem.w	d6,-(a7)
	jbsr	clear_plane_any_blitter_internal
	movem.w	(a7)+,d6
	bra.b	20f
	* previous rows were clean: looking for a dirty row
11:
	move.b	(a6,d7.w*2),d0
	beq.b	20f		| clean, next tile
	* dirty row found (D7)
	* mark start in d4
	move.w	d7,d4
	* flag as "looking for clean tile"
	st	d6
19:
	* tile has been accounted for: no more dirty for clear
	* clear bit 0 means that only changes in that row
	* is a tile clear, value is 0, 
	* so forget about redrawing something here
	bclr.b	#0,d0
	move.b	d0,(a6,d7.w*2)
20:
	addq.w	#1,d7
	cmp.w	#NB_VISIBLE_ROWS+1,d7
	bne.b	10b
	rts
	
	.macro	WAIT_BEAM_SPRITE
w\@:
	cmp.w	#0x1D00,vhposr+_custom
	bcs.b	w\@
	.endm
	
* show sprite, supports clipping (y offset)
* < A1: sprite data
* < A4: pointer on the sprite backup table
* < D0: X
* < D1: Y
* < D2: height
* < D3: y offset (clipping)
* < D6: amiga sprite number (0-7)

show_sprite:
	movem.l	d2-d6/a0/a2-a5,-(a7)
	* store it in sprite table structure
	* A4 is a pointer on the sprite display table
	* add a lifetime of 2 updates each time called, we'll
	* update with the pointer on the sprite structure later
	
	lea		active_hw_sprite_lifetime(pc),a0
	lsl.w	#3,d6
	add.w	d6,a0
	move.w	#SPRITE_LIFETIME,(a0)+
	move.l	A4,(a0)
	
	moveq	#0,d5
	move.w	(actsprite_y_clipping,a4),d5	| previous y clipping offset
	* here handle bogus Y clip = 32 out of nowhere
	bne.b	0f
	* previous y clip = 0, current clip 32: bogus first
	* andor position, skip display
	cmp.w	#32,d3
	jeq		10f
	bra.b	7f			| no clipping to restore from previous
0:
	cmp.w	D3,d5
	beq.b	7f			| no need to restore: sprite has the same pos
	* restore previous sprite bitmap line
	lea	(actsprite_saved_line.W,a4),a2	| source
	lsl.l	#4,d5
	lea		(a1,d5.l),a5	| destination
	lsr.l	#4,D5	| restore D5 value for correctness (D3 and D5 are compared again)
	* copy 16 bytes back to restore sprite line
	* but we have to make sure that the beam is not too high
	* else sprite flickers a lot. Ironically this happens
	* with fast machines, not with slow machines
	WAIT_BEAM_SPRITE
	
	move.l	(a2)+,(a5)+
	move.l	(a2)+,(a5)+
	move.l	(a2)+,(a5)+
	move.l	(a2),(a5)
7:
	* store a1 in backup BEFORE adding offset to it
	move.l	a1,(actsprite_orig_ptr,a4)

	move.w	D3,(actsprite_y_clipping,a4)  | store previous offset
	beq.b	8f
	* clipping enabled

	swap	d3
	clr		d3
	swap	d3
	* must move sprite start & put position here
	* first we back up sprite data
	lsl.l	#4,D3
	* add offset to sprite pointer to start by that line
	add.l	D3,a1
	lsr.l	#4,D3	| restore D3 value for next loop

	* don't save: sprite has the same pos as before, this
	* would clobber the backup
	
	cmp.w	D3,d5
	beq.b	8f

	lea	(actsprite_saved_line.W,a4),a5			| destination
	move.l	a1,a2	| source
	
	* copy 16 bytes to sprite line backup space
	* and zero that sprite line so 
	* it can be used as X/Y sprite first line
	WAIT_BEAM_SPRITE
	.rept	4
	move.l	(a2),(a5)+
	clr.l	(a2)+
	.endr
8:
	* same position as bobs: shift X by 8
	subq.w	#8,d0
	bsr		store_sprite_pos
	move.w	d0,(8,a1)
	swap	d0
	move.w	d0,(a1)
	* put it in the proper sprite slot (d6: sprite number)
	move.l	a1,d0
	lea		sprites,a1
	lea		(a1,d6.w),a1	| times 8, but d6 is already *8 at this point
	move.l	a1,(actsprite_copperlist_ptr,a4)
	move.w	d0,(6,a1)
	swap	d0
	move.w	d0,(2,a1)
10:
	movem.l	(a7)+,d2-d6/a0/a2-a5
	
	rts
	
* we have to restore backuped line if Y offset was != 0
* we have to reset sprite pointer to original in copperlist
* in case it's been y-clipped
* (else it's pointing on the clipped sprite in the copperlist
* and we are going to restore the sprite data at this line)
*
* < A1: sprite backup structure (if zero, skip)
* destroyed registers: none

hide_sprite:
	movem.l	d0/a2-a3,-(a7)
	move.l	(actsprite_orig_ptr,a1),a2
	move.l	a2,d0
	beq.b	11f
	move.l	(actsprite_copperlist_ptr,a1),a3
	move.w	d0,(6,a3)
	swap	d0
	move.w	d0,(2,a3)
	* nullify pointer
	clr.l	(actsprite_orig_ptr,a1)
	* now set coords to zero
	clr.w	(a2)
	clr.w	(8,a2)
	move.w	(actsprite_y_clipping,a1),d0
	beq.b	11f		| no need to restore
	* we need to restore backuped line
	lsl.w	#4,d0	| times 16
	add.w	d0,a2	| destination to be restored
	lea		(actsprite_saved_line.W,a1),a3
	* restore sprite data
	move.l	(a3)+,(a2)+
	move.l	(a3)+,(a2)+
	move.l	(a3)+,(a2)+
	move.l	(a3),(a2)
	* zero clipping to be coherent
	* (we're using it as "previous clipping offset" too)
	clr.w	(actsprite_y_clipping,a1)
11:
	movem.l	(a7)+,d0/a2-a3
	rts
	
* draw andor genesis sprite
* the interface slightly sucks, but hey this is highly specific

* < A3: sprite structure
* < D0: sprite index times 64 (for backup/clipping table)
* < D1: color code
* < D2: y offset for clipping (0 if no clipping)
* < D3: Y
* < D5: X
draw_andor_sprite:
	move.w	d4,-(a7)
	move.w	d3,d4		| Y in D4
	* before drawing sprite, adjust red color
	lea	red_color_table,a0
	* update red color MSB/LSB (third color)
	lea	(a0,d1.w*2),a0
	move.b	(a0)+,(8,a3)
	move.b	(a0)+,(16,a3)
	clr.w	d1			| fake color config 0 (we change it dynamically just above)
	move.w	d2,d3	| y-clipping in D3
	move.w	#96,d2	| same height for both parts
	addq.w	#2,d5	| make up for shift (strange!!)
	bsr	draw_hw_sprite
	move.w	(a7)+,d4
	rts

	
	
draw_32x32_hw_sprite:
	move.w	d4,-(a7)
	move.w	d3,d4		| Y in D4
	clr.w	d1			| fake color config 0 (we change it dynamically just above)
	moveq	#0,d3	| y-clipping in D3
	move.w	#32,d2
	bsr	draw_hw_sprite
	move.w	(a7)+,d4
	rts
	


	
* < D3: Y-offset (for clipping in the top area)
* < D4: Y
* < D5: X
* < A3: graphical object structure (sprites)
	
sprite_draw_jump_table:
	dc.l	draw_sprite_part
	dc.l	sprite_draw_double_width
	dc.l	sprite_draw_double_height
	dc.l	sprite_draw_double_width_and_height
	
* < D0: tile index
* < D1: color table index
* < D2: attributes
* < D3: Y
* < D5: X
* < A3: bitplane pointer list
* < A4: sprite structure (to update height & y-offset)
* trashed registers: A0
sprite_draw_double_width:
	and.w	#3,d2			| cancel attributes others than double width/height
	bsr		draw_sprite_part
	add.w	#16,d3
	addq.w	#1,d0	| neighbour tile
	bra		draw_sprite_part
	
sprite_draw_double_width_and_height:
	move.w	#3,d2			| cancel attributes others than double width/height
	and.w	#0x1FC,d0	| mask 2 lower bits
	add.w	#16,d3		| Y += 16
	addq	#3,d0
	bsr		draw_sprite_part
	subq	#2,d0
	add.w	#16,d5
	bsr		draw_sprite_part
	sub.w	#16,d3
	sub.w	#16,d5
	addq	#1,d0
	bsr		draw_sprite_part
	subq	#2,d0
	add.w	#16,d5
	bra		draw_sprite_part
	
sprite_draw_double_height:
	and.w	#3,d2			| cancel attributes others than double width/height
	add.w	#16,d5
	bsr		draw_sprite_part
	sub.w	#16,d5
	addq	#2,d0
	bra		draw_sprite_part
	
* internal routine to draw sprites
* either by blitting (BOBs) or positionning sprites (HW sprites)
*
* < D0: sprite index
* < D1: color table index
* < D2: attributes (ignored if HW sprite)
* < D3: Y
* < D5: X
* < A3: graphical object structure (bobs or sprites)
* < A4: sprite structure (to update height & y-offset)

* trashed registers: A0

draw_sprite_part:
	movem.w	d0-d4,-(a7)

	* d0 is the tile index
	* d0 times 128*2 (<<8) is the row start pointer
	lsl.l	#8,d0
	beq.b	2f			| code 0 is all transparent: nothing drawn
	* compute clut index in d1
	and.w	#0x7F,d1	| significant color bits
	beq.b	2f			| CLUT 0 is all transparent: nothing drawn
	
	* now d1 is the index, mul by 4 to get row pointer offset
	* (there are 2 versions of the sprite normal,mirror for each
	* color configuration)
	add.w	d1,d1

	lea		_sprite_tile,a0

	add.l	d0,a0		| row offset
	move.w	(a0,d1.w),d1	| col offset
	bne.b	7f
	.ifne	OPT_ENABLE_LOGGING
	* sprite is not known with that CLUT configuration: blue flash
	* can also happen with bogus sprite+clut configuration
	* (transcode bug?)
	move.w	#BASE_BPLCON3_VALUE,bplcon3+_custom
	move.w	#0xF,color+_custom
	tst.b	unknown_sprite_found
	bne.b	2f
	st.b	unknown_sprite_found
	**bsr		zzz
	nop
	.endif
	bra.b	2f
7:

	cmp.w	#1,d1		| test blankptr
	beq.b	2f			| skip

	
	move.w	(a3,d1.w),d4	| object type
	cmp.w	#BT_SPRITE,d4
	beq.b	4f

	* count a BOB sprite
	addq.w	#1,nb_active_bobs

	btst	#3,d2			| X-flip? (Y-flip in spec, but screen is rotated!!)
	beq.b	3f
	* mostly pointless as most of sprites aren't shown flipped
	* and the ones which are flipped are mostly symmetric (WTF?)
	* in the end, the explosions are reportedly flipped. Not removing that
	* feature, as it saves 130kb only, and we have a lot of memory left anyway
	addq.w	#4,d1		| pointer to mirror planes
3:
	move.l	(2,a3,d1.w),a0		| get pointer on bitplane pointer list
	move.w	d5,d0		| restore x
	subq.w	#8,d0		| sprite X offset
	* bob: get params
	move.w	d3,d1		| restore y
	move.w	(a0)+,d4	| y offset
	move.w	(a0)+,d3	| height
	* update sprite structure (to optimize single width/height
	* sprite erases)
	move.w	d4,(8,a4)
	move.w	d3,(10,a4)
	add.w	d4,d1		| apply Y offset
	* attributes remain in d2
	bsr	blit_16x_bob
2:
	movem.w	(a7)+,d0-d4
	rts	
4:
	* case of hardware sprite
	* D0 contains sprite tile code times 256
	* we could have backuped the register somewhere else
	* but anyways we need tile code times 32
	*
	* (damn it's time that this project ends, the code is trickier
	* and trickier!)
	
	lsr.l	#8-ACTIVE_SPRITE_STRUCT_BITS,d0
	move.w	#16,d2		| 16 height (standard 16x16)
	move.w	d3,d4
	moveq	#0,d3		| no clipping
	bsr		draw_hw_sprite
	bra.b	2b
	
* < D0: sprite index times 64 (for lifetime table)
* < D1: color table index
* < D2: sprite height
* < D3.L: Y-offset (for clipping in the top area)
* < D4: Y
* < D5: X
* < A3: graphical object structure (sprites)

draw_hw_sprite:
	movem.l	d6/a2/a4-a6,-(a7)
	* X in D5
	* Y in D4
	* set a lifetime in sprite table
	lea		active_hw_sprite_display_table(pc),a4
	
	add.w	d0,a4
	lea	(2,a3,d1.w),a0

	
5:
	move.w	(a0)+,d6	| sprite number
	bmi		21f			| end of sprite chain
	* load palette in the proper copperlist slots for this sprite
	move.w	d6,d1
	lsr.w	#1,d1
	bcs.b	51f

	* even: select range 48-63 (next shift makes it times 32)
	add.w	#4,d1
51:
	lsl.w	#4,d1	| times 16
	lea	sprite_cols_32_63,a1

	add.w	d1,a1
	moveq	#3,d0	| 4 colors
6:
	move.w	(a0)+,(2,a1)
	addq.w	#4,a1
	dbf		d0,6b
	* lower part of RGB palette
	lea	sprite_cols_32_63_lower,a1
	add.w	d1,a1
	moveq	#3,d0	| 4 colors
6:
	move.w	(a0)+,(2,a1)
	addq.w	#4,a1
	dbf		d0,6b

	*moveq	#0,d0		| we need to clear MSB, already done above
	* get sprite data
	move.l	(a0)+,a1

	* restore coordinates (same for all sprites in that chain)
	move.w	d5,d0
	move.w	d4,d1
	bsr		show_sprite

	* next sprite for this image
	lea		(actsprite_second_sprite.W,a4),a4
	bra	5b
21:
	movem.l	(a7)+,d6/a2/a4-a6
	rts
	

*Both are active LOW.

* bits 6:5 Lives
* Value Description
* 11 3
* 10 2
* 01 1
* 00 5
* 4:2 Bonus Life
* Value Lives=1/3/5 Lives=5
* 111 20K, 60K, every 60K 20K, 70K, every 70K
* 110 10K, 40K, every 40K 10K, 50K, every 50K
* 101 10K, 50K, every 50K 20K, 50K, every 50K
* 100 20K, 50K, every 50K 20K, 60K, every 60K
* 011 20K, 70K , every 70K 20K, 80K, every 80K
* 010 20K, 80K, every 80K 30K, 100K, every 100K
* 001 20K, 60K only 20K, 80K only
* 000 None None
* bits 7, 1, 0 are for cocktail mode/coinage: ignored

* d0=DSWA, d1=DSWB
osd_read_dipswitches:
	move.w	#0x1F,d0
	move.w	d0,d1
	* precomputed DSW bits
	or.w	start_lives_dsw(pc),d0
	or.w	difficulty_level_dsw(pc),d1
	
	move.l	misc_flags(pc),d2
	btst	#0,d2		| awards bonus life
	bne.b	0f
	bclr	#1,d1
0:
	move.l	_joypad_state(pc),d2
	btst	#JPB_BTN_BLU,d2   | 2nd button: bomb
	beq.b	1f
	bclr	#0,d1	| active low
1:
	rts

old_intena:
	.long	0
old_dmacon:
	.long	0
old_sysvectors:
	ds.l	8
old_vbr:
	.long	0
old_syscoplist:
	.long	0
old_actiview:
	.long	0
old_stack:
	.long	0
	
_tag:
		.long	WHDLTAG_CUSTOM1_GET
cheat_flags:
		.long	0
		.long	WHDLTAG_CUSTOM2_GET
difficulty_level:
	.long	0
		.long	WHDLTAG_CUSTOM3_GET
		* bit 0: DSW flag awards bonus life
		* bit 1: no looped music
misc_flags:
		.long	0
		.long	WHDLTAG_CUSTOM4_GET
start_lives:
		.long	0
		.long	WHDLTAG_CUSTOM5_GET
start_area_option:
	.long	0
	.long	0

start_lives_dsw:
	.word	0
difficulty_level_dsw:
	.word	0
	
bit_UP = 0
bit_DOWN = 1
bit_LEFT = 2
bit_RIGHT = 3
flag_UP = 1<<bit_UP
flag_DOWN = 1<<bit_DOWN
flag_LEFT = 1<<bit_LEFT
flag_RIGHT = 1<<bit_RIGHT

.macro	JOY_BIT_SET	dir
	btst	#JPB_BTN_\dir,d1
	beq.b	1f
	bset	#bit_\dir,d0
1:
	.endm
	
		
osd_read_p1_inputs:
	move.l	_joypad_state(pc),d1
	moveq.l	#0,d0
	JOY_BIT_SET	UP
	JOY_BIT_SET	DOWN
	JOY_BIT_SET	LEFT
	JOY_BIT_SET	RIGHT
	lea		direction_table(pc),a0
	move.b	(a0,d0.w),d0
	or.b	#0xF0,d0	| sets 0xF0 (bits 4 & 5 inactive high)
	
	btst	#JPB_BTN_RED,d1
	beq.b	1f
	bclr	#5,d0	| fire, active low
	move.l	_previous_joypad_state_2(pc),d2
	btst	#JPB_BTN_RED,d2
	bne.b	1f		| was already pressed
	bclr	#4,d0	| first time fire press
1:
	move.l	d1,_previous_joypad_state_2
	rts

create_direction_table:
	lea		direction_table(pc),a0
	move.b	#0,(flag_UP,a0)
	move.b	#1,(flag_UP+flag_RIGHT,a0)
	move.b	#2,(flag_RIGHT,a0)
	move.b	#3,(flag_DOWN+flag_RIGHT,a0)
	move.b	#4,(flag_DOWN,a0)
	move.b	#5,(flag_DOWN+flag_LEFT,a0)
	move.b	#6,(flag_LEFT,a0)
	move.b	#7,(flag_UP+flag_LEFT,a0)
	move.b	#8,(a0)
	rts
	
direction_table:
	ds.b	16

* < d0.w: x
* < d1.w: y
* < d2.w: sprite height: 16, 32, 96 are supported
* > d0.L: control word
store_sprite_pos:
    movem.l  d2/a0-a1,-(a7)

    lea	HW_SpriteXTable(pc),a0
    lea	sprite_y_tables(pc),a1
	lsr.w	#2,d2
	subq.w	#4,d2
	and.w	#0xFC,d2
	* pick proper table depending on height
	move.l	(a1,d2.w),a1
	
	.ifdef	NO68020
    add.w	d0,d0
    add.w	d0,d0
    move.l	(a0,d0.w),d0
	move.w	d1,-(a7)
    add.w	d1,d1
    add.w	d1,d1
    or.l	(a1,d1.w),d0
	move.w	(a7)+,d1
	.else
    move.l	(a0,d0.w*4),d0
    or.l	(a1,d1.w*4),d0	
	.endc
    movem.l  (a7)+,d2/a0-a1
    rts
	
HW_SpriteXTable:
	.set	reptn,0
	.rept 320
	.set	x,reptn+0x80
	.set reptn,reptn+1
    .byte  0,x>>1,0,x&1
  .endr

	.macro DEF_HW_SPRITE_Y_TABLE	height
HW_SpriteYTable_\height:
  .set	reptn,0
  .rept 288
	.set	ys,reptn+0x1c
	.set	ye,ys+\height
    .byte  ys&255, 0, ye&255, ((ys>>6)&4)+((ye>>7)&2)
	.set	reptn,reptn+1
  .endr
	.endm

	DEF_HW_SPRITE_Y_TABLE	16
	DEF_HW_SPRITE_Y_TABLE	32
	*DEF_HW_SPRITE_Y_TABLE	48
	*DEF_HW_SPRITE_Y_TABLE	64
	*DEF_HW_SPRITE_Y_TABLE	80
	DEF_HW_SPRITE_Y_TABLE	96

sprite_y_tables:
	.long	HW_SpriteYTable_16
	.long	HW_SpriteYTable_32
	.long	HW_SpriteYTable_16 | unused should be HW_SpriteYTable_48
	.long	HW_SpriteYTable_16 | unused should be HW_SpriteYTable_64
	.long	HW_SpriteYTable_16 | unused should be HW_SpriteYTable_80
	.long	HW_SpriteYTable_96
	
* set_bitplanes
* what: sets bitplanes in copperlist

set_bg_bitplanes:
    lea		bg_screen_data,a0
    moveq #NB_PLAYFIELD_PLANES-1,d1
	move.w	scroll_offset(pc),d2
	lea	mulNB_BYTES_PER_ROW_table(pc),a1
	.ifdef	NO68020
	add.w	d2,d2
	add.w	(a1,d2.w),a0
	.else
	add.w	(a1,d2.w*2),a0
	.endif
	move.l	a0,d0
    lea	bg_bitplanes+2,a0
1:
    swap d0
    move.w d0,(a0)
    swap d0
    move.w d0,(4,a0)    
    addq.w  #8,a0
    add.l #BG_SCREEN_PLANE_SIZE,d0
    dbf d1,1b
    rts

set_fg_bitplanes:
    move.l		fg_displayed_screen_ptr(pc),a0
    moveq #NB_PLAYFIELD_PLANES-1,d1
	move.l	a0,d0
    lea	fg_bitplanes+2,a0
1:
    swap d0
    move.w d0,(a0)
    swap d0
    move.w d0,(4,a0)    
    addq.w  #8,a0
    add.l #FG_SCREEN_PLANE_SIZE,d0
    dbf d1,1b
    rts
	
input_map_tbl:
		.byte			0xf8															|  0, none
		.byte			0xf0															|  1, up
		.byte			0xf4															|  2, down
		.byte			0xf8															|  3, down+up (invalid)
		.byte			0xf6															|  4, left
		.byte			0xf7															|  5, left+up
		.byte			0xf5															|  6, left+down
		.byte			0xf8															|  7, left+down+up (invalid)
		.byte			0xf2															|  8, right
		.byte			0xf1															|  9, right+up
		.byte			0xf3															|  A, right+down
		.byte			0xf8															|  B, right+down+up (invalid)
		.byte			0xf8															|  C, right+left (invalid)
		.byte			0xf8															|  D, right+left+up (invalid)
		.byte			0xf8															|  E, right+left+down (invalid)
		.byte			0xf8															|  F, right+left+down+up (invalid)
		
osd_read_p2_inputs:
		*move.b    BIOS_P2CURRENT,d0                 | read IN1
		bra				osd_read_p1_inputs
		rts

osd_debug_hook:
	rts
	
osd_read_coin:
	movem.l	a0/d1/d2,-(a7)
	lea keyboard_table(pc),a0
	tst.b	(5,a0)		| "5" key like in MAME
	bne.b	0f
	move.b	#0,d0
	move.l	_joypad_state(pc),d1
	move.l	_previous_joypad_state(pc),d2
	tst.b	ingame_palette_loaded
	bne.b	2f
	* we're in menu, we allow fire to insert
	* coin and start the game

	btst	#JPB_BTN_BLU,d1
	beq.b	2f
	btst	#JPB_BTN_BLU,d2	
	beq.b	0f
2:
	btst	#JPB_BTN_GRN,d1	
	beq.b	1f
	btst	#JPB_BTN_GRN,d2	
	bne.b	1f
0:
	clr.b	(5,a0)		| ack key

	bset	#0,d0
1:
	move.l	d1,_previous_joypad_state
	movem.l	(a7)+,a0/d1/d2
	tst.b		d0	| required as API needs CCR!
	rts
		
		

	bne.b	1f		| was already pressed
	bclr	#4,d0	| first time fire press
1:
	*
		* D0 bit0=P1, bit1=P2.
osd_read_start:
	move.l	d1,-(a7)
	move.b	#0,d0
	lea keyboard_table(pc),a0
	tst.b	(1,a0)		| "1" key like in MAME
	beq.b	0f
	clr.b	(1,a0)
	bra.b	2f
0:
	move.l	_joypad_state(pc),d1
	tst.b	ingame_palette_loaded
	bne.b	3f
	btst	#JPB_BTN_RED,d1
	bne.b	2f
3:
	btst	#JPB_BTN_YEL,d1
	beq.b	1f
2:
	bset	#0,d0
1:
	move.l	(a7)+,d1
	tst.b	d0
	rts
		
osd_read_high_scores:
	movem.l	d0-d7/a0-a6,-(a7)
	move.l	_resload(pc),d0
	beq.b	0f
	move.l	d0,a2
	move.l	a0,a3
	lea		hiscorename(pc),a0
	jsr		resload_GetFileSize(a2)		
	tst.l	d0
	beq.b	1f
	lea		hiscorename(pc),a0
	move.l	a3,a1
	jsr		resload_LoadFile(a2)		
	bra.b	1f
0:
	tst.b	highscore_loaded
	beq.b	2f
	* from DOS: just copy buffer
	lea		high_score_buffer(pc),a1
	move.l	#SCORE_FILE_SIZE/4-1,d0
2:
	move.l	(a1)+,(a0)+
	dbf		D0,2b

1:
	movem.l	(a7)+,d0-d7/a0-a6
	rts
	
osd_write_high_scores:
	movem.l	d0-d7/a0-a6,-(a7)
	tst.l	cheat_flags		| don't save score if cheat on
	bne.b	1f
	tst.l	start_area_option	| don't save score if cheat on
	bne.b	1f
	move.l	_resload(pc),d0
	beq.b	0f
	move.l	d0,a2
	move.l	#SCORE_FILE_SIZE,d0
	move.l	a0,a1
	lea		hiscorename(pc),a0
	jsr		resload_SaveFile(a2)
	bra.b	1f
0:
	* from DOS: just copy buffer
	lea		high_score_buffer(pc),a1
	move.l	#SCORE_FILE_SIZE/4-1,d0
2:
	move.l	(a0)+,(a1)+
	dbf		D0,2b
	st.b	highscore_needs_saving
1:
	movem.l	(a7)+,d0-d7/a0-a6
	rts


level2_interrupt:
	movem.l	D0/A0/A5,-(a7)
	LEA	0x00BFD000,A5
	MOVEQ	#0x08,D0
	AND.B	0x1D01(A5),D0
	BEQ.b	1f
	MOVE.B	0x1C01(A5),D0
	NOT.B	D0
	ROR.B	#1,D0		| raw key code here
    
    lea keyboard_table(pc),a0
	
    bclr    #7,d0
    seq (a0,d0.w)       | updates keyboard table
    bne.b   0f     | we don't care about key release
    
    cmp.b   #0x19,d0	| "P" key
    bne.b   0f

    bsr	toggle_pause
0:
	tst.l	_resload
	bne.b	0f
	cmp.b	#0x45,d0	| "ESC" key
	bne.b	0f
	BSET	#0x06,0x1E01(A5)
	moveq	#2,d0
	bsr	beamdelay
	BCLR	#0x06,0x1E01(A5)	| acknowledge key
	bra		quit_to_os
0:
	BSET	#0x06,0x1E01(A5)
	moveq	#2,d0
	bsr	beamdelay
	BCLR	#0x06,0x1E01(A5)	| acknowledge key

1:
	movem.l	(a7)+,d0/a0/a5
	move.w	#8,_custom+intreq
	rte
	
toggle_pause:
	* pause only within game
	tst.b	ingame_palette_loaded
	beq.b	0f
	eor.b   #1,pause_flag
0:
	rts
	
high_score_buffer:
	ds.b	SCORE_FILE_SIZE

highscore_needs_saving:
	.byte	0
highscore_loaded:
	.byte	0
	.align	2
	
keyboard_table:
	ds.b	0x100

pause_flag:
	dc.w	0
    
* < D0: numbers of vertical positions to wait
beamdelay:
0:
	move.w  d0,-(a7)
    move.b	0xdff006,d0	| VPOS
1:
	cmp.b	0xdff006,d0
	beq.s	1b
	move.w	(a7)+,d0
	dbf	d0,0b
	rts
	
* < A5: custom
* < D0,D1: x,y
* < A1: plane pointer
* < D2: width in bytes (inc. 2 extra for shifting)
* < D4: blit height
* trashes D0-D6
* > A1: even address where blit was done
clear_plane_any_blitter_internal:
	moveq	#1,d3
* < A5: custom
* < D0,D1: x,y
* < A1: foreground plane pointer (often first plane!)
* < D2: width in bytes (inc. 2 extra for shifting)
* < D3: number of planes to clear
* < D4: blit height
* < D7: mask (disabled, -1 set at start)
* trashes D0-D6
clear_planes_any_blitter_internal:
    * pre-compute the maximum of shit here
	move.w	d1,d6
    beq.b   1f    | optim
	* check if y start + height > Y_MAX
	* (ignores case where y = 0, no risk)
	add.w	d4,d6
	sub.w	#Y_MAX,d6
	bmi.b	0f
	* y start + height > Y_MAX: clip height
	sub.w	d6,d4
	beq.b	10f
	bpl.b	0f
10:
	* null or negative height after clipping: out
	rts
0:
    lea mulNB_BYTES_PER_ROW_table(pc),a2
    add.w   d1,d1
    move.w  (a2,d1.w),d1
1:
    move.l  #0x01000000,d5   | minterm useD & rect clear (0xA) 
    move    d0,d6
    beq.b   2f
    MOVEQ #15,D6
    AND.W D0,D6
    and.w   #0x1F0,d0
    lsr.w   #3,d0
    add.w   d0,d1
    LSL.W #8,D6
    LSL.W #4,D6

    swap    d6
    or.l    d6,d5            | add shift
2:   
    add.w   d1,a1       | plane position (always even)

	move.w #NB_BYTES_PER_ROW,d0
    sub.w   d2,d0       | blit width

    lsl.w   #6,d4
    lsr.w   #1,d2
    add.w   d2,d4       | blit height

    * now just wait for blitter ready to write all registers
	WAIT_BLIT
    
    * blitter registers set
	.ifdef	VARIABLE_BLITTER_MASKS_AND_MODS
    move.l  d7,bltafwm(a5)
	.endif
	
	move.l d5,bltcon0(a5)	
    move.w  d0,bltdmod(a5)	|D modulo
	
	subq	#1,d3
	beq.b	4f
	subq	#1,d3
3:
	move.l a1,bltdpt(a5)	|destination top left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	lea		(FG_SCREEN_PLANE_SIZE,a1),a1
	WAIT_BLIT
	dbf		d3,3b
4:
	move.l a1,bltdpt(a5)	|destination top left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	
    rts



* what: clears a plane of any width (not using blitter, no shifting, start is multiple of 8), 16 height
* args:
* < A1: dest (must be even)
* < D0: X (multiple of 8)
* < D1: Y
* < D2: blit width in bytes (even, 2 must be added same interface as blitter)
* trashes: none

clear_plane_any_cpu_16x16:
    move.w  d3,-(a7)
    move.w  #18,d3
    bsr     clear_plane_any_cpu_any_height
    move.w  (a7)+,d3
    rts
    
clear_plane_any_cpu_any_height:
    movem.l d0-D3/a0-a2,-(a7)
    subq.w  #1,d3
    bmi.b   5f
    add.w   d1,d1
    beq.b   1f		| optim
	bmi.b	5f
    lea mulNB_BYTES_PER_ROW_table(pc),a2
    move.w  (a2,d1.w),d1
    add.w   d1,a1
1:

    lsr.w   #3,d0
    add.w   d0,a1
	move.l	a1,d1
    btst    #0,d1
    bne.b   2f
    cmp.w   #4,d2
    bcs.b   2f
	btst	#0,d2
	bne.b	2f
	btst	#1,d2
	beq.b	6f
2:  
    * odd address
    move.w  d3,d0
    subq.w  #1,d2
3:
    move.l  a1,a0
    move.w  d2,d1   | reload d1
4:
    clr.b   (a0)+
    dbf d1,4b
    * next line
    add.w   #NB_BYTES_PER_ROW,a1
    dbf d0,3b
5:
    movem.l (a7)+,d0-D3/a0-a2
    rts

6:
    * even address, big width: can use longword erase
    move.w  d3,d0
    lsr.w   #2,d2
    subq.w  #1,d2
7:
    move.l  a1,a0
    move.w  d2,d1
8:
    clr.l   (a0)+
    dbf d1,8b
    * next line
    add.w   #NB_BYTES_PER_ROW,a1
    dbf d0,7b
    bra.b   5b
	
* what: blits 16x?? data on fg planes, cookie cut
* args:
* < A0: data (16 pixels wide, 4+1 planes)
* < D0: X
* < D1: Y
* < D2: bit 2: 0: direct, 1: flip
* < D3: height
* trashes: D0-D1

blit_16x_bob:
	movem.l	d2-d6/a0-a5,-(a7)
	* first check if Y is positive
	moveq	#0,d6	| bitmap offset
	tst		d1
	bpl.b	10f
	* Y is negative, handle the Y-clipping 
	* or completely zap the blit
	add.w	d1,d3
	bmi.b	2f
	beq.b	2f		| no need to blit if height <= 0
	* compute offset to add to bitmap
	neg		d1    | make it positive
	* add a 4-byte offset per line
	move.w	d1,d6
	add.w	d6,d6
	add.w	d6,d6
	moveq	#0,d1	| draw from Y=0
10:
	move.l	fg_drawed_screen_ptr(pc),a1
	lea		blit_planes_cookie_cut_16x(pc),a5
	btst	#2,d2
	beq.b	0f
	lea		blit_planes_cookie_cut_16x_flipped(pc),a5	
0:
	moveq	#NB_PLAYFIELD_PLANES-1,d5
	moveq	#-1,d2
	move.l	a0,a4		| pointers on planes
	move.l	(NB_PLAYFIELD_PLANES*4,a4),a3		| mask is the last plane

	move.l	a4,a0     | next plane list	
	move.l	a1,a2
	move.w	d6,d2	| y offset for source planes
	jsr		(a5)

2:
	movem.l	(a7)+,d2-d6/a0-a5
	rts
	
* what: blits parts of fg layer attract mode title
* A0: data
* D0: start X
* D1: start Y
* D2: width in bytes
* D3: height

blit_fg_layer:
    movem.l d0-d7/a1-a5,-(a7)
    lea _custom,A5
	move.w	d3,d4		| height
	
	move.l	fg_drawed_screen_ptr(pc),a1
    * pre-compute the maximum of shit here

	tst	d1
    beq.b   2f    | optim
    lea		mulNB_BYTES_PER_ROW_table,a4
	.ifdef	NO68020
	add.w	d1,d1
    add.w  (a4,d1.w),d1	| y times 40
	.else
    move.w  (a4,d1.w*2),d1	| y times 40
	.endif
    add.w   d1,a1       | plane position (D1 < 0x7FFF, 288*40=0x2D00)
2:
    move.l  #0x0fca0000,d3    | B+C-A->D cookie cut   

	move.w	#NB_BYTES_PER_ROW,d0

    sub.w   d2,d0       | blit modulo
    lsl.w   #6,d4
    lsr.w   #1,d2
    add.w   d2,d4       | blit height

    * always the same settings

    * now just wait for blitter ready to write all registers
	WAIT_BLIT
    
    * blitter registers set

	move.l d3,bltcon0(a5)	| sets con0 and con1

    move.w  d0,bltcmod(a5)	|C modulo
    move.w  d0,bltdmod(a5)	|D modulo
							
	move.l a0,bltapt(a5)	|source graphic top left corner (mask)
	move.l a0,bltbpt(a5)	|source graphic top left corner
	move.l a1,bltcpt(a5)	|pristine background top (bottom) left corner
	move.l a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	
	* now cut the rest of the planes
	lea		(FG_SCREEN_PLANE_SIZE,a1),a1

    move.l  #0x0bca0000,d3    | C-A->D cookie cut   

    * now just wait for blitter ready to write all registers
	WAIT_BLIT
    
    * blitter registers set

	move.l d3,bltcon0(a5)	| sets con0 and con1

 	clr.w	bltbdat(a5)	|B word is zero
	move.w  d0,bltcmod(a5)	|C modulo
    move.w  d0,bltdmod(a5)	|D modulo

	.rept	2
	move.l a0,bltapt(a5)	|source graphic top left corner (mask)
	move.l a1,bltcpt(a5)	|pristine background top (bottom) left corner
	move.l a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit		
	lea		(FG_SCREEN_PLANE_SIZE.W,a1),a1
	WAIT_BLIT
	.endr
	
	move.l a0,bltapt(a5)	|source graphic top left corner (mask)
	move.l a1,bltcpt(a5)	|pristine background top (bottom) left corner
	move.l a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
    
    movem.l (a7)+,d0-d7/a1-a5
	rts





* what: blits 16x16 data on one plane, cookie cut, flip
* args:
* < A0: data (16x16)
* < A1: plane  (40 rows)
* < A2: background (40 rows) to mix with cookie cut
* < A3: source mask for cookie cut (16x16)
* < D0: X
* < D1: Y
* < D2: source y-offset
* < D3: height
* trashes: a lot!

blit_planes_cookie_cut_16x_flipped:
    lea _custom,A5
	move.w	d2,d5
	move.w	d3,d4
	neg.w	d4
	moveq	#4,d3		| 4 planes
    moveq  #4,d2       | 16 pixels + 2 shift bytes
    jra blit_planes_any_internal_cookie_cut

* what: blits 16x16 data on one plane, cookie cut
* args:
* < A0: data (16x16)
* < A1: plane  (40 rows)
* < A2: background (40 rows) to mix with cookie cut
* < A3: source mask for cookie cut (16x16)
* < D0: X
* < D1: Y
* < D2: source y-offset
* < D3: height
* trashes: D0-D1

blit_planes_cookie_cut_16x:
    lea _custom,A5
	move.w	d2,d5
	move.w	d3,d4
	moveq	#4,d3		| 4 planes
    moveq  #4,d2       | 16 pixels + 2 shift bytes
* < A5: custom
* < D0.W,D1.W: x,y
* < A0: source (pointer on array of planes)
* < A1: destination fg plane, also background to mix with cookie cut fg plane
* < A3: source mask for cookie cut
* < D2: width in bytes (inc. 2 extra for shifting)
* < D3: number of planes
* < D4: height. If negative, source is copied with negative modulo (flip)
* < D5: y offset for source planes
* < D7: blit mask (not considered, optim, -1 all through the game)
       
* blit mask set
* returns: start of destination in A1 (computed from old A1+X,Y)
* trashes: a1

blit_planes_any_internal_cookie_cut:
    movem.l d0-d7/a2/a4,-(a7)
    * pre-compute the maximum of shit here
	tst.w	d4
	bpl.b	1f
	sub.w	d4,d1	| pre-add height to d1
	subq.w	#1,d1	| minus one
1:	
	tst	d1
    beq.b   2f    | optim
    lea		mulNB_BYTES_PER_ROW_table,a4
	.ifdef	NO68020
	add.w	d1,d1
    add.w  (a4,d1.w),d1	| y times 40
	.else
    move.w  (a4,d1.w*2),d1	| y times 40
	.endif
2:
	move.w	d5,-(a7)
    move.l  #0x0fca0000,d5    | B+C-A->D cookie cut   

    move    d0,d6
    beq.b   4f
    asr.w   #3,d0
	bclr	#0,d0
    and.w   #0xF,d6
	beq.b	3f

    lsl.l   #8,d6
    lsl.l   #4,d6
    or.w    d6,d5            | add shift to mask (bplcon1)
    swap    d6
    clr.w   d6
    or.l    d6,d5            | add shift
3:   
    add.w   d0,d1
    
4:
    * make offset even. Blitter will ignore odd address
    * but a 68000 CPU doesn't and since we RETURN A1...
    bclr    #0,d1
    add.w   d1,a1       | plane position (D1 < 0x7FFF, 288*40=0x2D00)

	move.w	#NB_BYTES_PER_ROW,d0
	tst.w	d4
	bpl.b	5f
	neg.w	d0
	neg.w	d4    | make d4 positive again
5:
    sub.w   d2,d0       | blit width
    lsl.w   #6,d4
    lsr.w   #1,d2
    add.w   d2,d4       | blit height

    * always the same settings (ATM)

    * now just wait for blitter ready to write all registers
	WAIT_BLIT
    
    * blitter registers set

	.ifdef	VARIABLE_BLITTER_MASKS_AND_MODS
    move.l  d7,bltafwm(a5)
	clr.w bltamod(a5)		|A modulo=bytes to skip between lines
	clr.w bltbmod(a5)		|B modulo=bytes to skip between lines
	.endif
	move.l d5,bltcon0(a5)	| sets con0 and con1
	move.w	(a7)+,d5
	
    move.w  d0,bltcmod(a5)	|C modulo
    move.w  d0,bltdmod(a5)	|D modulo
					
	add.w	d5,a3			| apply to mask too
	subq	#1,d3
	beq.b	7f
	subq	#1,d3
6:
	move.l a3,bltapt(a5)	|source graphic top left corner (mask)
	move.l (a0)+,a4
	add.w	d5,a4
	move.l	a4,bltbpt(a5)	|source graphic top left corner
	move.l	a1,bltcpt(a5)	|pristine background top (bottom) left corner
	move.l	a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	lea		(FG_SCREEN_PLANE_SIZE,a1),a1
	WAIT_BLIT
	dbf		d3,6b
7:
	move.l a3,bltapt(a5)	|source graphic top left corner (mask)
	move.l (a0),a4
	add.w	d5,a4
	move.l	a4,bltbpt(a5)	|source graphic top left corner
	move.l	a1,bltcpt(a5)	|pristine background top (bottom) left corner
	move.l	a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
    
    movem.l (a7)+,d0-d7/a2/a4
    rts


	
	MUL_TABLE	NB_BYTES_PER_ROW,512
	MUL_TABLE	NB_PLAYFIELD_PLANES,512

SPRITE_MEM_SIZE = 12
current_sprite_state:
	ds.b	SPRITE_MEM_SIZE*NB_SPRITES_TOTAL
previous_sprite_state_ptr:
	dc.l	previous_sprite_state_1
previous_sprite_state_1:
	ds.b	SPRITE_MEM_SIZE*NB_SPRITES_TOTAL
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING
previous_sprite_state_2:
	ds.b	SPRITE_MEM_SIZE*NB_SPRITES_TOTAL
	.endif
	
rdargs_struct:
	dc.l	0
program_args:
	ds.l	40,0	
read_args_string:
	.ascii	"STARTLIVES/K/N,SKILL/K/N,FLAGXTRA/S,NOMUSIC/S,SUPER/S,STARTAREA/K/N,"
	.ascii	"INVINCIBLE/S,INFLIVES/S,REVSOL/S,REVBFLAG/S"
	.byte	0
	
unknown_tile_found:
	dc.b	0
unknown_sprite_found:
	dc.b	0
ingame_palette_loaded:
	dc.b	0
	.align	2
	* sound variables
sound_lock:
	.word	0
music_duration:
	.word	0
music_loops:
	.byte	0
music_volume:
	.byte	0
music_track_start_number:
	.word	0
music_playing:
	.byte	0
music_muted:
	.byte	0
music_pattern:
	.word	0
music_tick:
	.word	0
sound_muted:
	.word	0
intro_music_counter:
	.word	0
nb_active_bobs:
	.word	0
scroll_offset:
	.word	0
vbl_counter:
	.word	0
_resload:
	.long	0
_joypad_state:
	.long	0
_previous_joypad_state:
	.long	0
_previous_joypad_state_2:
	.long	0
_gfxbase:
	.long	0
_dosbase:
	.long	0
fg_drawed_screen_ptr:
	.long	fg_screen_data_1
fg_displayed_screen_ptr:
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING
	.long	fg_screen_data_2
	.else
	.long	fg_screen_data_1
	.endif

* table accounting for amiga hardware sprites that the engine
* asked to display. Holds y-offset (for andor) & line backup
* (when y-offset is non-zero). Also holds pointers on sprite start
* and also on part of the copperlist which displays the sprite
* (so it can be reset when clipped sprite disappears)
*
* 64 bytes per sprite is enough to make access simple
* by shifting by ACTIVE_SPRITE_STRUCT_BITS
* each entry can hold up to 2 sprites (6-colored sprites)
*
* a lot of entries are unused, as only a few sprites are hardware ones
* (andor, solvalo, title spark, and bragza)

active_hw_sprite_display_table:
	ds.l	320*(1<<ACTIVE_SPRITE_STRUCT_BITS)

* simple structure 1 per hw sprite
* word: life (0: not active)
* long: sprite backup structure (needed to shut down the sprite)
* word: pad

active_hw_sprite_lifetime:
	ds.l	16
	
	.include	"sound_entries.68k"
	
dosname:
	.ascii	"dos.library"
	.byte	0
graphicsname:
	.ascii	"graphics.library"
	.byte	0
hiscorename:
	.asciz	"xevious.high"
floppy_file:
	.ascii	"floppy"
	.byte	0
_end_of_ng_code:
		
		.text
	.align 2
* bg tiles (game floor) (0-15) + bobs (16-32) in AGA dual playfield
palette:
	.include "palette.68k"
* used for bg "xevious" tiles for title screen
title_palette:
	.include "title_palette.68k"
* only used for fg tile color (specially when flashing xevious title)
original_palette:
	.include "original_palette.68k"

		.bss

		.align 4
	
	.ifne	OPT_ENABLE_LOGGING
bg_tile_log:
	ds.b	0x200*64    | there are 128 CLUTs but 1 bit is decided by tile code
sprite_tile_log:
	ds.b	320*128    | there are 128 CLUTs
	.endif
* using 2 tiles/sprite only
*scb1_shadow:									ds.w 	128*4*2
scb3_shadow:									ds.w 	128*2
scb4_shadow:									ds.w 	128*2
*scb4_shadow_2:								ds.w	128*2

.align 2
irq_cnt:											ds.w		1
		.data

* 36 rows = 288 pixels
* table of the colors for fg tiles in the copperlist
_fg_color_table:
	.set	fgrow_offset,2
	.long	color_row_0+4+fgrow_offset
	.rept	28
	.long	color_row_1+4+fgrow_offset
	.set	fgrow_offset,fgrow_offset+8
	.endr
	.long	color_row_30+2
	.set	fgrow_offset,2
	.rept	6
	.long	color_row_30_plus+fgrow_offset
	.set	fgrow_offset,fgrow_offset+8
	.endr

		.bsschip
	* some space to write tiles slightly outside screen
	* (scrolling requires it so it's seamless)
	ds.b	NB_BYTES_PER_ROW*12
bg_screen_data:
	ds.b	BG_SCREEN_SIZE
	ds.b	NB_BYTES_PER_ROW*12*3
	.align 0x8		| 8 else fmode=3 makes display wrong
fg_screen_data_1:
	ds.b	FG_SCREEN_SIZE
	
	* small margin (I suspect that gas is buggy with ds directive)
	* plus fg plane shifting can write one byte too far
	ds.b	100
	.ifne  OPT_ENABLE_DOUBLE_BUFFERING

	.align 0x8		| 8 else fmode first bits set (BPAGEM&BLP32) makes display wrong
fg_screen_data_2:
	ds.b	FG_SCREEN_SIZE
	
fg_tile_layer:
	ds.b	FG_SCREEN_PLANE_SIZE
	ds.b	NB_BYTES_PER_ROW*16
	* small margin (I suspect that gas is buggy with ds directive)
	* plus fg plane shifting can write one byte too far
	ds.b	100
	.endif
	.datachip
	
.macro	DECL_4_BITPLANES	bpoff_start
	.set	bpoff,\bpoff_start
	.rept	4
	dc.w  0xe0+bpoff,0
	dc.w  0xe2+bpoff,0
	.set	bpoff,bpoff+8
	.endr
	.endm

.macro	DECL_32_COLORS
	.set	colidx,0
	.rept	32
	dc.w	color+(colidx*2),0
	.set	colidx,colidx+1
	.endr
	.endm
	
debug_copperlist:
	dc.w	color
debug_color:
	dc.w	0
	dc.l	-2
	
copperlist:
	* dynamic colors for sprites, 32-63
	.word	bplcon3,BASE_BPLCON3_VALUE+(1<<13)
sprite_cols_32_63:
	DECL_32_COLORS
	.word	bplcon3,BASE_BPLCON3_VALUE+(1<<13)+0x200
sprite_cols_32_63_lower:
	DECL_32_COLORS
    * reset color 0 & bank 0 & upper nibble
	.word	bplcon3,BASE_BPLCON3_VALUE
	.word	color,0
fg_bitplanes:
	DECL_4_BITPLANES	4
bg_bitplanes:
	DECL_4_BITPLANES	0
sprites:
    * #0
    .word    sprpt+0,0
    .word    sprpt+2,0
    * #1
    .word    sprpt+4,0
    .word    sprpt+6,0
    * #2
    .word    sprpt+8,0
    .word    sprpt+10,0
    * #3
    .word    sprpt+12,0
    .word    sprpt+14,0   
    * #4
    .word    sprpt+16,0
    .word    sprpt+18,0
    * #5
    .word    sprpt+20,0
    .word    sprpt+22,0
    * #6
    .word    sprpt+24,0
    .word    sprpt+26,0
    * #7
    .word    sprpt+28,0
    .word    sprpt+30,0
end_color_copper:
   * dynamic colors for fg tile color each 8 lines
	.set    beampos,0x1C01
	.set    fgcol,color+17*2
	.set    testcol,0x0
color_row_0:
	dc.w	beampos,0xFFFE
	dc.w	fgcol,0xfa0    | orange
	.set	beampos,beampos+0x800
	.set	testcol,testcol+0x011
color_row_1:
	.rept	28
	dc.w	beampos,0xFFFE
	dc.w	fgcol,(testcol & 0x0FFF)
	.set	beampos,beampos+0x800
	.set	testcol,testcol+0x011
	.endr
	* pal limit
    dc.w  0xFFCF,0xFFFE       | PAL wait (should be 0xFFDF but probably fmode=3 changes it)
    dc.w  0x0401,0xFFFE
	
color_row_30:
	dc.w	fgcol,0xFFF
    dc.w  0x0C01,0xFFFE           
	.set    testcol,0xF0
	.set    beampos,0x1401
	
color_row_30_plus:
	.rept	4
	dc.w	fgcol,(testcol & 0x0FFF)
	dc.w	beampos,0xFFFE
	.set	beampos,beampos+0x800
	.set	testcol,testcol+0x022
	.endr
	* last row color is changed 4 pixels earlier
	* to match the 4 pixel shift hack on the last row for foreground tiles
	* (else lives and credits don't get displayed fully)
	dc.w	fgcol,(testcol & 0x0FFF)
	dc.w	beampos-0x400,0xFFFE
	.set	testcol,testcol+0x022

	dc.w	fgcol,(testcol & 0x0FFF)
 	dc.w	beampos+0x400,0xFFFE   | wait before interrupt, avoid losing last bobs lines
    dc.w	 intreq,0x8010
	*dc.w	color,(0xF0F)
	*dc.w	fgcol,0xF00	| test
    dc.l    -2					
	

	* aligning on 8 bytes so .align will work
	* in the next datachip sections
	.align	8
	
_end_of_ng_data:
		