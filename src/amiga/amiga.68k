*
*	Amiga-specific portions of Xevious
*


.include "../src/xevious.inc"
.include "custom.i"
.include "exec_lvos.i"
.include "graphics_lvos.i"

STATE_ACTIVE = 2
STATE_DO_NOT_UPDATE_SHADOW = 1
STATE_INACTIVE = 0
	
OPT_ENABLE_LOGGING = 1


_custom = 0xDFF000

BASE_BPLCON3_VALUE = (1<<12)|(1<<10)
NB_PLAYFIELD_PLANES = 4
FG_DIRTY_TILES_SIZE = 40*32
TOTAL_NB_COLORS = 32   | 16+16
NB_BYTES_PER_ROW = 40
NB_LINES = 288
NB_PLAYFIELD_LINES = 512
* scrollable planes
BG_SCREEN_PLANE_SIZE = NB_BYTES_PER_ROW*NB_PLAYFIELD_LINES*2
BG_SCREEN_SIZE =  BG_SCREEN_PLANE_SIZE*NB_PLAYFIELD_PLANES
* non-scrollable planes
FG_SCREEN_PLANE_SIZE = NB_BYTES_PER_ROW*(NB_LINES+16)
FG_SCREEN_SIZE =  FG_SCREEN_PLANE_SIZE*NB_PLAYFIELD_PLANES

NB_SPRITES_TO_UPDATE = 64
NB_SPRITES_TOTAL = 64

BLANK_FG_TILE_ID = 0x24

	bra	_user

| write current PC value to some address
.macro LOGPC	address
     bsr    .next_\@
.next_\@:
      addq.l    #6,(a7) | skip this & next instruction
      move.l    (a7)+,0x\address
.endm

	
.macro MUL_TABLE value,len
mul\value\()_table:
	.set    mulv,0
	.rept	\len
	dc.w	mulv
	.set	mulv,mulv+\value
	.endr
.endm

* internal macro
.macro GXY_PREP

	
	.endm
	
.macro GET_XY_ADDRESS  base_address
	* multiply D1 by 240
	lea		mulNB_BYTES_PER_ROW_table(pc),a1
	.ifdef	NO68020
	add.w	d1,d1
	move.w	(a1,d1.w),d1
	.else
	move.w	(a1,d1.w*2),d1
	.endif
	and.l	#0xFFFF,d1
	and.l	#0xFFFF,d0
	
	lsl.w	#3,d1
	lsr.w	#6,d0
	neg.w	d0
	add.w	#32,d0	| mirror
	* add y offset to screen data	
	add.w	d1,d0	
	* add x offset to screen data
	lea		(\base_address,d0.w),a1
.endm

	
* the non shifted version is just so simple...
* huge thanks to dual playfield and bplcon1 x-shift!
.macro	SET_FG_BYTE
	move.b	(a0)+,(offset,a1)
	.endm
.macro	CLR_FG_BYTE
	clr.b	(offset,a1)
	.endm
.macro	OR_FG_BYTE
	move.b	(offset,a1),d0
	or.b	(a0)+,d0
	move.b	d0,(offset,a1)
	.endm
	

.macro blitz
	move.w	d0,-(a7)
	clr.w	d0
loop\@:
	move.w	#BASE_BPLCON3_VALUE,_custom+bplcon3	| really color 0
	move.w	d0,_custom+color
	btst	#6,0xbfe001
	beq.b	out\@
	addq.w	#1,d0
	bra.b	loop\@
out\@:
	move.w	(a7)+,d0
	nop
.endm

* exports

    .global _jp_config
    .global _us_config
    .global _sp_config
   	.global DUMMY
	  .global _user
		.global _player_start
		.global _demo_end
		.global _coin_sound

* osd layer		
		.global osd_enable_vblank_interrupt
		.global osd_ack_vblank_interrupt
		.global osd_disable_vblank_interrupt
		.global osd_kick_wdog
		.global osd_w_fg_colorram
		.global osd_w_bg_colorram
		.global osd_w_fg_videoram
		.global osd_w_bg_videoram
		.global osd_update_scroll_hw
		.global osd_update_sprite_shadow
		.global osd_update_32_sprite_hw
		.global osd_read_dipswitches
		.global osd_read_p1_inputs
		.global osd_read_p2_inputs
		.global osd_read_high_scores
		.global osd_write_high_scores
		.global osd_read_coin
		.global osd_read_start

* debugging only
    .global osd_debug1
    .global osd_debug2
    .global osd_debug_hook
    .global	scb1_shadow
    .global scb3_shadow
    .global scb4_shadow
    .global _end_of_ng_code
    .global _end_of_ng_data
    
	.include	"ReadJoypad.inc"
		.text


.list

    .align 4
_jp_config:
_us_config:
_sp_config:
    .ascii    "XEVIOUS         "
    .word     0xffff
    .word     0xffff
    .byte     0xff
    .byte     0xff
    .byte     0x38                | bonus life (20,60,*60)
    .byte     0x24                | lives (3)
    .byte     0x02                | flags award bonus life (yes)
    .byte     0x14								| difficulty (normal)
    .byte     0x02                | cabinet
    .byte     0x00
    .byte     0x00
    .byte     0x00
    .byte     0x00
    .byte     0x00
* item names are 12 characters    
    .ascii    "BONUS LIFE  "      | item 5
    .ascii    "10K 40K *40K"
    .ascii    "10K 50K *50K"
    .ascii    "20K 50K *50K"
    .ascii    "20K 60K *60K"
    .ascii    "20K 70K *70K"
    .ascii    "20K 80K *80K"
    .ascii    "20K 60K only"
    .ascii    "NONE        "
    .ascii    "LIVES       "      | item 6
    .ascii    "3           "
    .ascii    "1           "
    .ascii    "2           "
    .ascii    "5           "
    .ascii    "FLAGS LIFE  "      | item 7
    .ascii    "YES         "
    .ascii    "NO          "
    .ascii		"DIFFICULTY  "			| item 8
    .ascii    "NORMAL      "
    .ascii    "EASY        "
    .ascii    "HARD        "
    .ascii    "HARDEST     "
    .ascii    "CABINET     "      | item 9
    .ascii    "VERTICAL    "
    .ascii    "HORIZONTAL  "

	.align 4
IRQ1:
	
	rte
    
	.align 4
IRQ3:
	
	rte

DUMMY:
	rte
	    
TRAP:
	rte
	    
_user:
    * if D0 contains "WHDL"
    * A0 contains resload
        
    cmp.l   #0x05748444c,D0	| WHDL
    bne.b   .standard
    move.l a0,_resload
    *move.b  d1,_keyexit
    *move.l  a0,a2
    *lea	_tags(pc),a0
    *jsr	resload_Control(a2)
    *bsr load_highscores
    bra.b   .startup
	nop
.standard:
    * open dos library, graphics library
    move.l  0x4.W,a6
    *lea dosname(pc),a1
    *moveq.l #0,d0
    *jsr _LVOOpenLibrary(a6)
    *move.l  d0,_dosbase
    *lea graphicsname(pc),a1
    *moveq.l #0,d0
    *jsr _LVOOpenLibrary(a6)
    *move.l  d0,_gfxbase
    *move.l	d0,a6
	*sub.l	a1,a1
	*jsr	_LVOLoadView(a6)
	*jsr	_LVOWaitTOF(a6)
	*jsr	_LVOWaitTOF(a6)
	*move.l  0x4.W,a6
    *bsr load_highscores

    * check if "floppy" file is here
    
    *move.l  _dosbase(pc),a6
    *move.l   #floppy_file,d1
    *move.l  #MODE_OLDFILE,d2
    *jsr     _LVOOpen(a6)
    *move.l  d0,d1
    *beq.b   .no_floppy
    
    * "floppy" file found
    *jsr     _LVOClose(a6)
    * wait 2 seconds for floppy drive to switch off
    *move.l  #100,d1
    *jsr     _LVODelay(a6)
.no_floppy:
	* stop cdtv device if found, avoids that cd device
	* sends spurious interrupts
    *move.l  #CMD_STOP,d0
    *bsr send_cdtv_command
.startup:
    lea  _custom,a5
    *move.b  #0,controller_joypad_1
    

* no multitask
    tst.l   _resload
    bne.b   .no_forbid
    *move.l  _gfxbase(pc),a4
    *move.l StartList(a4),gfxbase_copperlist

    move.l  4,a6
    jsr _LVOForbid(a6)
    
	sub.l	A1,A1
	jsr	_LVOFindTask(a6)		| find ourselves
	move.l	D0,A0
	*move.l	#-1,pr_WindowPtr(A0)	|Â no more system requesters (insert volume, write protected...)

.no_forbid:
	* soundfx lib
	lea		_custom,a6
	sub.l	a0,a0	| assuming vbr=0
	moveq	#1,d0	| PAL
	jsr		_mt_install_cia
	
	jsr	 _detect_controller_types 


		moveq			#2,d0
		*move.b		(BIOS_USER_REQUEST),d0
		lsl.w			#2,d0
    movea.l   1f(pc,d0.w),a0
    jmp       (a0)
    .align 4
1:	.long			startup_init
		.long			eye_catcher
		.long			demo_game
		.long			title_display

startup_init:
		rts

eye_catcher:
* we're not doing things the NeoGeo way
		rts


* To get the core to run, you just need to jump to xevious_reset after
* you've initialised the platform (Amiga) stuff. That essentially does a
* Z80 reset. You also need to call xevious_im1_irq from the Amiga vblank
* routine. They are the only 2 entry points required for the core to run,
* even if there's no other I/O.


demo_game:
		tst.l   _resload
		bne.b   .no_super
		move.l	4,A6
		jsr		_LVOSuperState(a6)
.no_super:	
		move		#0x4000,_custom+intena						| disable interrupts
		bsr			platform_init					| amiga-specific init
		jmp			xevious_reset					| pass control to the xevious core

title_display:
* we're not doing things the NeoGeo way
    rts

_player_start:
* we're not doing things the NeoGeo way
		rts
				
_demo_end:
* we're not doing things the NeoGeo way
		rts
				
_coin_sound:
* we're not doing things the NeoGeo way
		rts
				
_vblank:
    movem.l d0-d7/a0-a6,-(a7)
	move.w	_custom+intreqr,d0
	btst	#5,d0
	beq.b	.no_vblank
	moveq	#1,d0
	jsr	_read_joystick
	move.l	d0,_joypad_state
	
	jsr		xevious_im1_irq
	
    move.w  vbl_counter(pc),d0
    addq.w  #1,d0
    cmp.w   #5,d0
    bne.b   .normal
    * update a second time, simulate 60Hz
    jsr	xevious_im1_irq
    clr.w d0    
.normal:
    move.w  d0,vbl_counter
			
.no_vblank:
    movem.l (a7)+,d0-d7/a0-a6
	move.w	#0x70,_custom+intreq
    rte

osd_kick_wdog:
    rts

platform_init:
	
	lea		_custom,a5
	move.w	#0x7FFF,dmacon(a5)
	* restrict borders: we don't see bobs on the borders!
    move.w #0x1C99,diwstrt(a5)
    move.w #0x3881,diwstop(a5)
    move.w #0x0038,ddfstrt(a5)
    move.w #0x00D0,ddfstop(a5)
    #move.w #0x0210,bplcon0(a5)  
    move.w #0x0610,bplcon0(a5) | 8 bitplanes, dual playfield
	
    move.w #3,fmode(a5)  		| AGA fastest fetch mode
	
	* there's a 2-pixel shift between foreground layer
    * and background layer, can be seen in the title
	* screen with XEVIOUS bg/fg tiles
    move.w #2<<4,bplcon1(a5)    | foreground tiles shifted by 2 pixels
    move.w #0x0044,bplcon2(a5)	| 2nd playfield has priority, sprites have priority
    move.w #BASE_BPLCON3_VALUE,bplcon3(a5)	| color bank offset for playfield 2
	move.w	#-8,d0
    move.w d0,bpl1mod(a5)
    move.w d0,bpl2mod(a5)

	bsr		create_direction_table
	bsr		set_fg_bitplanes
	bsr		set_bg_bitplanes

	* load copperlist
	
	* set copperlist
	move.l	#copperlist,cop1lc(a5)
	* load palette
	lea		palette(pc),a0
	clr.w	d0
	bsr		set_aga_color_registers	
	move.w	#0x200,d0	| LOCT: 1
	bsr		set_aga_color_registers	
	
    * init sprite, bitplane, whatever dma
    move.w #0x83E0,dmacon(a5)

	* install vblank handler
	pea		_vblank(pc)
	move.l	(a7)+,0x6C.W
	
    rts

load_ingame_tile_palette:
	lea		palette,a0
	clr.w	d0
	bsr		load_first_16_colors
	add.w	#32,a0	| skip 16 colors
	move.w	#0x200,d0
	bsr		load_first_16_colors
	rts
	
load_title_tile_palette:
	lea		title_palette,a0
	clr.w	d0
	bsr		load_first_16_colors
	move.w	#0x200,d0
	bsr		load_first_16_colors
	rts
	
* D0: LOCT 0/0x200
* A0: out updated by 32
load_first_16_colors:
	movem.l	d0-d1/a1,-(a7)
	lea		_custom,a5
    or.w  #BASE_BPLCON3_VALUE,d0
	move.w	d0,bplcon3(a5)
	move.w	#15,d0
	lea		color(a5),a1
1:
	move.w	(a0)+,(a1)+
	dbf		d0,1b
	move.w	#BASE_BPLCON3_VALUE,bplcon3(a5)
	movem.l	(a7)+,d0-d1/a1
	rts
	
* < a0: source palette
* < d0: LOCT mask 0 or 0x200
set_aga_color_registers:
	lea		_custom,a5
	move.w	d0,d2
    moveq	#0,d7
    move.w  #TOTAL_NB_COLORS,d1    | number of colors: here only 32, bank system is not used
    lsr.w   #5,d1   | divide by 32
    and.w   #0x1F,d0
    beq.b   1f
    add.w   #1,d1
1:
    * set AGA color bank
    move.w  d7,d0
    lsl.w   #8,d0
    lsl.w   #5,d0
	or.w	d2,d0
	or.w	#BASE_BPLCON3_VALUE,d0
    move.w  d0,bplcon3(a5)
    lea color(a5),a1
    * now set the colors for that bank
    move.w  #31,d0 
2:
    move.w  (a0)+,(a1)+
    dbf d0,2b
    addq.w  #1,d7
    cmp.w   d1,d7
    bne.b   1b
    
    * reset bank so copperlist can work on base ECS bank
    move.w  #BASE_BPLCON3_VALUE,bplcon3(a5)
    rts

* 60Hz VBLANK interrupt
osd_enable_vblank_interrupt:
	move.w	#0xC020,_custom+intena
	rts

osd_ack_vblank_interrupt:
	move.w	#0x20,_custom+intreq
 	rts
		
osd_disable_vblank_interrupt:
	move.w	#0x0020,_custom+intena
	rts
		
* d0=offset (preserved), d1=attribute (preserved)
osd_w_fg_colorram:
    .ifeq OPT_DISABLE_FG_LAYER
	movem.l	d0-d5/a0-a1,-(a7)
	lea		fg_colorram,a1
	move.b	d1,(a1,d0.w)	| store color X/Y flip attribute in fg table
	lea		fg_videoram,a1
	move.b	d1,d2
	move.b	(a1,d0.w),d1	| fetch tile from character grid
	* now update tile to reflect the color change
	moveq	#FG_TILE_DRAW_COLOR,d3
	bsr	update_fg_tile
	movem.l	(a7)+,d0-d5/a0-a1
   .endif | OPT_DISABLE_FG_LAYER
	rts

* d0=offset (preserved), d1=attribute (preserved)
osd_w_bg_colorram:
    .ifeq OPT_DISABLE_BG_LAYER
	movem.l	d0-d5/a0-a1,-(a7)
	lea		bg_colorram,a1
	move.b	d1,(a1,d0.w)	| store attribute in bg table
	lea		bg_videoram,a1
	move.b	d1,d2
	move.b	(a1,d0.w),d1	| fetch tile from character grid
	bsr	update_bg_tile
	movem.l	(a7)+,d0-d5/a0-a1
   .endif | OPT_DISABLE_BG_LAYER
	rts
		
* the first 4 rows are not visible, then the next 36 rows
* are visible. Screen is 32 tiles wide but only 28 visible.
*  Bottom 6 bits of D0 is the row, upper 5 bits are the column.
* d0=offset (preserved), d1=tile (preserved)
osd_w_fg_videoram:
    .ifeq OPT_DISABLE_FG_LAYER
	movem.l	d0-d5/a0-a2,-(a7)
	lea		fg_colorram,a1
	lea		fg_videoram,a2
	move.b	d1,(a2,d0.w)	| update logical grid
	move.b	(a1,d0.w),d2	| color & X/Y flip data
	moveq	#FG_TILE_DRAW_FULL,d3
	bsr		update_fg_tile
	movem.l	(a7)+,d0-d5/a0-a2
    .endif | OPT_DISABLE_FG_LAYER
	rts

* d0=offset (preserved), d1=tile (preserved)
osd_w_bg_videoram:
    .ifeq OPT_DISABLE_BG_LAYER
	movem.l	d0-d5/a0-a2,-(a7)
	lea		bg_colorram,a1
	lea		bg_videoram,a2
	* dump both tables (color+char): S bg_data <address@0x110> $1000
	move.l	a1,0x110		| temp
	
	move.b	d1,(a2,d0.w)	| update logical grid
	move.b	(a1,d0.w),d2	| color & X/Y flip data
	bsr		update_bg_tile
	movem.l	(a7)+,d0-d5/a0-a2
    .endif | OPT_DISABLE_BG_LAYER
	rts
	
.macro	CLEAR_TILE
	.set	offset,0
	.rept	8
	clr.b	(offset,a1)
	clr.b	(offset,a2)
 	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	.endm
.macro	CLEAR_TILE_NO_MIRROR
	.set	offset,0
	.rept	8
	clr.b	(offset,a1)
 	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	.endm
	
* d0: offset
* d1: tile code (0-256 but extends to 512 with bit 0 of attribute)
* d2: attribute (0-255, color is in bits 0-5, X/Y flip in 6:7)
update_bg_tile:
	* first check if we must toggle lower 16 palette between title
	* and in-game
	lea		bg_videoram,a0
	cmp.b	#0xCD,(0x60E,a0)
	beq.b	2f
	* in-game
	tst.b	ingame_palette_loaded
	bne.b	3f
	bsr		load_ingame_tile_palette
	st.b	ingame_palette_loaded
	bra.b	3f
2:
	* title
	tst.b	ingame_palette_loaded
	beq.b	3f
	bsr		load_title_tile_palette
	clr.b	ingame_palette_loaded	
3:	
	* discard everything not in column range
	move.w	d0,d3
	lsr.w	#6,d3
	neg.w	d3
	add.w	#32-3,d3	| mirror
	bmi.b		0f
	cmp.w	#29,d3
	bcs.b	1f
0:
	rts
1:
	lea		_bg_tile,a0
	and.l	#0xFF,d1
	btst	#0,d2
	beq.b	2f
	bset	#8,d1	| upper part of background tile code
2:
	.ifne  OPT_ENABLE_LOGGING
	move.l	a0,0x120
	* log the tile, use start address in 0x100 then
	* S bg_tile_log <address> !64*!512
	lea		bg_tile_log,a1
	move.l	a1,0x100
	movem.l	d1/d2,-(a7)
	lsl.w	#6,d1		| times 64, 128 cluts but depend on bit 4
	add.w	d1,a1
	and.w	#0x3F,d2	| significant color bits
	move.b	#0xDD,(a1,d2.w)
	movem.l	(a7)+,d1/d2
	.endif

	* compute clut index in d3
	* by descrambling the bizarre encoding
	move.b	d2,d3
	and.w	#0x3F,d3	| keep only 5:0 bits
	lsr.b	#2,d3
	move.b	d2,d4
	and.b	#3,d4
	lsl.b	#5,d4	| high color bits
	or.b	d4,d3	| add them back
	btst	#7,d1
	beq.b	2f
	* bit 4 of the colour is derived from bit 7 of the videoram byte
	bset	#4,d3	| add bit 4 if tile id > 0x80
2:
	* now d3 is the index, mul by 2 to get row pointer offset
	add.w	d3,d3
	* d1 times 256 (<<8) is the row start pointer
	lsl.l	#8,d1
	
	add.l	d1,a0		| row offset
	add.w	d3,a0		| col offset
	tst.w	(a0)
	bne.b	7f
	* tile is not known with that CLUT configuration: flash
	**move.w	#0,bplcon3+_custom
	**move.w	#0xF00,color+_custom
	**tst.b	unknown_tile_found
	**bne.w	9f
	**st.b	unknown_tile_found
	**lsr.l	#8,d1
	**lsr.l	#1,d1		| row
	**lsr.l	#1,d3		| column
	**lea		_bg_tile,a1
	**
	**blitz
	bra.w	9f
7:
	move.w	(a0),a0
	move.w	d0,d1
	subq.w	#2,d1
	bmi		update_bg_tile_out

	moveq	#NB_PLAYFIELD_PLANES-1,d3

	;;and.w	#0x3F,d1		| row
	cmp.w	#36,d1
	bcc.w	bg_no_mirror
	* convert coords to address with proper shift vs foreground
	GET_XY_ADDRESS		bg_screen_data-NB_BYTES_PER_ROW*4
	* duplicate display (scrolling)
	lea		(BG_SCREEN_PLANE_SIZE/2,a1),a2

	cmp.w	#1,a0
	beq		8f		| blank (optim)

	add.l	#bg_picbase,a0   | pointer on tile data
	btst	#7,d2			 | X-flip?
	beq.b	3f
	addq.w	#4,a0			 | mirror version
3:	
	move.l	(a0),a0			 | tile data
	* draw
	btst	#6,d2    | Y-flip
	bne	5f
4:
	tst.b	(a0)+
	beq	6f
	.set	offset,0
	.rept	8
	move.b	(a0)+,d0
	move.b	d0,(offset,a1)
	move.b	d0,(offset,a2)
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
1:
    lea   (BG_SCREEN_PLANE_SIZE,a1),a1
    lea   (BG_SCREEN_PLANE_SIZE,a2),a2
    dbf d3,4b
	rts
6:
	CLEAR_TILE
	bra.b	1b
	
5:   | y-flip
	tst.b	(a0)+
	beq.b	6f

	.set	offset,NB_BYTES_PER_ROW*7
	.rept	8
	move.b	(a0)+,d0
	move.b	d0,(offset,a1)
	move.b	d0,(offset,a2)
	.set	offset,offset-NB_BYTES_PER_ROW
	.endr
1:
	lea		(BG_SCREEN_PLANE_SIZE,a1),a1
	lea		(BG_SCREEN_PLANE_SIZE,a2),a2
    dbf		d3,5b
update_bg_tile_out:
	rts

6:
	CLEAR_TILE
	bra.b	1b

8:	
	CLEAR_TILE
   lea   (BG_SCREEN_PLANE_SIZE,a1),a1
   lea   (BG_SCREEN_PLANE_SIZE,a2),a2
    dbf d3,8b
9:
	rts
	
	* same thing but without updating the mirror plane
	* as it will never be displayed (used only to simulate
	* the tile display hardware wrap so no need to go until
	* 64 rows for the mirror, only 36 are enough
bg_no_mirror:
	* convert coords to address with proper shift vs foreground
	GET_XY_ADDRESS		bg_screen_data-NB_BYTES_PER_ROW*4

	cmp.w	#1,a0
	beq		8f		| blank (optim)

	add.l	#bg_picbase,a0   | pointer on tile data
	btst	#7,d2			 | X-flip?
	beq.b	3f
	addq.w	#4,a0			 | mirror version
3:	
	move.l	(a0),a0			 | tile data
	* draw
	btst	#6,d2    | Y-flip
	bne	5f
4:
	tst.b	(a0)+
	beq	6f
	.set	offset,0
	.rept	8
	move.b	(a0)+,(offset,a1)
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
1:
    lea   (BG_SCREEN_PLANE_SIZE,a1),a1
    dbf d3,4b
	rts
6:
	CLEAR_TILE_NO_MIRROR
	bra.b	1b
	
5:   | y-flip
	tst.b	(a0)+
	beq.b	6f

	.set	offset,NB_BYTES_PER_ROW*7
	.rept	8
	move.b	(a0)+,(offset,a1)
	.set	offset,offset-NB_BYTES_PER_ROW
	.endr
1:
	lea		(BG_SCREEN_PLANE_SIZE,a1),a1
    dbf		d3,5b
	rts

6:
	CLEAR_TILE_NO_MIRROR
	bra.b	1b

8:	
	CLEAR_TILE_NO_MIRROR
   lea   (BG_SCREEN_PLANE_SIZE,a1),a1
    dbf d3,8b
9:
	rts
		
FG_TILE_DRAW_COLOR = 0
FG_TILE_DRAW_FULL = 1
FG_TILE_DRAW_OR = 2
FG_TILE_CLEAR = 3

* d0: offset
* d1: tile code
* d2: attribute
* d3: draw mode (see FG_TILE_DRAW... above)
* most other registers are killed

update_fg_tile:
	moveq	#0,d4
	lea		_fg_tile,a0
	and.w	#0xFF,d1
	* handle special case of orange color hiscore
	* (probably not going to handle that after all...)
	cmp.w	#17,d1		| "H" tile
	bne.b	0f
	cmp.w	#0x504,d0	| HISCORE pos
	bne.b	0f
	moveq	#1,d4
0:
	cmp.w	#BLANK_FG_TILE_ID,d1
	bne		0f
	move.w	#FG_TILE_CLEAR,d3
0:
	lsl.w	#4,d1			| *16 (each tile+mirror tile has 8+8 bytes)
	btst	#6,d2			| X-flip?
	beq.b	1f
	add.w	#8,d1			| mirror version
1:
	add.w	d1,a0
	move.w	d0,d1
	and.w	#0x3F,d1		| row
	subq.w	#4,d1
	bmi.w	3f

	cmp.w	#36,d1		| limit to 36th row, rest is not displayed
	bcc.w	3f
	
	move.w	d2,d4
	* decode color
	and.w	#0x3F,d2	| drop flip x/y bits
	move.w	d2,d5
	lsr.w	#2,d2		| 5:2 => 3:0
	and.w	#0x3,d5		| keep 5:4
	lsl.w	#4,d5		| at proper position
	or.w	d5,d2		| combine
	lea		original_palette(pc),a1	| original palette (upper nibble)
	.ifdef	NO68020
	add.w	d2,d2
	move.w	(a1,d2.w),d2
	.else
	move.w	(a1,d2.w*2),d2
	.endif
	* update color for that row
	lea	_fg_color_table,a1
	.ifdef	NO68020
	move.w	d1,d5
	add.w	d5,d5
	add.w	d5,d5
	move.l	(a1,d5.w),a1
	.else
	move.l	(a1,d1.w*4),a1	
	.endif
	move.w	d2,(a1)			| color palette index

	tst	d3
	bne.b	4f
	* no need to draw tile, called from color change
	* (saves cycles)
	rts
4:
	move.l		fg_screen_pointer,a2
	GET_XY_ADDRESS	a2
	cmp.w	#FG_TILE_DRAW_FULL,d3
	bne.w	5f
	
	* draw
	btst	#7,d4
	bne	2f
	.set	offset,0
	.rept		8
	SET_FG_BYTE
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	rts
2:
	.set	offset,NB_BYTES_PER_ROW*7
	.rept		8
	SET_FG_BYTE
	.set	offset,offset-NB_BYTES_PER_ROW
	.endr
3:
	rts
5:
	cmp.w	#FG_TILE_CLEAR,d3
	beq	6f
	* draw
	btst	#7,d4
	bne	2f
	.set	offset,0
	.rept		8
	OR_FG_BYTE
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	rts
2:
	.set	offset,NB_BYTES_PER_ROW*7
	.rept		8
	OR_FG_BYTE
	.set	offset,offset-NB_BYTES_PER_ROW
	.endr
3:
	rts
6:
	* clear

	.set	offset,0
	.rept		8
	CLR_FG_BYTE
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	rts

	
* d6 = bg_scroll_x_shadow
osd_update_scroll_hw:
	move.w	d6,scroll_offset
	* add to planes offset & change copperlist
	bra		set_bg_bitplanes


* a5=obj_tbl
osd_update_sprite_shadow:
	lea       sprite_shadow_msb,a2
	lea		current_sprite_state(pc),a4
	moveq			#NB_SPRITES_TOTAL-1,d7
1:
	move.b	(_STATE,a5),d0
	cmp.b	#STATE_INACTIVE,d0
	bne.b	11f
	* deactivate
	move.b	#STATE_DO_NOT_UPDATE_SHADOW,(_STATE,a5)
	clr.w	(_X,a5)
	clr.w	(_Y,a5)
	move.b	d0,(a4)	| inactive
	bra.b	3f
11:
	cmp.b	#STATE_DO_NOT_UPDATE_SHADOW,d0
	beq.b	3f
	move.b	d0,(a4)+
	move.b	(_ATTR,a5),(a4)+
	move.b	(_CODE,a5),(a4)+
	move.b	(_COLOUR,a5),(a4)+
	move.w	(_X,a5),d1
	lsr.w	#6,d1
	move.b	d1,(a2)+	| d1: X[8:1]
	add.w	d1,d1		| shift back
	move.w	d1,(a4)+
	move.w	(_Y,a5),d2
	lsr.w	#5,d2		| d2: Y[7:0]
	move.b	d2,(a2)+
	* mirror
	neg.w	d2
	add.w	#32*8,d2
	move.w	d2,(a4)+
2:
	lea		(_OBJSIZE,a5),a5
	dbf				d7,1b
	rts
3:
	addq.w	#8,a4
	addq.w	#2,a2
	bra.b	2b
	


* d0 = base sprite number (0/32)
osd_update_32_sprite_hw:	
	move.w	d0,d7
	* toggle fg planes (double buffering)
	lea		fg_screen_pointer(pc),a0
	lea		fg_screen_data_1,a1
	cmp.l	(a0),a1
	bne.b	1f
	lea		fg_screen_data_1,a1
1:
	move.l	a1,(a0)
	bsr		set_fg_bitplanes
	
	move.w	#0,min_sprite_y
	move.w	#NB_LINES/2+16,max_sprite_y
	tst.w	d7
	beq.b	0f
	move.w	#NB_LINES/2-16,min_sprite_y
	move.w	#NB_LINES,max_sprite_y
0:
	.ifeq		OPT_DISABLE_SPRITES
	lea		current_sprite_state(pc),a4
	lea		previous_sprite_state(pc),a5

	* first restore all background tiles behind the previous
	* positions of the previously active objects
	movem.l	d2-d5/a0-a2/a5,-(a7)
	move.w	#NB_SPRITES_TO_UPDATE-1,d4			| 32 sprites
2:
	cmp.b	#STATE_INACTIVE,(a5)
	beq	3f
	* erase previous sprite position
	move.w	(4,a5),d1   | Y
	sub.w	#4*8,d1
	bmi.b		11f		| not visible
	cmp.w	min_sprite_y(pc),d1
	bcs.b	11f
	cmp.w	max_sprite_y(pc),d1
	bcc.b	11f
	move.w	(6,a5),d0
	subq.w	#8,d0		| sprite X offset
	
	moveq	#NB_PLAYFIELD_PLANES-1,d3
	move.l		fg_screen_pointer(pc),a1
10:
	bsr		clear_plane_any_blitter_16x16
	lea		(FG_SCREEN_PLANE_SIZE,a1),a1
	dbf		d3,10b
11:
	* convert sprite coords to foreground tile coords, then mark
	* the dirty tiles
	move.w	(6,a5),d0
	sub.w	#4,d0		| sprite Y offset (32-X on amiga screen)
	move.w	(4,a5),d1
	
	subq.w	#2,d1
	
	* divide by 8 to get to tile resolution
	lsr.w	#3,d1
	lsr.w	#3,d0
	neg.w	d0
	add.w	#33,d0	| mirror plus one
	subq.w	#2,d1
	* mark tile below sprite for redraw
	* translate sprite x,y in tile offset
	* offset = (32-x)<<6 + y
	lsl.w	#6,d0
	add.w	d1,d0	| should do it
	bclr	#0,d0	| even
	addq	#2,d0
	
	* mark a 4x4 square as dirty
	lea	fg_dirty_tiles,a0
	move.l	#-1,d1
	move.l	#1<<6,d2
	move.l	d1,(a0,d0.w)	| 4 in a column (Y)
	sub.l	d2,d0		| increase X
	move.l	d1,(a0,d0.w)
	sub.l	d2,d0		| increase X
	move.l	d1,(a0,d0.w)
	sub.l	d2,d0		| increase X
	move.l	d1,(a0,d0.w)


3:
	lea		(8,a5),a5
	dbf		d4,2b
	movem.l	(a7)+,d2-d5/a0-a2/a5


	* then update the active sprites
	lea		sprite_picbase,a3
	move.l	a4,-(a7)
	move.w	#NB_SPRITES_TO_UPDATE-1,d4			| 32 sprites
	| sprite loop
4:
	cmp.b	#STATE_INACTIVE,(a4)
	beq.w	2f
	move.w	(4,a4),d1
	sub.w	#4*8,d1
	bmi		2f		| not visible
	cmp.w	#NB_LINES-15,d1
	bcc.w	2f		| too low
	cmp.w	min_sprite_y(pc),d1
	bcs.w	2f
	cmp.w	max_sprite_y(pc),d1
	bcc.w	2f

	move.w	d1,d3			| save y
	clr.w	d0
	move.b	(2,a4),d0	    | tile code
	move.b	(3,a4),d1	    | tile color
	move.b		(1,a4),d2   | tile attributes	
	bpl.b	5f
	* second bank
	bset	#8,d0
5:
	* mask higher nibble
	swap	d0
	clr.w	d0
	swap	d0
	
	.ifne  OPT_ENABLE_LOGGING
	* log the tile, use start address in 0x104 then
	* S sprite_tile_log <address> !128*!320
	* then run the "convert_graphics.py" script
	* to discover the new sprite configurations
	
	lea		sprite_tile_log,a1
	move.l	a1,0x104
	movem.l	d0/d1,-(a7)
	lsl.w	#7,d0		| times 128
	add.l	d0,a1
	and.w	#0x7F,d1	| significant color bits
	move.b	#0xEE,(a1,d1.w)
	movem.l	(a7)+,d0/d1
	.endif

	* compute clut index in d1
	and.w	#0x7F,d1	| significant color bits TEMP
	
	* now d1 is the index, mul by 4 to get row pointer offset
	* (there are 2 versions of the sprite normal,mirror for each
	* color configuration)
	add.w	d1,d1
	* d1 times 128*2 (<<8) is the row start pointer
	lsl.l	#8,d0

	lea		_sprite_tile,a0


	add.l	d0,a0		| row offset
	move.w	(a0,d1.w),d1	| col offset
	bne.b	7f
	* sprite is not known with that CLUT configuration: blue flash
	move.w	#BASE_BPLCON3_VALUE,bplcon3+_custom
	move.w	#0xF,color+_custom
	tst.b	unknown_sprite_found
	bne.b	2f
	st.b	unknown_sprite_found
	**bsr		zzz
	nop
	
	bra.b	2f
7:
	btst	#7,d2			| X-flip?
	beq.b	3f
	add.w	#4*(NB_PLAYFIELD_PLANES+1),d1			| mirror planes come right after
3:
	cmp.w	#1,d1		| test blankptr
	beq.b	2f			| skip
	
	lea	(a3,d1.w),a0	| get pointer on bitplane pointer list
	move.w	(6,a4),d0
	subq.w	#8,d0		| sprite X offset
	move.w	d3,d1		| restore y
	bsr	blit_16x16_bob
2:
	lea		(8,a4),a4		| next sprite
	dbf		d4,4b

	* now restore all foreground tiles behind the previous
	* positions of the previously active objects
	
	*move.w	#31,d4			| 32 sprites
	*lea		fg_colorram,a1
	*lea		fg_videoram,a2
	
	* then back up current object state (X,Y,STATE) for next update
	move.l	(a7)+,a4
	move.w	#NB_SPRITES_TOTAL/2-1,d0	| 32*8 bytes
	* d7 is 0 or 32
	tst.w	d7
	beq.b	3f
	* second half of sprite data (*8 bytes, /2)
	lea		(NB_SPRITES_TOTAL*4,a4),a4
	lea		(NB_SPRITES_TOTAL*4,a5),a5
3:
	* copy one sprite backup structure (8 bytes) 32 times
	move.l	(a4)+,(a5)+
	move.l	(a4)+,(a5)+
	dbf		d0,3b

	* in the end, redraw dirty foreground tiles
	lea		fg_dirty_tiles,a2
	move.l	a2,a3	| keep base
	move.w	#FG_DIRTY_TILES_SIZE-1,d4
	lea		fg_colorram,a4
	lea		fg_videoram,a5
	moveq	#FG_TILE_DRAW_OR,d3
4:
	tst.b	(a2)+
	dbne	d4,4b
	tst		d4
	bmi.b	5f
	* found a dirty tile
	clr.b	(-1,a2)		| clean
	move.l	a2,d0
	sub.l	a3,d0
	subq.l	#1,d0
	move.b	(a5,d0.w),d1	| fetch tile from character grid
	cmp.b	#BLANK_FG_TILE_ID,d1
	beq.b	4b				| no need to OR with blank tile
	move.b	(a4,d0.w),d2	| fetch tile from color grid
	**move.b	#17,d1
	* now update tile to reflect the color change
	movem.l	d3-d4/a2-a5,-(a7)
	bsr	update_fg_tile
	movem.l	(a7)+,d3-d4/a2-a5
	bra.b	4b
5:

	.endif  | OPT_DISABLE_SPRITES
	rts
zzz:
			blitz
			rts
			
min_sprite_y:
	dc.w	0
max_sprite_y:
	dc.w	0
	
*P1 B2 = DSWB bit 0
*P2 B2 = DWSB bit 4

*Both are active LOW.

* d0=DSWA, d1=DSWB
osd_read_dipswitches:
	moveq	#-1,d0
	moveq	#-1,d1
	move.l	_joypad_state(pc),d2
	btst	#JPB_BTN_BLU,d2   | 2nd button: bomb
	beq.b	1f
	bclr	#0,d1	| active low
1:
	rts

bit_UP = 0
bit_DOWN = 1
bit_LEFT = 2
bit_RIGHT = 3
flag_UP = 1<<bit_UP
flag_DOWN = 1<<bit_DOWN
flag_LEFT = 1<<bit_LEFT
flag_RIGHT = 1<<bit_RIGHT

.macro	JOY_BIT_SET	dir
	btst	#JPB_BTN_\dir,d1
	beq.b	1f
	bset	#bit_\dir,d0
1:
	.endm
	
		
osd_read_p1_inputs:
	move.l	_joypad_state(pc),d1
	moveq.l	#0,d0
	JOY_BIT_SET	UP
	JOY_BIT_SET	DOWN
	JOY_BIT_SET	LEFT
	JOY_BIT_SET	RIGHT
	lea		direction_table(pc),a0
	move.b	(a0,d0.w),d0
	or.b	#0xF0,d0	| sets 0xF0 (bits 4 & 5 inactive high)
	
	btst	#JPB_BTN_RED,d1
	beq.b	1f
	bclr	#5,d0	| fire, active low
	move.l	_previous_joypad_state,d2
	btst	#JPB_BTN_RED,d2
	bne.b	1f		| was already pressed
	bclr	#4,d0	| first time fire press
1:
	*move.l	d1,_previous_joypad_state
	rts

create_direction_table:
	lea		direction_table(pc),a0
	move.b	#0,(flag_UP,a0)
	move.b	#1,(flag_UP+flag_RIGHT,a0)
	move.b	#2,(flag_RIGHT,a0)
	move.b	#3,(flag_DOWN+flag_RIGHT,a0)
	move.b	#4,(flag_DOWN,a0)
	move.b	#5,(flag_DOWN+flag_LEFT,a0)
	move.b	#6,(flag_LEFT,a0)
	move.b	#7,(flag_UP+flag_LEFT,a0)
	move.b	#8,(a0)
	rts
	
direction_table:
	ds.b	16
	
* set_bitplanes
* what: sets bitplanes in copperlist

set_bg_bitplanes:
    lea		bg_screen_data,a0
    moveq #NB_PLAYFIELD_PLANES-1,d1
	move.w	scroll_offset(pc),d2
	lea	mulNB_BYTES_PER_ROW_table(pc),a1
	.ifdef	NO68020
	add.w	d2,d2
	add.w	(a1,d2.w),a0
	.else
	add.w	(a1,d2.w*2),a0
	.endif
	move.l	a0,d0
    lea	bg_bitplanes+2,a0
1:
    swap d0
    move.w d0,(a0)
    swap d0
    move.w d0,(4,a0)    
    addq.w  #8,a0
    add.l #BG_SCREEN_PLANE_SIZE,d0
    dbf d1,1b
    rts

set_fg_bitplanes:
    move.l		fg_screen_pointer(pc),a0
    moveq #NB_PLAYFIELD_PLANES-1,d1
	move.l	a0,d0
    lea	fg_bitplanes+2,a0
1:
    swap d0
    move.w d0,(a0)
    swap d0
    move.w d0,(4,a0)    
    addq.w  #8,a0
    add.l #FG_SCREEN_PLANE_SIZE,d0
    dbf d1,1b
    rts
	
input_map_tbl:
		.byte			0xf8															|  0, none
		.byte			0xf0															|  1, up
		.byte			0xf4															|  2, down
		.byte			0xf8															|  3, down+up (invalid)
		.byte			0xf6															|  4, left
		.byte			0xf7															|  5, left+up
		.byte			0xf5															|  6, left+down
		.byte			0xf8															|  7, left+down+up (invalid)
		.byte			0xf2															|  8, right
		.byte			0xf1															|  9, right+up
		.byte			0xf3															|  A, right+down
		.byte			0xf8															|  B, right+down+up (invalid)
		.byte			0xf8															|  C, right+left (invalid)
		.byte			0xf8															|  D, right+left+up (invalid)
		.byte			0xf8															|  E, right+left+down (invalid)
		.byte			0xf8															|  F, right+left+down+up (invalid)
		
osd_read_p2_inputs:
		*move.b    BIOS_P2CURRENT,d0                 | read IN1
		bra				osd_read_p1_inputs
		rts

osd_debug_hook:
	rts
	
osd_read_coin:
	movem.l	a0/d1/d2,-(a7)
	move.b	#0,d0
	move.l	_joypad_state(pc),d1
	btst	#JPB_BTN_GRN,d1	
	beq.b	1f
	move.l	_previous_joypad_state(pc),d2
	btst	#JPB_BTN_GRN,d2	
	bne.b	1f
	lea		credit_sound,a0
	lea		_custom,a6
	jsr		_mt_playfx
	bset	#0,d0
1:
	move.l	d1,_previous_joypad_state
	movem.l	(a7)+,a0/d1/d2
	tst.b		d0	| required as API needs CCR!
	rts
		
		

	bne.b	1f		| was already pressed
	bclr	#4,d0	| first time fire press
1:
	*
		* D0 bit0=P1, bit1=P2.
osd_read_start:
	move.l	d1,-(a7)
	move.b	#0,d0
	move.l	_joypad_state(pc),d1
	btst	#JPB_BTN_YEL,d1
	movem.l	(a7)+,d1
	beq.b	osd_no_yel
	bset	#0,d0
osd_no_yel:
	tst.b	d0
9:	rts
		
osd_read_high_scores:
	rts
osd_write_high_scores:
	rts
	
* what: clears a plane of any width (using blitter), 16 height
* args:
* < A1: dest
* < D0: X (not necessarily multiple of 8)
* < D1: Y
* trashes: none
    
clear_plane_any_blitter_16x16:
    movem.l d0-d6/a1/a5,-(a7)
    lea _custom,a5
    moveq.l #-1,d3
	moveq	#4,d2
    move.w  #16,d4
    bsr clear_plane_any_blitter_internal
    movem.l (a7)+,d0-d6/a1/a5
    rts

* < A5: custom
* < D0,D1: x,y
* < A1: plane pointer
* < D2: width in bytes (inc. 2 extra for shifting)
* < D3: blit mask
* < D4: blit height
* trashes D0-D6
* > A1: even address where blit was done
clear_plane_any_blitter_internal:
    * pre-compute the maximum of shit here
    lea mulNB_BYTES_PER_ROW_table(pc),a2
    add.w   d1,d1
    beq.b   1f    | optim
    move.w  (a2,d1.w),d1
    swap    d1
    clr.w   d1
    swap    d1
1:
    move.l  #0x030A0000,d5   | minterm useC useD & rect clear (0xA) 
    move    d0,d6
    beq.b   2f
    and.w   #0xF,d6
    and.w   #0x1F0,d0
    lsr.w   #3,d0
    add.w   d0,d1

    swap    d6
    clr.w   d6
    lsl.l   #8,d6
    lsl.l   #4,d6
    or.l    d6,d5            | add shift
2:   
    add.l   d1,a1       | plane position (always even)

	move.w #NB_BYTES_PER_ROW,d0
    sub.w   d2,d0       | blit width

    lsl.w   #6,d4
    lsr.w   #1,d2
    add.w   d2,d4       | blit height

    * now just wait for blitter ready to write all registers
	bsr	wait_blit
    
    * blitter registers set
    move.l  d3,bltafwm(a5)
	move.l d5,bltcon0(a5)	
    move.w  d0,bltdmod(a5)	|D modulo
	move.w  #-1,bltadat(a5)	|source graphic top left corner
	move.l a1,bltcpt(a5)	|destination top left corner
	move.l a1,bltdpt(a5)	|destination top left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
    rts


* what: blits 16x16 data on bg planes, cookie cut
* args:
* < A0: data (16x16X(7+1))
* < D0: X
* < D1: Y
* < D2: bit 6: 0: direct, 1: flip
* trashes: D0-D1

blit_16x16_bob:
	movem.l	d2-d4/a0-a5,-(a7)
	move.l		fg_screen_pointer(pc),a1
	lea		blit_plane_cookie_cut_16x16(pc),a5
	btst	#6,d2
	beq.b	0f
	lea		blit_plane_cookie_cut_16x16_flipped(pc),a5	
0:
	moveq	#NB_PLAYFIELD_PLANES-1,d3
	moveq	#-1,d2
	move.l	a0,a4		| pointers on planes
	move.l	(NB_PLAYFIELD_PLANES*4,a4),a3		| mask is the last plane
1:
	move.l	(a4)+,a0     | next plane
	move.l	a1,a2
	jsr		(a5)
	lea		(FG_SCREEN_PLANE_SIZE,a1),a1
	dbf		d3,1b
	movem.l	(a7)+,d2-d4/a0-a5
	rts
	
* what: blits 16x16 data on one plane, cookie cut
* args:
* < A0: data (16x16)
* < A1: plane  (40 rows)
* < A2: background (40 rows) to mix with cookie cut
* < A3: source mask for cookie cut (16x16)
* < D0: X
* < D1: Y
* < D2: blit mask
* trashes: D0-D1

blit_plane_cookie_cut_16x16:
    movem.l d2-d7/a1-a5,-(a7)
    lea _custom,A5
	move.l d2,d3		|masking of first/last word    
    move.w  #4,d2       | 16 pixels + 2 shift bytes
    move.w  #16,d4      | 16 pixels height   
    bsr blit_plane_any_internal_cookie_cut
    movem.l (a7)+,d2-d7/a1-a5
    rts

* what: blits 16x16 data on one plane, cookie cut, flip
* args:
* < A0: data (16x16)
* < A1: plane  (40 rows)
* < A2: background (40 rows) to mix with cookie cut
* < A3: source mask for cookie cut (16x16)
* < D0: X
* < D1: Y
* < D2: blit mask
* trashes: D0-D1

blit_plane_cookie_cut_16x16_flipped:
    movem.l d2-d7/a1-a5,-(a7)
    lea _custom,A5
	move.l d2,d3		|masking of first/last word    
    move.w  #4,d2       | 16 pixels + 2 shift bytes
    move.w  #-16,d4      | 16 pixels height
    bsr blit_plane_any_internal_cookie_cut
    movem.l (a7)+,d2-d7/a1-a5
    rts
    
* < A5: custom
* < D0.W,D1.W: x,y
* < A0: source
* < A1: destination
* < A2: background to mix with cookie cut
* < A3: source mask for cookie cut
* < D2: width in bytes (inc. 2 extra for shifting)
* < D3: blit mask
* < D4: height. If negative, source is copied with negative modulo (flip)*       
* blit mask set
* returns: start of destination in A1 (computed from old A1+X,Y)
* trashes: a1

blit_plane_any_internal_cookie_cut:
    movem.l d0-d6/a2/a4,-(a7)
    * pre-compute the maximum of shit here
    lea		mulNB_BYTES_PER_ROW_table,a4
	tst.w	d4
	bpl.b	1f
	sub.w	d4,d1	| pre-add height to d1
	subq.w	#1,d1	| minus one
1:	
    swap    d1
    clr.w   d1
    swap    d1
    beq   .d1_zero    | optim
	.ifdef	NO68020
	add.w	d1,d1
    move.w  (a4,d1.w),d1	| y times 40
	.else
    move.w  (a4,d1.w*2),d1	| y times 40
	.endif
	add.w	d1,a2			| Y plane position for background
.d1_zero:
    move.l  #0x0fca0000,d5    | B+C-A->D cookie cut   

    move    d0,d6
    beq   .d0_zero
    asr.w   #3,d0
	bclr	#0,d0
    and.w   #0xF,d6
	beq	.no_shifting

    lsl.l   #8,d6
    lsl.l   #4,d6
    or.w    d6,d5            | add shift to mask (bplcon1)
    swap    d6
    clr.w   d6
    or.l    d6,d5            | add shift
.no_shifting:   
    move.w  d0,d6
    add.w   d0,d1
    
.d0_zero:
    * make offset even. Blitter will ignore odd address
    * but a 68000 CPU doesn't and since we RETURN A1...
    bclr    #0,d1
    add.l   d1,a1       | plane position (long: allow unsigned D1)

    add.w   d6,a2       | X offset for background

	move.w	#NB_BYTES_PER_ROW,d0
	tst.w	d4
	bpl.b	1f
	neg.w	d0
	neg.w	d4    | make d4 positive again
1:

    sub.w   d2,d0       | blit width
    lsl.w   #6,d4
    lsr.w   #1,d2
    add.w   d2,d4       | blit height

    * always the same settings (ATM)

    * now just wait for blitter ready to write all registers
	bsr	wait_blit
    
    * blitter registers set

    move.l  d3,bltafwm(a5)
	clr.w bltamod(a5)		|A modulo=bytes to skip between lines
	clr.w bltbmod(a5)		|A modulo=bytes to skip between lines
	move.l d5,bltcon0(a5)	| sets con0 and con1

    move.w  d0,bltcmod(a5)	|C modulo
    move.w  d0,bltdmod(a5)	|D modulo
							
	move.l a3,bltapt(a5)	|source graphic top left corner (mask)
	move.l a0,bltbpt(a5)	|source graphic top left corner
	move.l a2,bltcpt(a5)	|pristine background top (bottom) left corner
	move.l a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
    
    movem.l (a7)+,d0-d6/a2/a4
    rts

wait_blit:
	TST.B	0xBFE001
1:
	BTST	#6,dmaconr+_custom
	BNE.S	1b
	rts
	
	MUL_TABLE	NB_BYTES_PER_ROW,512
	MUL_TABLE	NB_PLAYFIELD_PLANES,512
	
current_sprite_state:
	ds.b	8*NB_SPRITES_TOTAL
previous_sprite_state:
	ds.b	8*NB_SPRITES_TOTAL
	
unknown_tile_found:
	dc.b	0
unknown_sprite_found:
	dc.b	0
ingame_palette_loaded:
	dc.b	0
	dc.b	0
	
scroll_offset:
	dc.w	0
vbl_counter:
		dc.w	0
_resload:
		dc.l	0
_joypad_state:
		dc.l	0
_previous_joypad_state:
		dc.l	0
_gfxbase:
	dc.l	0
fg_screen_pointer:
	dc.l	fg_screen_data_1
	
	.include	"sound_entries.68k"
	
*graphicsname:
*	.ascii	"graphics.library"
	
_end_of_ng_code:
		
		.text

	.align 2
palette:
	.include "palette.68k"
title_palette:
	.include "title_palette.68k"
original_palette:
	.include "original_palette.68k"

		.bss

		.align 4
	
	ds.b	96		| safety/margin
fg_dirty_tiles:
	ds.b	FG_DIRTY_TILES_SIZE
	ds.b	96		| safety/margin
	
	.ifne	OPT_ENABLE_LOGGING
bg_tile_log:
	ds.b	0x200*64    | there are 128 CLUTs but 1 bit is decided by tile code
sprite_tile_log:
	ds.b	320*128    | there are 128 CLUTs
	.endif
* using 2 tiles/sprite only
*scb1_shadow:									ds.w 	128*4*2
scb3_shadow:									ds.w 	128*2
scb4_shadow:									ds.w 	128*2
*scb4_shadow_2:								ds.w	128*2

.align 2
irq_cnt:											ds.w		1
		.data

* 36 rows = 288 pixels
* table of the colors for fg tiles in the copperlist
_fg_color_table:
	.set	fgrow_offset,2
	.long	color_row_0+4+fgrow_offset
	.rept	28
	.long	color_row_1+4+fgrow_offset
	.set	fgrow_offset,fgrow_offset+8
	.endr
	.long	color_row_30+2
	.set	fgrow_offset,2
	.rept	6
	.long	color_row_30_plus+fgrow_offset
	.set	fgrow_offset,fgrow_offset+8
	.endr

		.bsschip
	* some space to write tiles slightly outside screen
	* (scrolling requires it so it's seamless)
	ds.b	NB_BYTES_PER_ROW*12
bg_screen_data:
	ds.b	BG_SCREEN_SIZE
	ds.b	NB_BYTES_PER_ROW*12*3
	.align 0x8		| 8 else fmode=3 makes display wrong
fg_screen_data_1:
	ds.b	FG_SCREEN_SIZE
	
	* small margin (I suspect that gas is buggy with ds directive)
	* plus fg plane shifting can write one byte too far
	ds.b	100
	.align 0x8		| 8 else fmode=3 makes display wrong
fg_screen_data_2:
	ds.b	FG_SCREEN_SIZE
	
	* small margin (I suspect that gas is buggy with ds directive)
	* plus fg plane shifting can write one byte too far
	ds.b	100
	.datachip
	
.macro	DECL_4_BITPLANES	bpoff_start
	.set	bpoff,\bpoff_start
	.rept	4
	dc.w  0xe0+bpoff,0
	dc.w  0xe2+bpoff,0
	.set	bpoff,bpoff+8
	.endr
	.endm
	
copperlist:
fg_bitplanes:
	DECL_4_BITPLANES	4
bg_bitplanes:
	DECL_4_BITPLANES	0


   * reset color 0
	dc.w	bplcon3,BASE_BPLCON3_VALUE
	dc.w color,0
sprites:
score_sprite_white:
    ; #0
    dc.w    sprpt+0,0
    dc.w    sprpt+2,0
    ; #1
    dc.w    sprpt+4,0
    dc.w    sprpt+6,0
score_sprite_red:
    ; #2
    dc.w    sprpt+8,0
    dc.w    sprpt+10,0
    ; #3
    dc.w    sprpt+12,0
    dc.w    sprpt+14,0   
    ; #4
    dc.w    sprpt+16,0
    dc.w    sprpt+18,0
    ; #5
    dc.w    sprpt+20,0
    dc.w    sprpt+22,0
    ; #6
    dc.w    sprpt+24,0
    dc.w    sprpt+26,0
    ; #7
    dc.w    sprpt+28,0
    dc.w    sprpt+30,0
end_color_copper:
   * proper sprite priority: above bitplanes
   *dc.w  0x0102,0x0000            ;  BPLCON1 := 0x0000
   *dc.w  0x0104,0x0024            ;  BPLCON2 := 
   * dynamic colors for fg tile color each 8 lines
	.set    beampos,0x1C01
	.set    fgcol,color+17*2
	.set    testcol,0x0
color_row_0:
	dc.w	beampos,0xFFFE
	dc.w	fgcol,(testcol & 0x0FFF)
	.set	beampos,beampos+0x800
	.set	testcol,testcol+0x011
color_row_1:
	.rept	28
	dc.w	beampos,0xFFFE
	dc.w	fgcol,(testcol & 0x0FFF)
	.set	beampos,beampos+0x800
	.set	testcol,testcol+0x011
	.endr
	* pal limit
    dc.w  0xFFDF,0xFFFE           
    dc.w  0x0401,0xFFFE
	
color_row_30:
	dc.w	fgcol,0xFFF
    dc.w  0x0C01,0xFFFE           
	.set    testcol,0xF0
	.set    beampos,0x1401
color_row_30_plus:
	.rept	(48/8)
	dc.w	fgcol,(testcol & 0x0FFF)
	dc.w	beampos,0xFFFE
	.set	beampos,beampos+0x800
	.set	testcol,testcol+0x022
	.endr
	dc.w	fgcol,0xF00	| test
    dc.w	 intreq,0x8010
    dc.l    -2					
	

	* padding (workaround for gas bug)
	ds.b	4
_end_of_ng_data:
		