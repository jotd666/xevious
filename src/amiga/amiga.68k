*
*	Amiga-specific portions of Xevious
*


.include "../src/xevious.inc"
.include "custom.i"
.include "exec_lvos.i"
.include "graphics_lvos.i"

STATE_ACTIVE = 2
STATE_DO_NOT_UPDATE_SHADOW = 1
STATE_INACTIVE = 0
	
OPT_ENABLE_LOGGING = 1

_custom = 0xDFF000

NB_PLANES = 7
COPPERLIST_SIZE = 200
GRID_SIZE = 1<<11   | 6+5 bits to encode position
NB_BYTES_PER_ROW = 40
NB_LINES = 288
SCREEN_PLANE_SIZE = NB_BYTES_PER_ROW*NB_LINES*2
* 7 scrollable planes + 1 non-scrollable so shorter
SCREEN_SIZE = NB_PLANES*SCREEN_PLANE_SIZE+(SCREEN_PLANE_SIZE/2)


;.macro pixw nm, x, y
; .set \nm, (\x+\y*240)*2
;.endm

	bra	_user

| write current PC value to some address
.macro LOGPC	address
     bsr    .next_\@
.next_\@:
      addq.l    #6,(a7) | skip this & next instruction
      move.l    (a7)+,0x\address
.endm

	
.macro MUL_TABLE value,len
mul\value\()_table:
	.set    mulv,0
	.rept	\len
	dc.w	mulv
	.set	mulv,mulv+\value
	.endr
.endm

.macro GET_XY_ADDRESS  base_address
	* multiply D1 by 240
	lea		mulNB_BYTES_PER_ROW_table(pc),a1
	.ifdef	NO68020
	add.w	d1,d1
	move.w	(a1,d1.w),d1
	.else
	move.w	(a1,d1.w*2),d1
	.endif
	lea		\base_address,a1
	lsl.w	#3,d1
	* add y offset to screen data
	add.w	d1,a1
	* add x offset to screen data
	lsr.w	#6,d0
	neg.w	d0
	add.w	#32,d0	| mirror
	add.w	d0,a1
.endm

* damn, there's a 2-pixel shift between foreground layer
* and background layer, forcing us to write tile data on 2 bytes!!
* fortunately, there's only 1 plane to process that way
.macro	SET_FG_BYTE
	move.b	(offset+1,a1),d1
	move.b	(a0)+,d0
	bclr	#6,d1
	btst	#0,d0
	beq.b	1f
	bset	#6,d1
1:
	bclr	#7,d1
	btst	#1,d0
	beq.b	1f
	bset	#7,d1
1:
	move.b	d1,(offset+1,a1)
	move.b	(offset,a1),d1
	and.b	#0xC0,d1
	lsr.b	#2,d0
	or.b	d0,d1
	move.b	d1,(offset,a1)
	.endm
	
* the non shifted version is just so simple...
.macro	SET_FG_BYTE_SHIFT
	move.b	(a0)+,(offset,a1)
	.endm
	

.macro blitz
	move.w	d0,-(a7)
	clr.w	d0
loop\@:
	move.w	#0,_custom+bplcon3	| really color 0
	move.w	d0,_custom+color
	btst	#6,0xbfe001
	beq.b	out\@
	addq.w	#1,d0
	bra.b	loop\@
out\@:
	move.w	(a7)+,d0
	nop
.endm

* exports

    .global _jp_config
    .global _us_config
    .global _sp_config
   	.global DUMMY
	  .global _user
		.global _player_start
		.global _demo_end
		.global _coin_sound

* osd layer		
		.global osd_enable_vblank_interrupt
		.global osd_ack_vblank_interrupt
		.global osd_disable_vblank_interrupt
		.global osd_kick_wdog
		.global osd_w_fg_colorram
		.global osd_w_bg_colorram
		.global osd_w_fg_videoram
		.global osd_w_bg_videoram
		.global osd_update_scroll_hw
		.global osd_update_sprite_shadow
		.global osd_update_32_sprite_hw
		.global osd_read_dipswitches
		.global osd_read_p1_inputs
		.global osd_read_p2_inputs
		.global osd_read_coin
		.global osd_read_start

* debugging only
    .global osd_debug1
    .global osd_debug2
    .global osd_debug_hook
    .global	scb1_shadow
    .global scb3_shadow
    .global scb4_shadow
    .global _end_of_ng_code
    .global _end_of_ng_data
    
	.include	"ReadJoypad.inc"
		.text


.list

    .align 4
_jp_config:
_us_config:
_sp_config:
    .ascii    "XEVIOUS         "
    .word     0xffff
    .word     0xffff
    .byte     0xff
    .byte     0xff
    .byte     0x38                | bonus life (20,60,*60)
    .byte     0x24                | lives (3)
    .byte     0x02                | flags award bonus life (yes)
    .byte     0x14								| difficulty (normal)
    .byte     0x02                | cabinet
    .byte     0x00
    .byte     0x00
    .byte     0x00
    .byte     0x00
    .byte     0x00
* item names are 12 characters    
    .ascii    "BONUS LIFE  "      | item 5
    .ascii    "10K 40K *40K"
    .ascii    "10K 50K *50K"
    .ascii    "20K 50K *50K"
    .ascii    "20K 60K *60K"
    .ascii    "20K 70K *70K"
    .ascii    "20K 80K *80K"
    .ascii    "20K 60K only"
    .ascii    "NONE        "
    .ascii    "LIVES       "      | item 6
    .ascii    "3           "
    .ascii    "1           "
    .ascii    "2           "
    .ascii    "5           "
    .ascii    "FLAGS LIFE  "      | item 7
    .ascii    "YES         "
    .ascii    "NO          "
    .ascii		"DIFFICULTY  "			| item 8
    .ascii    "NORMAL      "
    .ascii    "EASY        "
    .ascii    "HARD        "
    .ascii    "HARDEST     "
    .ascii    "CABINET     "      | item 9
    .ascii    "VERTICAL    "
    .ascii    "HORIZONTAL  "

	.align 4
IRQ1:
	
	rte
    
	.align 4
IRQ3:
	
	rte

DUMMY:
	rte
	    
TRAP:
	rte
	    
_user:
    * if D0 contains "WHDL"
    * A0 contains resload
        
    cmp.l   #0x05748444c,D0	| WHDL
    bne.b   .standard
    move.l a0,_resload
    *move.b  d1,_keyexit
    *move.l  a0,a2
    *lea	_tags(pc),a0
    *jsr	resload_Control(a2)
    *bsr load_highscores
    bra.b   .startup
	nop
.standard:
    * open dos library, graphics library
    move.l  0x4.W,a6
    *lea dosname(pc),a1
    *moveq.l #0,d0
    *jsr _LVOOpenLibrary(a6)
    *move.l  d0,_dosbase
    *lea graphicsname(pc),a1
    *moveq.l #0,d0
    *jsr _LVOOpenLibrary(a6)
    *move.l  d0,_gfxbase
    *move.l	d0,a6
	*sub.l	a1,a1
	*jsr	_LVOLoadView(a6)
	*jsr	_LVOWaitTOF(a6)
	*jsr	_LVOWaitTOF(a6)
	*move.l  0x4.W,a6
    *bsr load_highscores

    * check if "floppy" file is here
    
    *move.l  _dosbase(pc),a6
    *move.l   #floppy_file,d1
    *move.l  #MODE_OLDFILE,d2
    *jsr     _LVOOpen(a6)
    *move.l  d0,d1
    *beq.b   .no_floppy
    
    * "floppy" file found
    *jsr     _LVOClose(a6)
    * wait 2 seconds for floppy drive to switch off
    *move.l  #100,d1
    *jsr     _LVODelay(a6)
.no_floppy:
	* stop cdtv device if found, avoids that cd device
	* sends spurious interrupts
    *move.l  #CMD_STOP,d0
    *bsr send_cdtv_command
.startup:
    lea  _custom,a5
    *move.b  #0,controller_joypad_1
    

* no multitask
    tst.l   _resload
    bne.b   .no_forbid
    *move.l  _gfxbase(pc),a4
    *move.l StartList(a4),gfxbase_copperlist

    move.l  4,a6
    jsr _LVOForbid(a6)
    
	sub.l	A1,A1
	jsr	_LVOFindTask(a6)		| find ourselves
	move.l	D0,A0
	*move.l	#-1,pr_WindowPtr(A0)	|Â no more system requesters (insert volume, write protected...)

.no_forbid:
	jsr	 _detect_controller_types 


		moveq			#2,d0
		*move.b		(BIOS_USER_REQUEST),d0
		lsl.w			#2,d0
    movea.l   1f(pc,d0.w),a0
    jmp       (a0)
    .align 4
1:	.long			startup_init
		.long			eye_catcher
		.long			demo_game
		.long			title_display

startup_init:
		rts

eye_catcher:
* we're not doing things the NeoGeo way
		rts


* To get the core to run, you just need to jump to xevious_reset after
* you've initialised the platform (Amiga) stuff. That essentially does a
* Z80 reset. You also need to call xevious_im1_irq from the Amiga vblank
* routine. They are the only 2 entry points required for the core to run,
* even if there's no other I/O.


demo_game:
		tst.l   _resload
		bne.b   .no_super
		move.l	4,A6
		jsr		_LVOSuperState(a6)
.no_super:	
		move		#0x4000,_custom+intena						| disable interrupts
		bsr			platform_init					| amiga-specific init
		jmp			xevious_reset					| pass control to the xevious core

title_display:
* we're not doing things the NeoGeo way
    rts

_player_start:
* we're not doing things the NeoGeo way
		rts
				
_demo_end:
* we're not doing things the NeoGeo way
		rts
				
_coin_sound:
* we're not doing things the NeoGeo way
		rts
				
_vblank:
    movem.l d0-d7/a0-a6,-(a7)
	move.w	_custom+intreqr,d0
	btst	#5,d0
	beq.b	.no_vblank
	moveq	#1,d0
	jsr	_read_joystick
	move.l	d0,_joypad_state
	
	jsr		xevious_im1_irq
	
    move.w  vbl_counter(pc),d0
    addq.w  #1,d0
    cmp.w   #5,d0
    bne.b   .normal
    * update a second time, simulate 60Hz
    jsr	xevious_im1_irq
    clr.w d0    
.normal:
    move.w  d0,vbl_counter
			
.no_vblank:
    movem.l (a7)+,d0-d7/a0-a6
	move.w	#0x70,_custom+intreq
    rte

osd_kick_wdog:
    rts

platform_init:
	
	lea		_custom,a5
	move.w	#0x7FFF,dmacon(a5)
    move.w #0x1C81,diwstrt(a5)
    move.w #0x30C1,diwstop(a5)
    move.w #0x0038,ddfstrt(a5)
    move.w #0x00D0,ddfstop(a5)
    move.w #0x0210,bplcon0(a5)  | 8 bitplanes
	
    clr.w bplcon1(a5) 
    clr.w bplcon2(a5)                     
    move.w #0,bpl1mod(a5) 
    move.w #0,bpl2mod(a5)

	bsr		set_bitplanes

	* load copperlist
	
	* set copperlist
	move.l	#copperlist,cop1lc(a5)
	* load palette
	lea		palette(pc),a0
	clr.w	d0
	bsr		set_aga_color_registers	
	move.w	#0x200,d0	| LOCT: 1
	bsr		set_aga_color_registers	
	
    * init sprite, bitplane, whatever dma
    move.w #0x83E0,dmacon(a5)

	* install vblank handler
	pea		_vblank(pc)
	move.l	(a7)+,0x6C.W
	
    rts

* < a0: source palette
* < d0: LOCT mask 0 or $200
set_aga_color_registers:
	move.w	d0,d2
    moveq	#0,d7
    move.w  #256,d1    | number of colors
    lsr.w   #5,d1   | divide by 32
    and.w   #0x1F,d0
    beq.b   1f
    add.w   #1,d1
1:
    * set AGA color bank
    move.w  d7,d0
    lsl.w   #8,d0
    lsl.w   #5,d0
	or.w	d2,d0
    move.w  d0,bplcon3(a5)
    lea color(a5),a1
    * now set the colors for that bank
    move.w  #31,d0 
2:
    move.w  (a0)+,(a1)+
    dbf d0,2b
    addq.w  #1,d7
    cmp.w   d1,d7
    bne.b   1b
    
    * reset bank so copperlist can work on base ECS bank
    move.w  #0,bplcon3(a5)
    rts

* 60Hz VBLANK interrupt
osd_enable_vblank_interrupt:
	move.w	#0xC020,_custom+intena
	rts

osd_ack_vblank_interrupt:
	move.w	#0x20,_custom+intreq
 	rts
		
osd_disable_vblank_interrupt:
	move.w	#0x0020,_custom+intena
	rts
		
* d0=offset (preserved), d1=attribute (preserved)
osd_w_fg_colorram:
    .ifeq OPT_DISABLE_FG_LAYER
	movem.l	d0-d5/a0-a1,-(a7)
	lea		_fg_color_data,a1
	move.b	d1,(a1,d0.w)	| store color X/Y flip attribute in fg table
	lea		_fg_char_data,a1
	move.b	d1,d2
	move.b	(a1,d0.w),d1	| fetch tile from character grid
	* now update tile to reflect the color change
	moveq	#0,d3
	bsr	update_fg_tile
	movem.l	(a7)+,d0-d5/a0-a1
   .endif | OPT_DISABLE_FG_LAYER
	rts

* d0=offset (preserved), d1=attribute (preserved)
osd_w_bg_colorram:
    .ifeq OPT_DISABLE_BG_LAYER
	movem.l	d0-d5/a0-a1,-(a7)
	lea		_bg_color_data,a1
	move.b	d1,(a1,d0.w)	| store attribute in bg table
	lea		_bg_char_data,a1
	move.b	d1,d2
	move.b	(a1,d0.w),d1	| fetch tile from character grid
	bsr	update_bg_tile
	movem.l	(a7)+,d0-d5/a0-a1
   .endif | OPT_DISABLE_BG_LAYER
	rts
		
* the first 4 rows are not visible, then the next 36 rows
* are visible. Screen is 32 tiles wide but only 28 visible.
*  Bottom 6 bits of D0 is the row, upper 5 bits are the column.
* d0=offset (preserved), d1=tile (preserved)
osd_w_fg_videoram:
    .ifeq OPT_DISABLE_FG_LAYER
	movem.l	d0-d5/a0-a2,-(a7)
	lea		_fg_color_data,a1
	lea		_fg_char_data,a2
	move.b	d1,(a2,d0.w)	| update logical grid
	move.b	(a1,d0.w),d2	| color & X/Y flip data
	moveq	#1,d3
	bsr		update_fg_tile
	movem.l	(a7)+,d0-d5/a0-a2
    .endif | OPT_DISABLE_FG_LAYER
	rts

* d0=offset (preserved), d1=tile (preserved)
osd_w_bg_videoram:
    .ifeq OPT_DISABLE_BG_LAYER
	movem.l	d0-d5/a0-a2,-(a7)
	lea		_bg_color_data,a1
	lea		_bg_char_data,a2
	move.b	d1,(a2,d0.w)	| update logical grid
	move.b	(a1,d0.w),d2	| color & X/Y flip data
	bsr		update_bg_tile
	movem.l	(a7)+,d0-d5/a0-a2
    .endif | OPT_DISABLE_BG_LAYER
	rts
	
* d0: offset
* d1: tile code (0-256 but extends to 512 with bit 0 of attribute)
* d2: attribute (0-255, color is in bits 0-5)
update_bg_tile:
	lea		_bg_tile,a0
	and.l	#0xFF,d1
	btst	#0,d2
	beq.b	1f
	bset	#8,d1	| upper part of background tile code
1:
	.ifne  OPT_ENABLE_LOGGING
	* log the tile, use start address in 0x100 then
	* S bg_tile_log <address> !64*!512
	lea		bg_tile_log,a1
	move.l	a1,0x100
	movem.l	d1/d2,-(a7)
	lsl.w	#6,d1		| times 64
	add.w	d1,a1
	and.w	#0x3F,d2	| significant color bits
	move.b	#0xDD,(a1,d2.w)
	movem.l	(a7)+,d1/d2
	.endif

	* compute clut index in d3
	* by descrambling the bizarre encoding
	move.b	d2,d3
	and.w	#0x3F,d3	| keep only 5:0 bits
	lsr.b	#2,d3
	move.b	d2,d4
	and.b	#3,d4
	lsl.b	#5,d4	| high color bits
	or.b	d4,d3	| add them back
	btst	#7,d1
	beq.b	2f
	bset	#4,d3	| add bit 4 if tile id > 0x80
2:
	* now d3 is the index, mul by 4 to get row pointer offset
	lsl.w	#2,d3
	* d1 times 512 (<<9) is the row start pointer
	lsl.l	#8,d1
	add.l	d1,d1
	
	btst	#6,d2			| X-flip?
	beq.b	3f
	add.w	#2,d3			| mirror version
3:
	add.l	d1,a0		| row offset
	add.w	d3,a0		| col offset
	move.w	(a0),d1
	bne.b	7f
	* tile is not known with that CLUT configuration: flash
	move.w	#0,bplcon3+_custom
	move.w	#0xF00,color+_custom
	bra.w	9f
7:
	move.w	d1,a0
	move.w	d0,d1
	and.w	#0x3F,d1		| row
	subq.w	#4,d1
	bmi		6f
	cmp.w	#64,d1
	bcc.w	6f
	
	GET_XY_ADDRESS		screen_data+NB_BYTES_PER_ROW*12

	moveq	#NB_PLANES-1,d3	| 7 planes (AGA)
	move.w	d2,d4

	cmp.w	#1,a0
	beq.b	8f		| clear

	add.l	#bg_picbase,a0
	
	* draw
	btst	#7,d4
	bne.b	5f
4:
	move.b	(a0)+,(a1)
	move.b	(a0)+,(NB_BYTES_PER_ROW,a1)
	move.b	(a0)+,(NB_BYTES_PER_ROW*2,a1)
	move.b	(a0)+,(NB_BYTES_PER_ROW*3,a1)
	move.b	(a0)+,(NB_BYTES_PER_ROW*4,a1)
	move.b	(a0)+,(NB_BYTES_PER_ROW*5,a1)
	move.b	(a0)+,(NB_BYTES_PER_ROW*6,a1)
	move.b	(a0)+,(NB_BYTES_PER_ROW*7,a1)
    lea   (SCREEN_PLANE_SIZE,a1),a1
    dbf d3,4b
	rts
	
5:   | y-flip
	move.b	(a0)+,(NB_BYTES_PER_ROW*7,a1)
	move.b	(a0)+,(NB_BYTES_PER_ROW*6,a1)
	move.b	(a0)+,(NB_BYTES_PER_ROW*5,a1)
	move.b	(a0)+,(NB_BYTES_PER_ROW*4,a1)
	move.b	(a0)+,(NB_BYTES_PER_ROW*3,a1)
	move.b	(a0)+,(NB_BYTES_PER_ROW*2,a1)
 	move.b	(a0)+,(NB_BYTES_PER_ROW,a1)
	move.b	(a0)+,(a1)
   lea		(SCREEN_PLANE_SIZE,a1),a1
    dbf		d3,5b
6:
	rts
8:
	clr.b	(a1)
	clr.b	(NB_BYTES_PER_ROW,a1)
	clr.b	(NB_BYTES_PER_ROW*2,a1)
	clr.b	(NB_BYTES_PER_ROW*3,a1)
	clr.b	(NB_BYTES_PER_ROW*4,a1)
	clr.b	(NB_BYTES_PER_ROW*5,a1)
	clr.b	(NB_BYTES_PER_ROW*6,a1)
	clr.b	(NB_BYTES_PER_ROW*7,a1)
    lea   (SCREEN_PLANE_SIZE,a1),a1
    dbf d3,8b
9:
	rts
	
* d0: offset
* d1: tile code
* d2: attribute
* d3: needs to redraw tile
update_fg_tile:
	moveq	#0,d4
	lea		_fg_tile,a0
	and.w	#0xFF,d1
	* handle special case of orange color hiscore
	cmp.w	#17,d1		| "H" tile
	bne.b	0f
	cmp.w	#0x504,d0	| HISCORE pos
	seq		d4
0:
	lsl.w	#4,d1			| *16 (each tile+mirror tile has 8+8 bytes)
	btst	#6,d2			| X-flip?
	beq.b	1f
	add.w	#8,d1			| mirror version
1:
	add.w	d1,a0
	move.w	d0,d1
	and.w	#0x3F,d1		| row
	subq.w	#4,d1
	bmi.w	3f

	cmp.w	#36,d1
	bcc.w	3f
	
	move.w	d2,d4
	* decode color
	and.w	#0x3F,d2	| drop flip x/y bits
	move.w	d2,d5
	lsr.w	#2,d2		| 5:2 => 3:0
	and.w	#0x3,d5		| keep 5:4
	lsl.w	#4,d5		| at proper position
	or.w	d5,d2		| combine
	lea		palette(pc),a1
	.ifdef	NO68020
	add.w	d2,d2
	move.w	(a1,d2.w),d2
	.else
	move.w	(a1,d2.w*2),d2
	.endif
	* update color for that row
	lea	_fg_color_table,a1
	.ifdef	NO68020
	move.w	d1,d5
	add.w	d5,d5
	add.w	d5,d5
	move.l	(a1,d5.w),a1
	.else
	move.l	(a1,d1.w*4),a1	
	.endif
	move.w	d2,(a1)			| color palette index
	move.w	d2,(8,a1)		| color palette index

	tst	d3
	bne.b	4f
	* no need to draw tile, called from color change
	* (saves cycles)
	rts
4:
	GET_XY_ADDRESS	screen_data+SCREEN_PLANE_SIZE*7
	
	
	* draw
	btst	#7,d4
	bne	2f
	.set	offset,0
	.rept		8
	SET_FG_BYTE
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	rts
2:
	.set	offset,NB_BYTES_PER_ROW*7
	.rept		8
	SET_FG_BYTE
	.set	offset,offset-NB_BYTES_PER_ROW
	.endr
3:
	rts
	
* d6 = bg_scroll_x_shadow
osd_update_scroll_hw:
	move.w	d6,scroll_offset
	* add to planes offset & change copperlist
	bra		set_bitplanes


* a5=obj_tbl
osd_update_sprite_shadow:
	lea       sprite_shadow_msb,a2
	lea		current_sprite_state(pc),a4
	moveq			#64-1,d7
1:
	move.b	(_STATE,a5),d0
	cmp.b	#STATE_DO_NOT_UPDATE_SHADOW,d0
	beq.b	3f
	move.b	d0,(a4)+
	move.b	(_ATTR,a5),(a4)+
	move.b	(_CODE,a5),(a4)+
	move.b	(_COLOUR,a5),(a4)+
	move.w	(_X,a5),d1
	lsr.w	#6,d1
	move.b	d1,(a2)+	| d1: X[8:1]
	add.w	d1,d1		| shift back
	move.w	d1,(a4)+
	move.w	(_Y,a5),d2
	lsr.w	#5,d2		| d2: Y[7:0]
	move.b	d2,(a2)+
	* mirror
	neg.w	d2
	add.w	#32*8,d2
	move.w	d2,(a4)+
2:
	lea		(_OBJSIZE,a5),a5
	dbf				d7,1b
	rts
3:
	addq.w	#8,a4
	addq.w	#2,a2
	bra.b	2b
	
.macro   UPDATE_BG_TILE_OFFSET	xoff,yoff
	movem.l	d0/d4/a1,-(a7)
	add.w	#\yoff-(\xoff<<6),d0
	move.b	(a1,d0.w),d2
	move.b	(a2,d0.w),d1
	bsr	update_bg_tile
	movem.l	(a7)+,d0/d4/a1
	.endm
	
* d0 = base sprite number (0/32)
osd_update_32_sprite_hw:
	lea		current_sprite_state(pc),a4
	lea		previous_sprite_state(pc),a5
	move.w	d0,d1
	beq.b	1f
	lsl.w	#3,d1		| times 8 (size of the "previous" struct)
	add.w	d1,a4		| add second half offset
	add.w	d1,a5		| add second half offset
1:
	* first restore all background tiles behind the previous
	* positions of the previously active objects
	movem.l	d0-d5/a0-a2/a5,-(a7)
	move.w	#31,d4			| 32 sprites
	lea		_bg_color_data,a1
	lea		_bg_char_data,a2
2:
	cmp.b	#STATE_INACTIVE,(a5)
	beq	3f
	* first convert sprite coords to background tile coords
	move.w	(6,a5),d0
	sub.w	#4,d0		| sprite Y offset (32-X on amiga screen)
	move.w	(4,a5),d1
	lsr.w	#3,d1
	lsr.w	#3,d0
	neg.w	d0
	add.w	#32,d0	| mirror
	* update background tile below sprite
	* translate sprite x,y in tile offset
	* offset = (32-x)<<6 + y
	lsl.w	#6,d0
	add.w	d1,d0	| should do it
	move.b	(a1,d0.w),d2
	move.b	(a2,d0.w),d1	| char
	movem.l	d0/d4/a1,-(a7)
	bsr	update_bg_tile
	movem.l	(a7)+,d0/d4/a1
	UPDATE_BG_TILE_OFFSET	1,0
	UPDATE_BG_TILE_OFFSET	1,1
	UPDATE_BG_TILE_OFFSET	1,-1
	UPDATE_BG_TILE_OFFSET	-1,-1
	UPDATE_BG_TILE_OFFSET	-1,0
	UPDATE_BG_TILE_OFFSET	-1,1
	UPDATE_BG_TILE_OFFSET	0,-1

3:
	lea		(8,a5),a5
	dbf		d4,2b
	movem.l	(a7)+,d0-d5/a0-a2/a5

	* then update the active sprites
	lea		sprite_picbase,a3
	move.l	a4,-(a7)
	move.w	#31,d4			| 32 sprites
	| sprite loop
4:
	cmp.b	#STATE_INACTIVE,(a4)
	beq.w	2f
	move.w	(4,a4),d1
	sub.w	#4*8,d1
	bmi		2f		| not visible
	cmp.w	#36*8,d1
	bcc.w	2f		| too low

	move.w	d1,d3			| save y
	clr.w	d0
	move.b	(2,a4),d0	    | tile code
	move.b	(3,a4),d1	    | tile color
	move.b		(1,a4),d2   | tile attributes	
	bpl.b	5f
	* second bank
	bset	#8,d0
5:
	* mask higher nibble
	swap	d0
	clr.w	d0
	swap	d0
	
	.ifne  OPT_ENABLE_LOGGING
	* log the tile, use start address in 0x104 then
	* S sprite_tile_log <address> !128*!320
	lea		sprite_tile_log,a1
	move.l	a1,0x104
	movem.l	d0/d1,-(a7)
	lsl.w	#7,d0		| times 128
	add.l	d0,a1
	and.w	#0x7F,d1	| significant color bits
	move.b	#0xEE,(a1,d1.w)
	movem.l	(a7)+,d0/d1
	.endif

	* compute clut index in d1
	and.w	#0x7F,d1	| significant color bits TEMP
	
	* now d1 is the index, mul by 4 to get row pointer offset
	* (there are 2 versions of the sprite normal,mirror for each
	* color configuration)
	lsl.w	#2,d1
	* d1 times 512 (<<9) is the row start pointer
	lsl.l	#8,d0
	add.l	d0,d0
	* TODO x/y flip
*	btst	#6,d2			| X-flip?
*	beq.b	3f
*	add.w	#2,d1			| mirror version comes right after
*3:
	lea		_sprite_tile,a0
	add.l	d0,a0		| row offset
	add.w	d1,a0		| col offset
	move.w	(a0),d1
	bne.b	7f
	* sprite is not known with that CLUT configuration: red flash
	move.w	#0,bplcon3+_custom
	move.w	#0xF,color+_custom
	bra.b	2f
7:
	lea		(a3,d1.w),a0	| sprite data
	move.w	(6,a4),d0
	subq.w	#8,d0		| sprite X offset
	move.w	d3,d1		| restore y
	addq.w	#4,d1		| sprite Y offset
	bsr	blit_16x16_bob

2:
	lea		(8,a4),a4		| next sprite
	dbf		d4,4b
	* then back up current object state (X,Y,STATE) for next update
	move.l	(a7)+,a4
	move.w	#31,d0	| 32*8 bytes
3:
	* copy one sprite backup structure (8 bytes) 32 times
	move.l	(a4)+,(a5)+
	move.l	(a4)+,(a5)+
	dbf		d0,3b
	rts
zzz:
			blitz
			rts
* d0=DSWA, d1=DSWB
osd_read_dipswitches:
		rts

* - neogeo   5=B2, 4=B1, 3=right, 2=left, 1=down,  0=up
		
osd_read_p1_inputs:
	moveq.l	#-1,d0
	rts

* set_bitplanes
* what: sets bitplanes in copperlist

set_bitplanes:
    lea		screen_data,a0
    moveq #NB_PLANES-1,d1
	move.w	scroll_offset(pc),d2
	lea	mulNB_BYTES_PER_ROW_table(pc),a1
	.ifdef	NO68020
	add.w	d2,d2
	add.w	(a1,d2.w),a0
	.else
	add.w	(a1,d2.w*2),a0
	.endif
	move.l	a0,d0
    lea	bitplanes+2,a0
.mkcl:
    swap d0
    move.w d0,(a0)
    swap d0
    move.w d0,(4,a0)    
    addq.w  #8,a0
    add.l #SCREEN_PLANE_SIZE,d0
    dbf d1,.mkcl
	* foreground bitplane doesn't scroll
    move.l	#screen_data+7*SCREEN_PLANE_SIZE,d0
    swap d0
    move.w d0,(a0)
    swap d0
    move.w d0,(4,a0)    
    rts
	
input_map_tbl:
		.byte			0xf8															|  0, none
		.byte			0xf0															|  1, up
		.byte			0xf4															|  2, down
		.byte			0xf8															|  3, down+up (invalid)
		.byte			0xf6															|  4, left
		.byte			0xf7															|  5, left+up
		.byte			0xf5															|  6, left+down
		.byte			0xf8															|  7, left+down+up (invalid)
		.byte			0xf2															|  8, right
		.byte			0xf1															|  9, right+up
		.byte			0xf3															|  A, right+down
		.byte			0xf8															|  B, right+down+up (invalid)
		.byte			0xf8															|  C, right+left (invalid)
		.byte			0xf8															|  D, right+left+up (invalid)
		.byte			0xf8															|  E, right+left+down (invalid)
		.byte			0xf8															|  F, right+left+down+up (invalid)
		
osd_read_p2_inputs:
		*move.b    BIOS_P2CURRENT,d0                 | read IN1
		bra				osd_read_p1_inputs
		rts

osd_debug_hook:
	rts
	
osd_read_coin:
	move.l	d1,-(a7)
	move.b	#0,d0
	move.l	_joypad_state(pc),d1
	btst	#JPB_BTN_GRN,d1
	movem.l	(a7)+,d1
	beq.b	osd_no_grn
	bset	#0,d0
osd_no_grn:
	tst.b		d0	| required as API needs CCR!
9:	rts
		
		* D0 bit0=P1, bit1=P2.
osd_read_start:
	move.l	d1,-(a7)
	move.b	#0,d0
	move.l	_joypad_state(pc),d1
	btst	#JPB_BTN_YEL,d1
	movem.l	(a7)+,d1
	beq.b	osd_no_yel
	bset	#0,d0
osd_no_yel:
	tst.b	d0
9:	rts
		
* what: blits 16x16 data on bg planes, cookie cut
* args:
* < A0: data (16x16X(7+1))
* < D0: X
* < D1: Y
* trashes: D0-D1

blit_16x16_bob:
	movem.l	d2-d4/a0-a2,-(a7)
	lea		screen_data,a1
	moveq	#NB_PLANES-1,d3
	lea		(64*NB_PLANES,a0),a3		| mask
	moveq	#-1,d2
1:
	move.l	a1,a2
	bsr.b	blit_plane_cookie_cut
	lea		(SCREEN_PLANE_SIZE,a1),a1
	lea		(64,a0),a0  | next plane
	dbf		d3,1b
	movem.l	(a7)+,d2-d4/a0-a2
	rts
	
* what: blits 16x16 data on one plane, cookie cut
* args:
* < A0: data (16x16)
* < A1: plane  (40 rows)
* < A2: background (40 rows) to mix with cookie cut
* < A3: source mask for cookie cut (16x16)
* < D0: X
* < D1: Y
* < D2: blit mask
* trashes: D0-D1

blit_plane_cookie_cut:
    movem.l d2-d7/a1-a5,-(a7)
    lea _custom,A5
	move.l d2,d3		|masking of first/last word    
    move.w  #4,d2       | 16 pixels + 2 shift bytes
    move.w  #16,d4      | 16 pixels height   
    bsr blit_plane_any_internal_cookie_cut
    movem.l (a7)+,d2-d7/a1-a5
    rts
    
* < A5: custom
* < D0.W,D1.W: x,y
* < A0: source
* < A1: destination
* < A2: background to mix with cookie cut
* < A3: source mask for cookie cut
* < D2: width in bytes (inc. 2 extra for shifting)
* < D3: blit mask
* < D4: height
* blit mask set
* returns: start of destination in A1 (computed from old A1+X,Y)
* trashes: a1

blit_plane_any_internal_cookie_cut:
    movem.l d0-d6/a2/a4,-(a7)
    * pre-compute the maximum of shit here
    lea		mulNB_BYTES_PER_ROW_table,a4
    swap    d1
    clr.w   d1
    swap    d1
    beq   .d1_zero    | optim
	.ifdef	NO68020
	add.w	d1,d1
    move.w  (a4,d1.w),d1	| y times 40
	.else
    move.w  (a4,d1.w*2),d1	| y times 40
	.endif
	add.w	d1,a2			| Y plane position for background
.d1_zero:
    move.l  #0x0fca0000,d5    | B+C-A->D cookie cut   

    move    d0,d6
    beq   .d0_zero
    asr.w   #3,d0
	bclr	#0,d0
    and.w   #0xF,d6
	beq	.no_shifting

    lsl.l   #8,d6
    lsl.l   #4,d6
    or.w    d6,d5            | add shift to mask (bplcon1)
    swap    d6
    clr.w   d6
    or.l    d6,d5            | add shift
.no_shifting:   
    move.w  d0,d6
    add.w   d0,d1
    
.d0_zero:
    * make offset even. Blitter will ignore odd address
    * but a 68000 CPU doesn't and since we RETURN A1...
    bclr    #0,d1
    add.l   d1,a1       | plane position (long: allow unsigned D1)

    add.w   d6,a2       | X offset for background

	move.w	#NB_BYTES_PER_ROW,d0

    sub.w   d2,d0       | blit width

    lsl.w   #6,d4
    lsr.w   #1,d2
    add.w   d2,d4       | blit height

    * always the same settings (ATM)

    * now just wait for blitter ready to write all registers
	bsr	wait_blit
    
    * blitter registers set

    move.l  d3,bltafwm(a5)
	clr.w bltamod(a5)		|A modulo=bytes to skip between lines
	clr.w bltbmod(a5)		|A modulo=bytes to skip between lines
	move.l d5,bltcon0(a5)	| sets con0 and con1

    move.w  d0,bltcmod(a5)	|C modulo
    move.w  d0,bltdmod(a5)	|D modulo
							
	move.l a3,bltapt(a5)	|source graphic top left corner (mask)
	move.l a0,bltbpt(a5)	|source graphic top left corner
	move.l a2,bltcpt(a5)	|pristine background
	move.l a1,bltdpt(a5)	|destination top left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
    
    movem.l (a7)+,d0-d6/a2/a4
    rts

wait_blit:
	TST.B	0xBFE001
1:
	BTST	#6,dmaconr+_custom
	BNE.S	1b
	rts
	
	MUL_TABLE	NB_BYTES_PER_ROW,512
	MUL_TABLE	NB_PLANES,512
	
current_sprite_state:
	ds.b	8*64
previous_sprite_state:
	ds.b	8*64
	
scroll_offset:
	dc.w	0
vbl_counter:
		dc.w	0
_resload:
		dc.l	0
_joypad_state:
		dc.l	0
_gfxbase:
	dc.l	0
*graphicsname:
*	.ascii	"graphics.library"
	
_end_of_ng_code:
		
		.text

	.align 2
palette:
	.include "palette.68k"

		.bss

		.align 4
	.ifne	OPT_ENABLE_LOGGING
bg_tile_log:
	ds.b	0x200*64    | there are 128 CLUTs but 1 bit is decided by tile code
sprite_tile_log:
	ds.b	320*128    | there are 128 CLUTs
	.endif
* using 2 tiles/sprite only
*scb1_shadow:									ds.w 	128*4*2
scb3_shadow:									ds.w 	128*2
scb4_shadow:									ds.w 	128*2
*scb4_shadow_2:								ds.w	128*2

.align 2
irq_cnt:											ds.w		1
		.data

* 36 rows = 288 pixels
* table of the colors for fg tiles in the copperlist
_fg_color_table:
	.set	fgrow_offset,2
	.long	color_row_0+8+fgrow_offset
	.rept	28
	.long	color_row_1+8+fgrow_offset
	.set	fgrow_offset,fgrow_offset+20
	.endr
	.long	color_row_30+6
	.set	fgrow_offset,2
	.rept	6
	.long	color_row_30_plus+4+fgrow_offset
	.set	fgrow_offset,fgrow_offset+20
	.endr
	
_fg_color_data:
	ds.b	GRID_SIZE
_bg_color_data:
	ds.b	GRID_SIZE
_fg_char_data:
	ds.b	GRID_SIZE
_bg_char_data:
	ds.b	GRID_SIZE
		.bsschip
screen_data:
	ds.b	SCREEN_SIZE
	
	* small margin (I suspect that gas is buggy with ds directive)
	* plus fg plane shifting can write one byte too far
	ds.b	100
	.datachip
	

copperlist:
bitplanes:
   dc.l  0x00e00000
   dc.l  0x00e20000
   dc.l  0x00e40000
   dc.l  0x00e60000
   dc.l  0x00e80000
   dc.l  0x00ea0000
   dc.l  0x00ec0000
   dc.l  0x00ee0000
   dc.l  0x00f00000
   dc.l  0x00f20000
   dc.l  0x00f40000
   dc.l  0x00f60000
   dc.l  0x00f80000
   dc.l  0x00fa0000
   dc.l  0x00fc0000
   dc.l  0x00fe0000
   * reset color 0
   dc.w	bplcon3,0
	dc.w color,0
sprites:
score_sprite_white:
    ; #0
    dc.w    sprpt+0,0
    dc.w    sprpt+2,0
    ; #1
    dc.w    sprpt+4,0
    dc.w    sprpt+6,0
score_sprite_red:
    ; #2
    dc.w    sprpt+8,0
    dc.w    sprpt+10,0
    ; #3
    dc.w    sprpt+12,0
    dc.w    sprpt+14,0   
    ; #4
    dc.w    sprpt+16,0
    dc.w    sprpt+18,0
    ; #5
    dc.w    sprpt+20,0
    dc.w    sprpt+22,0
    ; #6
    dc.w    sprpt+24,0
    dc.w    sprpt+26,0
    ; #7
    dc.w    sprpt+28,0
    dc.w    sprpt+30,0
end_color_copper:
   * proper sprite priority: above bitplanes
   *dc.w  0x0102,0x0000            ;  BPLCON1 := 0x0000
   *dc.w  0x0104,0x0024            ;  BPLCON2 := 
   * dynamic colors for color 128 each 8 lines
	.set    beampos,0x1C01
	.set    testcol,0x0
	.set	color_28,color+28*2
color_row_0:
	dc.w	bplcon3,4<<13	| color 128
	dc.w	beampos,0xFFFE
	dc.w	color,(testcol & 0x0FFF)
	dc.w	bplcon3,5<<13	| color 188
	dc.w	color_28,0xFFF
	* special copper change
color_row_0_col_4:
	*dc.w	bplcon3,0  |4<<13	| color 128
	*dc.w	beampos+90,0xFF00+(90<<1)
	*dc.w	color,0xF00
	
	.set	beampos,beampos+0x800
	.set	testcol,testcol+0x011
color_row_1:
	.rept	28
	dc.w	bplcon3,4<<13	| color 128
	dc.w	beampos,0xFFFE
	dc.w	color,(testcol & 0x0FFF)
	dc.w	bplcon3,5<<13	| color 188
	dc.w	color_28,0xFFF
	.set	beampos,beampos+0x800
	.set	testcol,testcol+0x011
	.endr
	* pal limit
    dc.w  0xFFDF,0xFFFE           
    dc.w  0x0401,0xFFFE
color_row_30:
	dc.w	bplcon3,4<<13	| color 128
	dc.w	color,0xFFF
	dc.w	bplcon3,5<<13	| color 188
	dc.w	color_28,0xFFF
    dc.w  0x0C01,0xFFFE           
          
	.set    testcol,0xF0
	.set    beampos,0x1401
color_row_30_plus:
	.rept	48/8
	dc.w	bplcon3,4<<13	| color 128
	dc.w	color,(testcol & 0x0FFF)
	dc.w	bplcon3,5<<13	| color 188
	dc.w	color_28,0xFFF
	dc.w	beampos,0xFFFE
	.set	beampos,beampos+0x800
	.set	testcol,testcol+0x022
	.endr
   
    dc.w	 intreq,0x8010
	dc.w	bplcon3,0  | reset ECS	
    dc.l    -2					
	

	* padding (workaround for gas bug)
	ds.b	4
_end_of_ng_data:
		