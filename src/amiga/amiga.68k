*
*	Amiga-specific portions of Xevious
*


.include "../src/xevious.inc"
.include "custom.i"
.include "exec_lvos.i"


_custom = 0xDFF000

NB_PLANES = 4
COPPERLIST_SIZE = 200
NB_BYTES_PER_ROW = 40
NB_LINES = 288
SCREEN_PLANE_SIZE = NB_BYTES_PER_ROW*NB_LINES
SCREEN_SIZE = NB_PLANES*SCREEN_PLANE_SIZE


;.macro pixw nm, x, y
; .set \nm, (\x+\y*240)*2
;.endm

	bra	_user
.macro blitz
	move.w	d0,-(a7)
	clr.w	d0
loop\@:
	move.w	d0,0xdff180
	btst	#6,0xbfe001
	beq.b	out\@
	addq.w	#1,d0
	bra.b	loop\@
out\@:
	move.w	(a7)+,d0
.endm

* exports

    .global _jp_config
    .global _us_config
    .global _sp_config
   	.global DUMMY
	  .global _user
		.global _player_start
		.global _demo_end
		.global _coin_sound

* osd layer		
		.global osd_enable_vblank_interrupt
		.global osd_ack_vblank_interrupt
		.global osd_disable_vblank_interrupt
		.global osd_kick_wdog
		.global osd_w_fg_colorram
		.global osd_w_bg_colorram
		.global osd_w_fg_videoram
		.global osd_w_bg_videoram
		.global osd_update_scroll_hw
		.global osd_update_sprite_shadow
		.global osd_update_32_sprite_hw
		.global osd_read_dipswitches
		.global osd_read_p1_inputs
		.global osd_read_p2_inputs
		.global osd_read_coin
		.global osd_read_start

* debugging only
    .global osd_debug1
    .global osd_debug2
    .global	scb1_shadow
    .global scb3_shadow
    .global scb4_shadow
    .global _end_of_ng_code
    .global _end_of_ng_data
    
		.text


.list

    .align 4
_jp_config:
_us_config:
_sp_config:
    .ascii    "XEVIOUS         "
    .word     0xffff
    .word     0xffff
    .byte     0xff
    .byte     0xff
    .byte     0x38                | bonus life (20,60,*60)
    .byte     0x24                | lives (3)
    .byte     0x02                | flags award bonus life (yes)
    .byte     0x14								| difficulty (normal)
    .byte     0x02                | cabinet
    .byte     0x00
    .byte     0x00
    .byte     0x00
    .byte     0x00
    .byte     0x00
* item names are 12 characters    
    .ascii    "BONUS LIFE  "      | item 5
    .ascii    "10K 40K *40K"
    .ascii    "10K 50K *50K"
    .ascii    "20K 50K *50K"
    .ascii    "20K 60K *60K"
    .ascii    "20K 70K *70K"
    .ascii    "20K 80K *80K"
    .ascii    "20K 60K only"
    .ascii    "NONE        "
    .ascii    "LIVES       "      | item 6
    .ascii    "3           "
    .ascii    "1           "
    .ascii    "2           "
    .ascii    "5           "
    .ascii    "FLAGS LIFE  "      | item 7
    .ascii    "YES         "
    .ascii    "NO          "
    .ascii		"DIFFICULTY  "			| item 8
    .ascii    "NORMAL      "
    .ascii    "EASY        "
    .ascii    "HARD        "
    .ascii    "HARDEST     "
    .ascii    "CABINET     "      | item 9
    .ascii    "VERTICAL    "
    .ascii    "HORIZONTAL  "

	.align 4
IRQ1:
	
	rte
    
	.align 4
IRQ3:
	
	rte

DUMMY:
	rte
	    
TRAP:
	rte
	    
_user:
    * if D0 contains "WHDL"
    * A0 contains resload
        
    cmp.l   #0x05748444c,D0	| WHDL
    bne.b   .standard
    move.l a0,_resload
    *move.b  d1,_keyexit
    *move.l  a0,a2
    *lea	_tags(pc),a0
    *jsr	resload_Control(a2)
    *bsr load_highscores
    bra.b   .startup
	nop
.standard:
    * open dos library, graphics library
    *move.l  $4.W,a6
    *lea dosname(pc),a1
    *moveq.l #0,d0
    *jsr _LVOOpenLibrary(a6)
    *move.l  d0,_dosbase
    *lea graphicsname(pc),a1
    *moveq.l #0,d0
    *jsr _LVOOpenLibrary(a6)
    *move.l  d0,_gfxbase
    
    *bsr load_highscores

    * check if "floppy" file is here
    
    *move.l  _dosbase(pc),a6
    *move.l   #floppy_file,d1
    *move.l  #MODE_OLDFILE,d2
    *jsr     _LVOOpen(a6)
    *move.l  d0,d1
    *beq.b   .no_floppy
    
    * "floppy" file found
    *jsr     _LVOClose(a6)
    * wait 2 seconds for floppy drive to switch off
    *move.l  #100,d1
    *jsr     _LVODelay(a6)
.no_floppy:
	* stop cdtv device if found, avoids that cd device
	* sends spurious interrupts
    *move.l  #CMD_STOP,d0
    *bsr send_cdtv_command
.startup:

    
    lea  _custom,a5
    *move.b  #0,controller_joypad_1
    

* no multitask
    tst.l   _resload
    bne.b   .no_forbid
    *move.l  _gfxbase(pc),a4
    *move.l StartList(a4),gfxbase_copperlist

    move.l  4,a6
    jsr _LVOForbid(a6)
    
	sub.l	A1,A1
	jsr	_LVOFindTask(a6)		| find ourselves
	move.l	D0,A0
	*move.l	#-1,pr_WindowPtr(A0)	|Â no more system requesters (insert volume, write protected...)

.no_forbid:


		moveq			#2,d0
		*move.b		(BIOS_USER_REQUEST),d0
		lsl.w			#2,d0
    movea.l   1f(pc,d0.w),a0
    jmp       (a0)
    .align 4
1:	.long			startup_init
		.long			eye_catcher
		.long			demo_game
		.long			title_display

startup_init:
		rts

eye_catcher:
* we're not doing things the NeoGeo way
		rts


* To get the core to run, you just need to jump to xevious_reset after
* you've initialised the platform (Amiga) stuff. That essentially does a
* Z80 reset. You also need to call xevious_im1_irq from the Amiga vblank
* routine. They are the only 2 entry points required for the core to run,
* even if there's no other I/O.


demo_game:
		tst.l   _resload
		bne.b   .no_super
		move.l	4,A6
		jsr		_LVOSuperState(a6)
.no_super:	
		move		#0x4000,_custom+intena						| disable interrupts
		bsr			platform_init					| amiga-specific init
		jmp			xevious_reset					| pass control to the xevious core

title_display:
* we're not doing things the NeoGeo way
    rts

_player_start:
* we're not doing things the NeoGeo way
		rts
				
_demo_end:
* we're not doing things the NeoGeo way
		rts
				
_coin_sound:
* we're not doing things the NeoGeo way
		rts
				
_vblank:
    movem.l d0-d7/a0-a6,-(a7)
	move.w	_custom+intreqr,d0
	btst	#5,d0
	beq.b	.no_vblank
	
	jsr		xevious_im1_irq
	
    move.w  vbl_counter(pc),d0
    addq.w  #1,d0
    cmp.w   #5,d0
    bne.b   .normal
    * update a second time, simulate 60Hz
    jsr	xevious_im1_irq
    clr.w d0    
.normal:
    move.w  d0,vbl_counter
			
.no_vblank:
    movem.l (a7)+,d0-d7/a0-a6
	move.w	#0x70,_custom+intreq
    rte

osd_kick_wdog:
    rts

platform_init:
	lea		_custom,a5
	move.w	#0x7FFF,dmacon(a5)
    move.w #0x3081,diwstrt(a5)
    move.w #0x30C1,diwstop(a5)
    move.w #0x0038,ddfstrt(a5)
    move.w #0x00D0,ddfstop(a5)
    move.w #0x4200,bplcon0(a5)
    clr.w bplcon1(a5) 
    clr.w bplcon2(a5)                     
    move.w #0,bpl1mod(a5) 
    move.w #0,bpl2mod(a5)

	bsr		set_bitplanes

	* load copperlist
	
	* set copperlist
	move.l	#copperlist,cop1lc(a5)
	* load palette
	lea		palette(pc),a0
	lea		_custom+color,a1
	move.w	#15,d0
.copy:
	move.w	(a0)+,(a1)+
	dbf		d0,.copy
	
    * init sprite, bitplane, whatever dma
    move.w #0x83E0,dmacon(a5)

	* install vblank handler
	pea		_vblank(pc)
	move.l	(a7)+,0x6C.W
	
    rts

* 60Hz VBLANK interrupt
osd_enable_vblank_interrupt:
	move.w	#0xC020,_custom+intena
	rts

osd_ack_vblank_interrupt:
	move.w	#0x20,_custom+intreq
 	rts
		
osd_disable_vblank_interrupt:
	move.w	#0x0020,_custom+intena
	rts
		
* d0=offset (preserved), d1=attribute (preserved)
osd_w_fg_colorram:
		rts

* d0=offset (preserved), d1=attribute (preserved)
osd_w_bg_colorram:
		rts
		
* the first 4 rows are not visible, then the next 36 rows
* are visible. Screen is 32 tiles wide but only 28 visible.
*  Bottom 6 bits of D0 is the row, upper 5 bits are the column.
* d0=offset (preserved), d1=tile (preserved)
osd_w_fg_videoram:
	movem.l	d0-d1/a0-a1,-(a7)
	lea		_fg_tile,a0
	bsr		process_bg_fg_tile
	movem.l	(a7)+,d0-d1/a0-a1
	rts

* d0=offset (preserved), d1=tile (preserved)
osd_w_bg_videoram:
	movem.l	d0-d1/a0-a1,-(a7)
	lea		_bg_tile,a0
	;bsr		process_bg_fg_tile
	movem.l	(a7)+,d0-d1/a0-a1
	rts
	
process_bg_fg_tile:
	lsl.w	#5,d1		| *32 (each tile has 8 bytes ATM)
	add.w	d1,a0
	move.w	d0,d1
	and.w	#0x3F,d1		| row
	subq.w	#4,d1
	bmi.b	.fg_out
	mulu.w	#NB_BYTES_PER_ROW,d1		| TODO: use table
	lsl.w	#3,d1	| *8
	lea		screen_data,a1
	add.w	d1,a1
	lsr.w	#6,d0
	neg.w	d0
	add.w	#32,d0	| mirror
	add.w	d0,a1
	move.w	#7,d0
.fg_copy:
	move.b	(a0)+,(a1)
	add.w	#NB_BYTES_PER_ROW,a1
	dbf		d0,.fg_copy
.fg_out:
	rts
	
* d6 = bg_scroll_x_shadow
osd_update_scroll_hw:
		rts

* a5=obj_tbl
osd_update_sprite_shadow:
		moveq			#64-1,d7
1:	jsr				update_sprite_shadow
		adda.w		#_OBJSIZE,a5
		dbf				d7,1b
		rts

update_sprite_shadow: | $0332
9:	rts
				
* d0 = base sprite number (0/32)
osd_update_32_sprite_hw:
		rts
		
* d0=DSWA, d1=DSWB
osd_read_dipswitches:
		rts

* - neogeo   5=B2, 4=B1, 3=right, 2=left, 1=down,  0=up
		
osd_read_p1_inputs:
	moveq.l	#-1,d0
	rts

* set_bitplanes
* what: sets bitplanes in copperlist

set_bitplanes:
    move.l	#screen_data,d0
    moveq #NB_PLANES-1,d1
    lea	bitplanes+2,a0
.mkcl:
    swap d0
    move.w d0,(a0)
    swap d0
    move.w d0,(4,a0)    
    addq.w  #8,a0
    add.l #SCREEN_PLANE_SIZE,d0
    dbf d1,.mkcl
    rts
	
input_map_tbl:
		.byte			0xf8															|  0, none
		.byte			0xf0															|  1, up
		.byte			0xf4															|  2, down
		.byte			0xf8															|  3, down+up (invalid)
		.byte			0xf6															|  4, left
		.byte			0xf7															|  5, left+up
		.byte			0xf5															|  6, left+down
		.byte			0xf8															|  7, left+down+up (invalid)
		.byte			0xf2															|  8, right
		.byte			0xf1															|  9, right+up
		.byte			0xf3															|  A, right+down
		.byte			0xf8															|  B, right+down+up (invalid)
		.byte			0xf8															|  C, right+left (invalid)
		.byte			0xf8															|  D, right+left+up (invalid)
		.byte			0xf8															|  E, right+left+down (invalid)
		.byte			0xf8															|  F, right+left+down+up (invalid)
		
osd_read_p2_inputs:
		*move.b    BIOS_P2CURRENT,d0                 | read IN1
		bra				osd_read_p1_inputs
		rts

osd_read_coin:
9:	rts
		
osd_read_start:
9:	rts
		
vbl_counter:
		dc.w	0
_resload:
		dc.l	0
		
_end_of_ng_code:
		
		.text

	.align 2
palette:
	.include "palette.68k"

		.bss

		.align 4

* using 2 tiles/sprite only
*scb1_shadow:									ds.w 	128*4*2
scb3_shadow:									ds.w 	128*2
scb4_shadow:									ds.w 	128*2
*scb4_shadow_2:								ds.w	128*2

.align 2
irq_cnt:											ds.w		1

		.datachip
screen_data:
	ds.b	SCREEN_SIZE
copperlist:
bitplanes:
   dc.l  0x00e00000
   dc.l  0x00e20000
   dc.l  0x00e40000
   dc.l  0x00e60000
   dc.l  0x00e80000
   dc.l  0x00ea0000
   dc.l  0x00ec0000
   dc.l  0x00ee0000
*   dc.l  $00f00000
*   dc.l  $00f20000

colors:
   dc.w color,0
sprites:
score_sprite_white:
    ; #0
    dc.w    sprpt+0,0
    dc.w    sprpt+2,0
    ; #1
    dc.w    sprpt+4,0
    dc.w    sprpt+6,0
score_sprite_red:
    ; #2
    dc.w    sprpt+8,0
    dc.w    sprpt+10,0
    ; #3
    dc.w    sprpt+12,0
    dc.w    sprpt+14,0   
    ; #4
    dc.w    sprpt+16,0
    dc.w    sprpt+18,0
    ; #5
    dc.w    sprpt+20,0
    dc.w    sprpt+22,0
    ; #6
    dc.w    sprpt+24,0
    dc.w    sprpt+26,0
    ; #7
    dc.w    sprpt+28,0
    dc.w    sprpt+30,0
end_color_copper:
   * proper sprite priority: above bitplanes
   *dc.w  $0102,$0000            ;  BPLCON1 := 0x0000
   *dc.w  $0104,$0024            ;  BPLCON2 := 
   dc.w  0xFFDF,0xFFFE           
   dc.w  0x2201,0xFFFE           
   dc.w	 intreq,0x8010          
    dc.l    -2					
	

	* padding (workaround for gas bug)
	ds.b	4
_end_of_ng_data:
		