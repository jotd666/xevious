*
* Neo Geo-specific portions of Xevious
*

* Neo Geo hardware definitions
.include "regdefs.68k"
.include "xevious.inc"

* exports

    .global _jp_config
    .global _us_config
    .global _sp_config
    .global IRQ1
    .global IRQ3
    .global DUMMY
    .global TRAP
    .global _user
    .global _player_start
    .global _demo_end
    .global _coin_sound

* osd layer   
    .global osd_enable_vblank_interrupt
    .global osd_ack_vblank_interrupt
    .global osd_disable_vblank_interrupt
    .global osd_kick_wdog
    .global osd_w_fg_colorram
    .global osd_w_bg_colorram
    .global osd_w_fg_videoram
    .global osd_w_bg_videoram
    .global osd_update_scroll_hw
    .global osd_update_sprite_shadow
    .global osd_update_32_sprite_hw
    .global osd_read_dipswitches
    .global osd_read_p1_inputs
    .global osd_read_p2_inputs
    .global osd_read_coin
    .global osd_read_start
    .global osd_sound_start
    .global osd_sound_stop
    .global osd_read_high_scores
    .global osd_write_high_scores
    .global osd_debug_hook

* debugging only
    .global osd_debug1
    .global osd_debug2
    .global fg_colorram_lookup_tbl
    .global bg_colorram_lookup_tbl
    .global _end_of_ng_code
    .global _end_of_ng_data
    
    .text

TRAP00=TRAP
TRAP01=TRAP
TRAP02=TRAP
TRAP03=TRAP
TRAP04=TRAP
TRAP05=TRAP
TRAP06=TRAP
TRAP07=TRAP
TRAP08=TRAP
TRAP09=TRAP
TRAP10=TRAP
TRAP11=TRAP
TRAP12=TRAP
TRAP13=TRAP
TRAP14=TRAP
TRAP15=TRAP

* Cartridge/CD header
.nolist
.include "header.68k"
.list

    .align 4
_jp_config:
_us_config:
_sp_config:
    .ascii    "XEVIOUS         "
    .word     0xffff
    .word     0xffff
    .byte     0xff
    .byte     0xff
    .byte     0x78                | bonus life (20,60,*60)
    .byte     0x34                | lives (3)
    .byte     0x02                | flags award bonus life (yes)
    .byte     0x04                | difficulty (normal)
    .byte     0x02                | cabinet
    .byte     0x00
    .byte     0x00
    .byte     0x00
    .byte     0x00
    .byte     0x00
* item names are 12 characters    
    .ascii    "BONUS LIFE  "      | item 5
    .ascii    "NONE        "
    .ascii    "20K 60K only"
    .ascii    "20K 80K *80K"
    .ascii    "20K 70K *70K"
    .ascii    "20K 50K *50K"
    .ascii    "10K 50K *50K"
    .ascii    "10K 40K *40K"
    .ascii    "20K 60K *60K"
    .ascii    "LIVES       "      | item 6
    .ascii    "5           "
    .ascii    "2           "
    .ascii    "1           "
    .ascii    "3           "
    .ascii    "FLAGS LIFE  "      | item 7
    .ascii    "NO          "
    .ascii    "YES         "
    .ascii    "DIFFICULTY  "      | item 8
    .ascii    "HARDEST     "
    .ascii    "HARD        "
    .ascii    "EASY        "
    .ascii    "NORMAL      "
    .ascii    "CABINET     "      | item 9
    .ascii    "VERTICAL    "
    .ascii    "HORIZONTAL  "

  .align 4
IRQ1:
  move.w  #2, 0x3C000C
  rte
    
  .align 4
IRQ3:
  move.w  #1, 0x3C000C
  rte

DUMMY:
  rte
      
TRAP:
  rte
      
_user:
    moveq     #0,d0
    move.b    (BIOS_USER_REQUEST),d0
    lsl.w     #2,d0
    movea.l   1f(pc,d0.w),a0
    jmp       (a0)
    .align 4
1:  .long     startup_init
    .long     eye_catcher
    .long     demo_game
    .long     title_display

startup_init:
* we're not doing things the NeoGeo way
    jmp       BIOSF_SYSTEM_RETURN

eye_catcher:
* we're not doing things the NeoGeo way
    jmp       BIOSF_SYSTEM_RETURN

demo_game:
    move    #0x2700,sr            | disable interrupts
    lea     0x10F300,sp
    move.b  #2,BIOS_USER_MODE     | tell BIOS we're running the game
    bsr.b   platform_init         | neo geo-specific init
    jmp     xevious_reset         | pass control to the xevious core

title_display:
* we're not doing things the NeoGeo way
    move.b  BIOS_SELECT_TIMER,d0
    jmp     BIOSF_SYSTEM_RETURN

_player_start:
* we're not doing things the NeoGeo way
    rts
        
_demo_end:
* we're not doing things the NeoGeo way
    rts
        
_coin_sound:
* we're not doing things the NeoGeo way
    rts
        
_vblank:
    btst    #7,BIOS_SYSTEM_MODE
    bne.b   .gamemode
    jmp     BIOSF_SYSTEM_INT1
.gamemode:
    movem.l d0-d7/a0-a6,-(a7)
    KICK_WDOG
    jsr     xevious_im1_irq
    jsr     BIOSF_SYSTEM_IO
.nothing:
    movem.l (a7)+,d0-d7/a0-a6
    move.w  #4,REG_IRQACK
    rte

osd_kick_wdog:
    KICK_WDOG
    rts

    .equ    SPRITEX_0,              8
    .equ    SPRITEY_0,              (0x1F0)
                                    
    .equ    SCB3_STICKY,            (1<<6)

* NEO GEO FIX LAYER tile allocations
    
    .equ    FG_FIX_BASE,            0x0400
    .equ    FG_ASCII_TRANS_BASE,    0x0500
    .equ    FG_ASCII_OPAQUE_BASE,   0x0600
    
* NEO GEO sprite allocations
* -   0- 31 (unused)
* -  32- 95 (64) background tilemap
* -  96-223 (128) Xevious sprites (2/Xevious sprite)
* - 224-263 (36+4) foreground tilemap
* - 264-265 (2) visible display masking sprites

    .equ    BGSS,                   32
    .equ    XSSS,                   96
    .equ    FGSS,                   224
    .equ    DMSS,                   264
                                    
    .equ    BGNS,                   64
    .equ    XSNS,                   128
    .equ    FGNS,                   36+4
    .equ    DMNS,                   2

    .equ    FG_TILE_BASE,           0x0200
    .equ    BG_TILE_BASE,           0x0600
    .equ    XS_TILE_BASE,           0x0A00
    
    * fg and bg tiles share the first 128 palettes
    * - fg uses colours 0-1 in each palette
    * - bg uses colours 8-11 in each palette
    .equ    FG_PAL_BASE,            0
    .equ    BG_PAL_BASE,            0
    * sprites use the second 128 palettes
    .equ    XS_PAL_BASE,            128           
    
platform_init:

    KICK_WDOG
*   acknowlede interrupts
    move.w    #7,REG_IRQACK

* clear fix layer (not used)
    jsr       BIOSF_FIX_CLEAR
    jsr       BIOSF_LSP_1ST

* setup palette(s)
    clr.b     REG_PALBANK0
    lea       _xevious_tile_palette.l,a0
    lea       PALETTES,a1                       | start at palette #0
    move.w    #128-1,d7                         | 128 palettes
1:  moveq     #16-1,d6                          | 16 colours/palette
    KICK_WDOG
2:  move.w    (a0)+,(a1)+
    dbf       d6,2b
    dbf       d7,1b
    lea       _xevious_sprite_palette.l,a0
    move.w    #128-1,d7                         | 128 palettes
3:  moveq     #16-1,d6                          | 16 colours/palette
    KICK_WDOG
4:  move.w    (a0)+,(a1)+
    dbf       d6,4b
    dbf       d7,3b
    move.w    #0x0000,(BACKDROPCOLOR)
    
* setup tilemaps and sprites

    lea       VRAM_RW.l,a0
    move.w    #1,2(a0)                          | VRAM_MOD=1

* clear all sprite tiles & attributes
    move.w    #SCB1,-2(a0)                      | VRAM_ADDR=SCB1
    moveq     #0,d7
    move.w    #448*32-1,d7                      | 448 sprites
1:  move.w    #0,(a0)                           | clear tile
    move.w    #0,(a0)                           | clear palette, attributes
    dbf       d7,1b   
* set all zoom to 1
    move.w    #SCB2,-2(a0)                      | VRAM_ADDR=SCB2
    move.w    #448-1,d7                         | 448 sprites
2:  move.w    #0xFFF,(a0)                       | clear zoom
    dbf       d7,2b   
* set all size to 0 (make inactive)
    move.w    #SCB3,-2(a0)                      | VRAM_ADDR=SCB3
    move.w    #448-1,d7                         | 448 sprites
2:  move.w    #0x0000,(a0)                      | clear size
    dbf       d7,2b   

.ifeq OPT_DISABLE_BG_LAYER

* background tilemap

*   - shrinking coefficients
    move.w    #(SCB2+BGSS),-2(a0)               | VRAM_ADDR=SCB2
    moveq     #BGNS-1,d7
2:  move.w    #0x077F,(a0)                      | 50% H&V (8x8)
    dbf       d7,2b

*   - vertical position, sticky, size=0 (inactive)           
    move.w    #(SCB3+BGSS),-2(a0)               | VRAM_ADDR=SCB3
    move.w    #SPRITEY_0<<7,d0                  | YPOS=0
    *ori.w      #33,d0                            | SIZE=33
    move.w    d0,(a0)                           | 1st sprite not sticky
    ori.w     #SCB3_STICKY,d0                   | set sticky bit
    moveq     #BGNS-2,d7                        | 
3:  move.w    d0,(a0)                           | SCB3 data
    dbf       d7,3b
    
*   - horizontal position
    move.w    #(SCB4+BGSS),-2(a0)               | VRAM_ADDR=SCB4
    moveq     #BGNS-1,d7
    move.w    #SPRITEX_0<<7,d0
5:  move.w    d0,(a0)                           | XPOS=0
    addq.w    #8,d0
    *dbf        d7,5b

  * show a tile on each BG sprite so we can see it
  .if 0
    lea       (SCB1+BGSS*64),a1
    moveq     #BGNS-1,d7
0:  move.w    a1,-2(a0)
    move.w    #63,d6
    sub.w     d7,d6
    ori.w     #FG_TILE_BASE,d6
    move.w    d6,(a0)
    move.w    #0x0100,(a0)
    lea       (64,a1),a1
    dbf       d7,0b
  .endif

.endif | OPT_DISABLE_BG_LAYER

.ifeq OPT_DISABLE_FG_LAYER

* foreground tilemap

*   - shrinking coefficients
    move.w    #(SCB2+FGSS),-2(a0)               | VRAM_ADDR=SCB2
    moveq     #FGNS-1,d7
2:  move.w    #0x077F,(a0)                      | 50% H&V (8x8)
    dbf       d7,2b

*   - vertical position, sticky, size           
    move.w    #(SCB3+FGSS),-2(a0)               | VRAM_ADDR=SCB3
    move.w    #(SPRITEY_0-2)<<7,d0              | YPOS=0
    ori.w     #33,d0                            | SIZE=33
    moveq     #FGNS-4-1,d7
3:  move.w    d0,(a0)                           | visible
    dbf       d7,3b   
    andi.w    #~33,d0                           | SIZE=0
    * deactivate top 4 sprites to min sprites/line
    moveq     #4-1,d7                           | top 4 sprites not visible
4:  move.w    d0,(a0)                           | SCB3 data
    dbf       d7,4b
    
*   - horizontal position
    move.w    #(SCB4+FGSS),-2(a0)               | VRAM_ADDR=SCB4
    moveq     #FGNS-1,d7
    move.w    #(SPRITEX_0+8)<<7,d0              | XPOS=0
5:  move.w    d0,(a0)             
    add.w     #(8<<7),d0                        | next XPOS
    dbf       d7,5b

.endif | OPT_DISABLE_FG_LAYER

.ifeq OPT_DISABLE_DISPLAY_MASKS

*
* display masking sprites
*

* - tiles and palettes
    move.w    #(SCB1+DMSS)*64,-2(a0)            | VRAM_ADDR=SCB1
    moveq     #DMNS-1,d6                        | 2 sprites
1:  moveq     #32-1,d7
    move.w    #BG_TILE_BASE,d0                  | tile code from BG
2:  move.w    d0,(a0)                           | TILE
    addq.w    #1,d0                             | this is for debugging
* change the palette for debugging these sprites
    move.w    #(128+3)<<8,(a0)                  | PALETTE (black on black)
    dbf       d7,2b
    dbf       d6,1b
    
*   - shrinking coefficients
    move.w    #(SCB2+DMSS),-2(a0)               | VRAM_ADDR=SCB2
    moveq     #0,d7
    moveq     #DMNS-1,d7                        | 2 sprites
2:  move.w    #0x077F,(a0)                      | 50% H&V (8x8)
    dbf       d7,2b

*   - vertical position, sticky, size           
    move.w    #(SCB3+DMSS),-2(a0)               | VRAM_ADDR=SCB3
    move.w    #SPRITEY_0<<7,d0                  | YPOS=0
    ori.w     #33,d0                            | SIZE
    moveq     #DMNS-1,d7                         | 2 sprites
3:  move.w    d0,(a0)                           | SCB3 data
    dbf       d7,3b

*   - horizontal position
    move.w    #(SCB4+DMSS),-2(a0)               | VRAM_ADDR=SCB4
    move.w    #SPRITEX_0<<7,d0                  | X POSITION (bottom)
    move.w    d0,(a0)
    move.w    #(SPRITEX_0+37*8)<<7,d0           | X POSITION (top)
    move.w    d0,(a0)

.endif | OPT_DISABLE_DISPLAY_MASKS

    * generate lookup table for fg offset
    lea       fg_offset_lookup_tbl,a0
    moveq     #0,d7
4:  move.w    d7,d3
    and.w     #0x3f,d3                          | row (sprite number indirectly)
    move.w    #35+4,d2                          | first 4 rows not visible
    sub.w     d3,d2                             | sprite #
    lsl.w     #6,d2                             | d2=sprite offset in SCB1
    move.w    d7,d3
    lsr.w     #6,d3                             | sprite tile #
    not.w     d3                                | reverse column
    subq.w    #2,d3                             | adjust for visible display
    and.w     #0x1f,d3                          | column (tile number)
    lsl.w     #1,d3                             | d3=tile offset in SCB1
    add.w      d2,d3                            | combine for SCB1 address
    add.w     #SCB1+(FGSS*64),d3
    move.w    d3,(a0)+                          | store entry
    addq.w    #1,d7
    cmp.w     #0x0800,d7
    blt       4b
    
    * generate lookup table for bg offset
    lea       bg_offset_lookup_tbl,a0
    moveq     #0,d7
5:  move.w    d7,d3
    and.w     #0x3f,d3                          | 63-sprite number
    move.w    #63,d2                            |
    sub.w     d3,d2                             | sprite #
    lsl.w     #6,d2                             | sprite offset in SCB1
    move.w    d7,d3
    lsr.w     #6,d3                             | sprite tile #
    not.w     d3                                | reverse column
    subq.w    #2,d3                             | adjust for visible display
    and.w     #0x1f,d3                          | column (tile number)
    lsl.w     #1,d3                             | tile offset in SCB1
    add.w     d2,d3
    add.w     #SCB1+(BGSS*64),d3
    move.w    d3,(a0)+
    addq.w    #1,d7
    cmp.w     #0x0800,d7
    blt       5b

    * generate lookup table for osd_w_fg_colorram
    lea       fg_colorram_lookup_tbl,a0
    moveq     #0,d7
6:  move.w    d7,d0                             | working copy
    and.b     #0x03,d0                          | 1|0
    ror.w     #4,d0                             | X|X|1|0|X|X|X|X (MSB)
    move.w    d7,d1                             | working copy
    and.b     #0x3c,d1                          | 5|4|3|2
    lsl.w     #6,d1                             | X|X|X|X|5|4|3|2 (MSB)
    or.w      d1,d0                             | X|X|1|0|5|4|3|2 (MSB)
    move.w    d7,d1                             | working copy
    lsr.b     #6,d1                             | X|X|X|X|X|X|7|6 (LSB)
    or.w      d1,d0                             | combine MSB,LSB
    move.w    d0,(a0)+
    addq.b    #1,d7
    bne       6b
    
    * generate lookup-table for osd_w_bg_colorram
    lea       bg_colorram_lookup_tbl,a0
    moveq     #0,d7
7:  move.w    d7,d0                             | working copy
    and.w     #0x03,d0                          | 1|0
    ror.w     #3,d0                             | into place
    move.w    d7,d1                             | working copy
    and.w     #0x3c,d1                          | 5|4|3|2
    lsl.w     #6,d1                             | into place
    or.w      d1,d0                             | X|1|0|X|5|4|3|2 (MSB)
    move.w    d7,d1                             | working copy
    and.w     #0xC0,d1                          | 7|6
    rol.b     #2,d1                             | into place
    or.w      d1,d0                             | X|1|0|X|5|4|3|2|..|7|6
    move.w    d7,d1                             | working copy
    and.w     #0x0100,d1                        | 8
    lsl.w     #4,d1                             | into place
    or.w      d1,d0                             | X|1|0|8|5|4|3|2|..|7|6
    move.w    d0,(a0)+
    addq.w    #1,d7
    cmp.w     #512,d7
    blt       7b

    lea       snd_playing,a0
    moveq     #0x20-1,d7
8:  clr.b     (a0)+
    dbf       d7,8b
    
* CD hardware only
.ifdef __cd__
    move.b    #0,(REG_DISBLSPR)                 | enable sprites
    move.b    #1,(REG_ENVIDEO)                  | enable video
.endif

.ifeq OPT_SKIP_SPLASH
    clr.b     REG_PALBANK1                      | alt palette bank
    lea       PALETTES,a0
    * palette 0 - transparent/high score colour/black
    move.w    #0x8000,(0,a0)
    move.w    (_xevious_tile_palette+0x1f*32+2),d0
    move.w    d0,(2,a0)
    move.w    #BLACK,(4,a0)
    * palette 1 - transparent/black/white
    lea       (32,a0),a0
    move.w    #0,(0,a0)
    move.w    #BLACK,(2,a0)
    move.w    #WHITE,(4,a0)
    * palette 2 - transparent/solvalou symbol colour/black
    lea       (32,a0),a0
    move.w    #0,(0,a0)
    move.w    (_xevious_tile_palette+0x2a*32+2),d0
    move.w    d0,(2,a0)
    move.w    #BLACK,(4,a0)
    ** show splash screen on fix layer
    lea       VRAM_RW.l,a0
    move.w    #1,(2,a0)                         | VRAM_MOD=1
    lea       splash,a1
    move.w    #FIXMAP+(38*32),d1
    lea       splash_attr,a2
1:  move.w    d1,(-2,a0)                        | VRAM_ADDR
    move.w    #FG_ASCII_OPAQUE_BASE,d0          | tile base
    or.w      (a2)+,d0                          | line attribute
    moveq     #32-1,d6                          | 32 chars per line
    
2:  move.b    (a1)+,d0
    move.w    d0,(a0)                           | VRAM
    dbf       d6,2b                             | do line
    sub.w     #32,d1                            | next line VRAM address
    tst.b     (a1)                              | last line?
    bne.b     1b                                | no, loop
    *
3:  KICK_WDOG
    jsr       BIOSF_SYSTEM_IO                   | update inputs etc
    move.b    BIOS_P1CURRENT,d0                 | read IN1
    and.b     #0xf0,d0                          | any buttons pressed?
    beq.b     3b                                | no, loop
    jsr       BIOSF_FIX_CLEAR
    clr.b     REG_PALBANK0                      | main palette bank
.endif | OPT_SKIP_SPLASH

    * some working variables
    move.w    #0,(btm_sprite)
    move.w    #0,(bg_scroll_x_r)
    
5:  KICK_WDOG
    rts

splash:
    *         "  [--------------------------]  "
    .ascii    "                                "
    .ascii    "            XEVIOUS     Beta1   "
    .ascii    "                                "
    .ascii    "            NGH 420             "
    .ascii    "                                "
    .ascii    "  This is a 68K transcode of    "
    .ascii    "  the arcade game Xevious       "
    .ascii    "  released by Namco in 1983.    "
    .ascii    "                                "
    .ascii    "  The core is a line-by-line    "
    .ascii    "  translation of the Z80        "
    .ascii    "  assembler code in the MAIN    "
    .ascii    "  and SUB CPU ROMs. Every       "
    .ascii    "  nuance and every bug is       "
    .ascii    "  faithfully replicated in      "
    .ascii    "  the transcode. The graphics   "
    .ascii    "  and palette have been         "
    .ascii    "  ripped as-is from the         "
    .ascii    "  arcade ROMs for use in this   "
    .ascii    "  version.                      "
    .ascii    "                                "
    .ascii    "  The core itself is platform   "
    .ascii    "  agnostic and can be ported    "
    .ascii    "  to other 68K systems with a   "
    .ascii    "  well defined API.             "
    .ascii    "                                "
    .ascii    "  The Neo Geo version supports  "
    .ascii    "  high score load & save on     "
    .ascii    "  both BRAM and memory card.    "
    .ascii    "                                "
    .ascii    "  Arcade dipswitches are        "
    .ascii    "  supported via the soft DIP    "
    .ascii    "  settings.                     "
    .ascii    "                                "
    .ascii    "  NGFX Soundbuilder by Blastar  "
    .ascii    "                                "
    .ascii    "     Copyright 2023 tcdev       "
    .ascii    "    retroports.blogspot.com     "
    .byte     0
    .align 2

splash_attr:
    .word     0x0000, 0x0000, 0x0000, 0x0000
    .word     0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000
    .word     0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000
    .word     0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000
    .word     0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000
    .word     0x2000, 0x2000
            
* 60Hz VBLANK interrupt
osd_enable_vblank_interrupt:
    move      #0x2000,sr                        | enable interrupts
    rts

osd_ack_vblank_interrupt:
    move.w    #4,REG_IRQACK                     
    rts
    
osd_disable_vblank_interrupt:
    move      #0x2400,sr                        | enable interrupts
    rts
    
* d0=offset (preserved), d1=attribute (preserved)
osd_w_fg_colorram:
    .ifeq OPT_DISABLE_FG_LAYER
    movem.l   d0-d3/a0/a1,-(a7)
    lea       fg_colorram,a0
    move.b    d1,(d0.w,a0)                      | save to fg_colorram
    move.w    d0,d3                             | copy offset
    and.w     #0x3f,d3                          | row (sprite number indirectly)
    cmp.w     #FGNS,d3                          | visible?
    bge       9f                                | no, skip
    * use lookup for SBC1 offset
    lea       fg_offset_lookup_tbl,a0
    lsl.w     #1,d0
    move.w    (a0,d0.w),a1
    lea       (1,a1),a1
    * use lookup table for attribute
    lsl.w     #1,d1                             | x2 for entry offset
    lea       fg_colorram_lookup_tbl,a0
    move.w    (a0,d1.w),d1
    * update tilemap attributes
    move      #0x2400,sr                        | disable vblank
    lea       VRAM_RW.l,a0
    move.w    a1,(-2,a0)                        | VRAM_ADDR=SCB1
    move.w    d1,(a0)                           | set attribute
    move      #0x2000,sr                        | enable interrupts
9:  movem.l   (a7)+,d0-d3/a0/a1
    .endif | OPT_DISABLE_FG_LAYER
    rts

* d0=offset (preserved), d1=attribute (preserved)
osd_w_bg_colorram:
    .ifeq OPT_DISABLE_BG_LAYER
    movem.l   d0-d3/a0/a1,-(a7)
    lea       bg_colorram,a0
    move.b    d1,(a0,d0.w)                      | save attr to bg_colorram
    move.w    d1,d2
    lea       bg_videoram,a0
    move.b    (a0,d0.w),d1                      | get code
    .endif | OPT_DISABLE_BG_LAYER
    bra.s     w_bg_ram
    
* d0=offset (preserved), d1=tile (preserved)
osd_w_fg_videoram:
    .ifeq OPT_DISABLE_FG_LAYER
    movem.l   d0-d3/a0/a1,-(a7)
    lea       fg_videoram,a0
    move.b    d1,(d0.w,a0)                      | save to fg_videoram
    move.w    d0,d3                             | copy offset
    and.w     #0x3f,d3                          | row (sprite # indirectly)
    cmp.w     #FGNS,d3                          | visible?
    bge.b     9f                                | no, skip
    * use lookup for SBC1 offset
    lea       fg_offset_lookup_tbl,a0
    lsl.w     #1,d0
    move.w    (a0,d0.w),a1
    ori.w     #FG_TILE_BASE,d1                  | map to NG tile
    * update tilemap
    move      #0x2400,sr                        | disable vblank
    lea       VRAM_RW.l,a0
    move.w    a1,(-2,a0)                        | VRAM_ADDR=SCB1
    move.w    d1,(a0)                           | set tile
    move      #0x2000,sr                        | enable interrupts
9:  movem.l   (a7)+,d0-d3/a0/a1
    .endif | OPT_DISABLE_FG_LAYER
    rts

* d0=offset (preserved), d1=tile (preserved)
osd_w_bg_videoram:
    .ifeq OPT_DISABLE_BG_LAYER
    movem.l   d0-d3/a0/a1,-(a7)
    lea       bg_videoram,a0
    move.b    d1,(a0,d0.w)                      | save code to bg_videoram
    lea       bg_colorram,a0
    move.b    (a0,d0.w),d2                      | get attr
    .endif | OPT_DISABLE_BG_LAYER
    * fall thru
    
* d0 = offset, d1=tile, d2=attr
w_bg_ram:
    .ifeq OPT_DISABLE_BG_LAYER
    lea       bg_offset_lookup_tbl,a0
    lsl.w     #1,d0
    move.w    (a0,d0.w),a1
    move      #0x2400,sr                        | disable vblank
    lea       VRAM_RW.l,a0
    move.w    #1,(2,a0)                         | VRAM_MOD=1
    move.w    a1,(-2,a0)                        | VRAM_ADDR=SCB1
    * calculate tile
    andi.w    #0x00ff,d1
    btst.b    #0,d2                             | attr bit0?
    beq.s     1f
    ori.w     #0x0100,d1                        | bank
1:  ori.w     #BG_TILE_BASE,d1
    move.w    d1,(a0)
    * calculate attribute
    and.w     #0x00ff,d2
    and.w     #0x0080,d1                        | code&0x80
    beq.s     2f
    or.w      #(1<<8),d2                        | code&0x80|7|6|$3C|$03
2:  lsl.w     #1,d2                             | x2 for table offset
    lea       bg_colorram_lookup_tbl,a1
    move.w    (a1,d2.w),(a0)                    | get/set entry
    move      #0x2000,sr                        | enable interrupts
9:  movem.l   (a7)+,d0-d3/a0/a1
    .endif | OPT_DISABLE_BG_LAYER
    rts

    .equ      BGOFF, -4

* we require 38 visible (active) sprites
* d6 = bg_scroll_x_shadow
osd_update_scroll_hw:
    .ifeq OPT_DISABLE_BG_LAYER
    movem.l   d0-d2/a0-a2,-(a7)
    * on title screens it's the same
    cmp.w     (bg_scroll_x_r),d6                | same?
    beq       9f                                | yes, do nothing
    * check if scrolled by 1 pixel or not
    lea       VRAM_RW.l,a0
    move.w    #1,(2,a0)                         | VRAM_MOD=1
    move.w    d6,d1                             | copy of scroll register
    addq.w    #1,d1                             | scroll+1
    and.w     #0x01ff,d1                        | handle wrap
    cmp.w     (bg_scroll_x_r),d1                | same as last?
    bne.w     arbitrary_scroll                  | no, recalculate entire screen
    * has scrolled down by 1 pixel row
    move.w    d6,(bg_scroll_x_r)
    and.w     #7,d6                             | bit offset
    cmp.b     #7,d6                             | time for a new row?
    beq.b     row_scroll                        | yes, go
    
    * only need to reposition existing btm_sprite
    * and sprite BGSS if it's visible
    * - btm_sprite    
    lea       (SCB4+BGSS),a1
    move.w    (btm_sprite),d0
    lea       (a1,d0.w),a2
    move.w    a2,(-2,a0)                        | VRAM_ADDR=SCB4
    add.w     #(SPRITEX_0+BGOFF),d6             | add screen offset
    lsl.w     #7,d6                             | shift for Neo Geo
    move.w    d6,(a0)                           | set register
    * - sprite BGSS if required
    cmp.w     #64-37,d0                         | visible?
    blt       9f                                | no, done
    move.w    a1,(-2,a0)                        | VRAM_ADDR=SCB4
    move.w    #64,d1
    sub.w     d0,d1
    ror.w     #6,d1                             | lsl 3, lsl 7
    add.w     d1,d6                             | add to base
    move.w    d6,(a0)    
    bra 9f
    
row_scroll:
    * inactivate btm_sprite, update btm_sprite
    lea       (SCB3+BGSS),a1
    move.w    (btm_sprite),d0
    lea       (a1,d0.w),a2
    move.w    a2,(-2,a0)                        | VRAM_ADDR=SCB3
    clr.w     (a0)                              | inactivate
    addq.w    #1,d0                             | calc btm_sprite
    and.w     #0x3f,d0                          | handle wrap
    move.w    d0,(btm_sprite)
    * unsticky, set btm_sprite position
    lea       (a1,d0.w),a2
    move.w    a2,(-2,a0)                        | VRAM_ADDR=SCB3
    move.w    #(SPRITEY_0<<7)+33,d1             | unsticky
    move.w    d1,(a0)
    lea       (SCB4+BGSS),a1
    lea       (a1,d0.w),a2
    move.w    a2,(-2,a0)                        | VRAM_ADDR=SCB4
    move.w    #(SPRITEX_0+BGOFF+7)<<7,d1
    move.w    d1,(a0)
    * update sprite BGSS if visible    
    cmp.w     #64-37,d0                         | visible?
    blt.b     1f                                | no, skip
    move.w    a1,(-2,a0)                        | VRAM_ADDR=SCB4
    move.w    #64,d1
    sub.w     d0,d1
    ror.w     #6,d1                             | lsl 3, lsl 7
    add.w     #(SPRITEX_0+BGOFF+7)<<7,d1        | add to base
    move.w    d1,(a0)    
    * activate top sprite (chained unless sprite BGSS)
1:  add.w     #37,d0                            | calc top sprite
    and.w     #0x3f,d0                          | handle wrap
    lea       (SCB3+BGSS),a1
    lea       (a1,d0.w),a2
    move.w    a2,(-2,a0)                        | VRAM_ADDR=SCB4
    move.w    #(SPRITEY_0<<7)+33,d1             | always set ypos,size
    tst.w     d0
    beq.b     2f                                | no sticky for sprite BGSS
    ori.w     #SCB3_STICKY,d1
2:  move.w    d1,(a0)
    bra       9f

arbitrary_scroll:
osd_debug1:    
    move.w    d6,(bg_scroll_x_r)
    * deactivate all active sprites
    lea       SCB3+BGSS,a1
    move.w    (btm_sprite),d0
    lea       (a1,d0.w),a2                      | offset for btm_sprite
    move.w    a2,(-2,a0)                        | VRAM_ADDR=SCB3(btm_sprite)
    move.w    #38-1,d7                          | 38 sprites to deactivate
3:  clr.w     (a0)                              | unsticky,size=0
    addq.w    #1,d0                             | next sprite
    cmp.w     #0x3f,d0                          | sprite=BGSS+63?
    ble.b     4f                                | no, skip
    moveq     #0,d0                             | sprite=BGSS
    move.w    a1,(-2,a0)                        | VRAM_ADDR=SCB3(BGSS)
4:  dbf       d7,3b
    * calculate new bottom sprite
    move.w    d6,d1                             | copy
    lsr.w     #3,d1                             | byte offset
    move.w    #24,d0
    sub.w     d1,d0                             | new btm_sprite
    and.w     #0x3f,d0                          | fix wrap
    move.w    d0,(btm_sprite)
    move.w    d0,d2                             | copy
    * activate visible sprites
    lea       (a1,d0.w),a2                      | offset for btm_sprite
    move.w    a2,(-2,a0)                        | VRAM_ADDR=SCB3(btm_sprite)
    moveq     #38-1,d7                          | 38 sprites to activate
    move.w    #(SPRITEY_0<<7)+33,d1             | bottom sprite not sticky
5:  move.w    d1,(a0)                           | ypos,sticky,size
    ori.w     #SCB3_STICKY,d1                   | default sticky
    addq.w    #1,d0                             | next sprite
    cmp.w     #0x3f,d0
    ble.b     6f
    moveq     #0,d0                             | handle wrap
    move.w    a1,(-2,a0)                        | VRAM_ADDR=SCB3(BGSS)
    and.w     #~SCB3_STICKY,d1                  | never sticky
6:  dbf       d7,5b
    * position btm sprite and sprite BGSS
    * - btm_sprite
    lea       SCB4+BGSS,a1
    lea       (a1,d2.w),a2                      | addr for btm_sprite
    move.w    a2,(-2,a0)                        | VRAM_ADDR=SCB3(btm_sprite)
    move.w    #(SPRITEX_0+BGOFF),d1
    and.w     #7,d6                             | scroll pixel offset
    add.w     d6,d1
    lsl.w     #7,d1
    move.w    d1,(a0)                           | X POSITION
    * - sprite BGSS (if visible)
    cmp.w     #64-37,d2                         | visible?
    blt.b     9f                                | no, skip
    move.w    a1,(-2,a0)                        | VRAM_ADDR=SCB3(BGSS)
    move.w    #64,d1
    sub.w     d2,d1
    lsl.w     #3,d1                             | x8 (row offset)
    add.w     d1,d6                             | add pixel offset
    add.w     #(SPRITEX_0+BGOFF),d1             | add to base
    lsl.w     #7,d1                             | lsl 7
    move.w    d1,(a0)    

9:  movem.l   (a7)+,d0-d2/a0-a2
    .endif | OPT_DISABLE_BG_LAYER
    rts

* a5=obj_tbl
osd_update_sprite_shadow:
    lea       scb1_shadow,a1
    lea       sprite_shadow_msb,a2
    lea       scb3_shadow,a3
    lea       scb4_shadow,a4
    moveq     #64-1,d7
1:  jsr       update_sprite_shadow
    lea       (_OBJSIZE,a5),a5
    dbf       d7,1b
    rts

update_sprite_shadow: | $0332
    move.b    (_STATE,a5),d0                    | state
    subq.b    #1,d0                             | =1 (inactive)?
    beq.b     0f                                | yes, skip
    addq.b    #1,d0                             | restore state
    bne.b     1f                                | NZ (not going inactive)? no, continue
    * deactivate
    clr.w     (_X,a5)                           | spriteX=0
    clr.w     (_Y,a5)                           | spriteY=0
    move.b    #1,(_STATE,a5)                    | state=1 (inactive)
    clr.w     (0,a3)                            | sprite0 size=0 (deactivate)
    clr.w     (2,a3)                            | sprite1 size=0 (deactivate)
0:  lea       (2*4*2,a1),a1
    lea       (2,a2),a2
    lea       (2*2,a3),a3
    lea       (2*2,a4),a4
    rts

    ** SCB1
1:  moveq     #0,d5
    move.b    (_ATTR,a5),d5                     | bank,xflip,yflip,size
    move.w    d5,d0                             | save
    and.w     #(1<<7),d0                        | bank only
    lsl.w     #1,d0                             | :8=bank
    move.b    (_CODE,a5),d0                     | 7:0=code
    ori.w     #XS_TILE_BASE,d0                  | d0.w=code
    moveq     #0,d1           
    move.b    (_COLOUR,a5),d1                   | colour
    ori.w     #XS_PAL_BASE,d1
    lsl.w     #8,d1                             | 15:8=colour
    move.b    d5,d1                             | 7:0=ATTR
    and.b     #0x0c,d1                          | yflip,xflip only
    lsr.b     #2,d1                             | d1.w=colour
    move.b    d1,d4                             | d4.b[1:0]=yflip,xflip
    * handle sizes now...
    move.w    d5,d2                             | ATTR
    and.w     #3,d2                             | size only
    not.w     d2
    and.w     d2,d0                             | adjust code
    btst.b    #0,d5
    bne.b     2f                                | size=0x01/0x03
    btst.b    #1,d5
    bne.b     3f                                | size=0x02
    * size=0x00 (1x1)
    move.w    d0,(0,a1)                         | SCB1 code (sprite0,tile0)
    bra.b     1f    
2:  btst.b    #1,d5
    bne.b     4f                                | size=0x03
    * size=0x01 (2x1) - not used?
    bra.b     0f    
3:  * size=0x02 (1x2)
    * only used for Bacura, and never Y-flipped
    move.w    d0,(4,a1)                         | SCB1 code (sprite0,tile1)
    addq.w    #2,d0                             | code+2
    move.w    d0,(0,a1)                         | SCB1 code (sprite0,tile0)
    bra.b     2f    
4:  * size=0x03 (2x2)
    * can be X/Y flipped
    eor.b     d4,d0                             | adjust starting code for flip
    move.w    d0,(12,a1)                        | SCB1 code (sprite1,tile1)
    eor.b     #1,d0
    move.w    d0,(4,a1)                         | SCB1 code (sprite0,tile1)
    eor.b     #3,d0
    move.w    d0,(8,a1)                         | SCB1 code (sprite1,tile0)
    eor.b     #1,d0
    move.w    d0,(0,a1)                         | SCB1 code (sprite0,tile0)
0:  move.w    d1,(14,a1)                        | SCB1 colour (sprite1,tile1)
    move.w    d1,(10,a1)                        | SCB1 colour (sprite1,tile0)
2:  move.w    d1,(6,a1)                         | SCB1 colour (sprite0,tile1)
1:  move.w    d1,(2,a1)                         | SCB1 colour (sprite0,tile0)
    adda.l    #2*8,a1
    ** SCB3
    move.w    (_Y,a5),d0                        | spriteY
    lsr.w     #5,d0                             | back to original
    *** THIS IS MANDATORY IN EVERY PORT
    move.b    #0xef,d1                          | arcade adjustment
    sub.b     d0,d1                             | arcade adjustment
    move.b    d1,(a2)+                          | store Y[7:0] for hit-box calcs
    *** END OF MANDATORY
    btst      #8,d0
    beq.b     3f
    and.w     #0xff00,d0                        | max=256
3:  add.w     #0x110,d0                         | Neo Geo coordinate mapping
    lsl.w     #7,d0
    ori.w     #1,d0                             | size=1 (default)
    btst.b    #1,d5                             | double height?
    beq.b     4f                                | no, skip
    addq.w    #1,d0                             | size=2
4:  move.w    d0,(a3)+                          | SCB3 YPOS
    move.b    d5,d0                             | ATTR
    and.w     #1,d0                             | double width only
    ror.b     #2,d0                             | move to sticky bit (size=0)
    move.w    d0,(a3)+
    ** SCB4
    move.w    (_X,a5),d0                        | spriteX
    lsr.w     #5,d0                             | back to original
    move.w    d0,d1
    *** THIS IS MANDATORY IN EVERY PORT
    addq.b    #8,d1    
    lsr.w     #1,d1
    move.b    d1,(a2)+                          | store X[8:1] for hit-box calcs
    *** END OF MANDATORY
    cmp.w     #0x0200,d0                        | too big?
    bcs.b     5f
    clr.w     d0
5:  move.w    #319,d1
    sub.w     d0,d1                             | Neo Geo coordinate mapping
    btst.b    #0,d5                             | double width?
    beq.b     6f                                | no, skip
    sub.w     #16,d1                            | adjust
6:  lsl.w     #7,d1
    move.w    d1,(a4)                           | SCB4 XPOS
    * no need to write SCB4 for the chained sprite
    adda.w    #4,a4
9:  rts
        
* d0 = base sprite number (0/32)
osd_update_32_sprite_hw:
.if 0
    move.w    (irq_cnt),d1
    addq.w    #1,d1
    and.w     #0x0f,d1
    move.w    d1,(irq_cnt)
    bne       9f
.endif    
    .ifeq OPT_DISABLE_SPRITES
    lea       VRAM_RW.l,a0
    move.w    #1,(2,a0)                         | VRAM_MOD=1
    lsl.w     #1,d0                             | 2x Neo Geo sprites
    move.w    d0,d6                             | save base sprite (0/64)
    * SCB1 (code,colour,flip)
    lsl.w     #3,d6                             | 2 tiles (8 bytes)/entry
    lea       scb1_shadow,a1
    lea       (a1,d6.w),a1
    lsl.w     #3,d6                             | 64 words/entry
    lea       SCB1+(XSSS*64),a4
    move.w    #64-1,d7
1:  lea       (a4,d6.w),a2
    move.w    a2,(-2,a0)                        | VRAM_ADDR=SCB1
    move.w    (a1)+,(a0)                        | SCB1 TILE
    move.w    (a1)+,(a0)                        | SCB1 PALETTTE,FLIP
    move.w    (a1)+,(a0)                        | SCB1 TILE
    move.w    (a1)+,(a0)                        | SCB1 PALETTTE,FLIP
    add.w     #64,d6                            | next sprite VRAM offset
    dbf       d7,1b
    * SCB3 (ypos,size)
    move.w    d0,d6
    lea       SCB3+XSSS,a4
    lea       (a4,d6.w),a4
    move.w    a4,(-2,a0)                        | VRAM_ADDR=SCB3
    lsl.w     #1,d6                             | 2 bytes/entry
    lea       scb3_shadow,a1
    lea       (a1,d6.w),a1
    moveq     #64-1,d7
3:  move.w    (a1)+,(a0)                        | SCB3 YPOS,SIZE
    dbf       d7,3b
    * SCB4 (xpos)
    move.w    d0,d6
    lea       SCB4+XSSS,a4
    lea       (a4,d6.w),a4
    move.w    a4,(-2,a0)                        | VRAM_ADDR=SCB4
    lsl.w     #1,d6                             | 2 bytes/entry
    lea       scb4_shadow,a1
    lea       (a1,d6.w),a1
    moveq     #64-1,d7
4:  move.w    (a1)+,(a0)                        | SCB4 XPOS
    dbf       d7,4b
    .endif | OPT_DISABLE_SPRITES
    rts
    
* d0=DSWA, d1=DSWB
osd_read_dipswitches:
    lea       BIOS_GAME_DIP,a0
    *** DSWA
    * coinage 2,1 (1,0)
    move.b    6(a0),d0                          | bonus life
    lsl.b     #2,d0                             | SW=5,4,3 (bit=4,3,2)
    move.b    7(a0),d2                          | lives
    lsl.b     #5,d2                             | SW=7,6 (bit=6,5)
    or.b      d2,d0
    *** DSWB
    move.b    8(a0),d1                          | flag awards bonus life
    lsl.b     #1,d1                             | SW=2 (bit=1)
    move.b    9(a0),d2                          | difficulty
    lsl.b     #5,d2                             | SW=7,6 (bit=6,5)
    or.b      d2,d1
    move.b    BIOS_P2CURRENT,d2                 | read P2 inputs
    and.b     #(1<<5),d2                        | B2 only
    lsr.b     #1,d2                             | 4=B2
    or.b      d2,d1                             | add to DSWB
    move.b    BIOS_P1CURRENT,d2                 | read P1 inputs
    and.b     #(1<<5),d2                        | B2 only
    lsr.b     #5,d2                             | 0=B2
    or.b      d2,d1                             | add to DSWB
    * invert inputs, not dipswitches
    eori.b    #0b10011101,d1
    rts

* - neogeo   5=B2, 4=B1, 3=right, 2=left, 1=down,  0=up

* returns inputs in d0    
osd_read_p1_inputs:
    move.b    BIOS_P1CURRENT,d0                 | read IN1
    move.b    d0,d1                             | copy
    and.w     #0x0f,d0
    movem.l   a0,-(a7)
    movea.l   #input_map_tbl,a0
    move.b    (a0,d0.w),d0                      | d0=joystick
    and.b     #(1<<4),d1                        | B1 only
    lsl.b     #1,d1                             | 5=B1
    eor.b     d1,d0                             | add to joystick
    * looks like bit4 is a one-shot version of bit5
    * - this is the only way to get name input to work
    btst.b    #5,d0                             | B1?
    bne.b     1f                                | no, skip
    btst.b    #5,(p1_input_r)                   | B1 last time?
    beq.b     1f                                | yes, skip
    and.b     #~(1<<4),d0                       | flag B1 (active low)  
1:  move.b    d0,(p1_input_r)                   | save for next time
    movem.l   (a7)+,a0
9:  rts

input_map_tbl:
    .byte     0xf8                              |  0, none
    .byte     0xf0                              |  1, up
    .byte     0xf4                              |  2, down
    .byte     0xf8                              |  3, down+up (invalid)
    .byte     0xf6                              |  4, left
    .byte     0xf7                              |  5, left+up
    .byte     0xf5                              |  6, left+down
    .byte     0xf8                              |  7, left+down+up (invalid)
    .byte     0xf2                              |  8, right
    .byte     0xf1                              |  9, right+up
    .byte     0xf3                              |  A, right+down
    .byte     0xf8                              |  B, right+down+up (invalid)
    .byte     0xf8                              |  C, right+left (invalid)
    .byte     0xf8                              |  D, right+left+up (invalid)
    .byte     0xf8                              |  E, right+left+down (invalid)
    .byte     0xf8                              |  F, right+left+down+up (invalid)
    
osd_read_p2_inputs:
    *move.b    BIOS_P2CURRENT,d0                 | read IN1
    bra       osd_read_p1_inputs
    rts

osd_read_coin:
    tst.b     (BIOS_MVS_FLAG)
    beq       home_use
*   The NEO GEO BIOS handles credits and coins for you
*   so we always use 1C1C here and let DK handle the
*   actual credits itself
    lea       0x10fdb0.l,a0
    move.w    #0x0100,(a0)
    jsr       BIOSF_CREDIT_CHECK
    lea       0x10fdb0.l,a0
    move.w    (a0),d0
    cmpi.w    #0x0100,d0
    beq       1f
    moveq     #0,d0
    bra       9f
1:  jsr       BIOSF_CREDIT_DOWN
    bra       coin_inserted
home_use:   
    * fix me
    move.b    (BIOS_STATCHANGE),d6
    btst.b    #1,d6                             | <SELECT> changed?
    beq       9f                                | no, skip
    move.b    BIOS_STATCURNT,d0                 | read start buttons
    btst.b    #1,d0                             | <SELECT> pressed?
    beq       9f
coin_inserted:    
    moveq     #1,d0
9:  rts
    
osd_read_start:
    move.b    BIOS_STATCURNT,d0                 | bit0=P1, bit2=P2
    move.b    d0,d6
    and.b     #1,d0                             | P1 only
    lsr.b     #1,d6                             | P2->bit1
    and.b     #2,d6                             | P2 only
    or.b      d6,d0                             | bit0=P1, bit1=P2
9:  rts

* d0 = sound ordinal
osd_sound_start:
    lea       snd_playing,a0
    cmp.b     #ORDINAL_1_SND,d0
    beq       9f
    cmp.b     #SOLVALOU_SND,d0
    beq.b     1f
    cmp.b     #HIGH_SCORE_SND,d0
    bgt.b     2f
1:  tst.b     (a0,d0.w)                         | already playing?
    bne.b     9f                                | yes, exit
    move.b    #1,(a0,d0.w)
2:  add.w     #0x1f,d0                          | calc sound command
    move.b    d0,(REG_SOUND)
9:  rts

*
* 00-02,0E (high score, solvalou) B loop
*
    
* d0 = sound ordinal
osd_sound_stop:
    lea       snd_playing,a0
    * ADPCMA_LOOP_STOP
    cmp.b     #BOMB_SND,d0
    bne       1f
    move.b    #0x19,(REG_SOUND)
    rts
    * ADPCMB_LOOP_STOP
1:  cmp.b     #SOLVALOU_SND,d0
    beq.b     2f
    cmp.b     #HIGH_SCORE_SND,d0
    bgt.b     9f
2:  clr.b     (a0,d0.w)
    move.b    #0x1a,(REG_SOUND)
9:  rts
    
***
*** high score format
*** - high score table (a0) $50 bytes
***   - 5 entries
***     - 3 bytes BCD score (MSB-LSB)
***     - 10 bytes name (xevious encoded)
***     - 3 bytes filler ($00)
*** - high score (a1) $3 bytes
***   - 3 bytes BCD score (MSB-LSB)
***   - (no need to save this explicitly)
***

*** BRAM (MVS only)
*** Memory card (MVS,AES,NGCD)

patch_high_score_table:
    * extract high score from entry 1
    lea       mc_scores,a2
    move.b    (0,a2),(a1)+
    move.b    (1,a2),(a1)+
    move.b    (2,a2),(a1)+
    * extract high score table
    move.w    #16*5-1,d7
0:  move.b    (a2)+,(a0)+
    dbf       d7,0b
    rts

osd_read_high_scores:
    * try to read from BRAM first
    * - any memory card saves will overwrite
.ifndef __cd__
    tst.b     (BIOS_MVS_FLAG)                   | MVS?
    beq       check_memcard_data                | no, skip
check_BRAM_data:
    move.l    (memcard_buf),d0
    cmp.l     (memcard_hdr),d0                  | valid save data?
    bne.b     check_memcard_data                | no, skip
    movem.l   a0-a1,-(a7)
    bsr.b     patch_high_score_table
    movem.l   (a7)+,a0-a1
.endif | __cd__

check_memcard_data:    
    movem.l   d0-d7/a0-a6,-(a7)
    * try reading card data first
    move.b    #0x01,(BIOS_CRDF)
    move.w    #__NGH__,(BIOS_CRDNGH)
    jsr       BIOSF_CARD
    move.b    (BIOS_CRDRESULT),d0
    bne.b     2f
    * found some data for Xevious
    move.b    #0x02,(BIOS_CRDF)
    move.w    #__NGH__,(BIOS_CRDNGH)
    move.b    #0,(BIOS_CRDFILE)
    move.l    #memcard_buf,(BIOS_CRDPTR)
    move.w    #128,(BIOS_CRDSIZE)
    jsr       BIOSF_CARD
    move.b    (BIOS_CRDRESULT),d0
    bne       9f                                | error reading, exit
    movem.l   (a7)+,d0-d7/a0-a6
    bra       patch_high_score_table

    * handle card search data errors
2:  cmp.b     #0x80,d0                          | not inserted?
    beq.b     9f                                | not, return
    cmp.b     #0x81,d0                          | not formatted?
    bne.b     3f                                | not, go
    * format card
    move.b    #0x00,(BIOS_CRDF)
    jsr       BIOSF_CARD
    move.b    (BIOS_CRDRESULT),d0
    * not much we can do about failure
    bra.b     9f
3:  cmp.b     #0x82,d0                          | no data?
    beq.b     9f                                | no data, return
    nop
9:  movem.l   (a7)+,d0-d7/a0-a6
    rts
    
osd_write_high_scores:
    movem.l   d0-d7/a0-a6,-(a7)
    * init memcard buffer
    lea       memcard_hdr,a1
    lea       memcard_buf,a2
    move.w    #20+28-1,d7
1:  move.b    (a1)+,(a2)+
    dbf       d7,1b
    * copy high scores to memcard buffer
    move.w    #16*5-1,d7
2:  move.b    (a0)+,(a2)+
    dbf       d7,2b
    
    * write to BOTH BRAM and memcard (if valid)
    
.ifndef __cd__
    tst.b     (BIOS_MVS_FLAG)                   | MVS?
    beq       write_memcard_data                | no, skip
    *** write to BRAM first
write_BRAM_data:
    lea       0x10F300,a5
    move.b    #1,(0xBBF,a5)                     | mark BRAM as being used
    jsr       0xC12322                          | init_workbackup_ram
    clr.b     (0xBBF,a5)                        | unmark BRAM as being used
.endif | __cd__

    *** write to memcard
write_memcard_data:
    move.b    #0x03,(BIOS_CRDF)
    move.w    #__NGH__,(BIOS_CRDNGH)
    move.b    #0,(BIOS_CRDFILE)
    move.l    #memcard_buf,(BIOS_CRDPTR)
    move.w    #128,(BIOS_CRDSIZE)
    jsr       BIOSF_CARD
    move.b    (BIOS_CRDRESULT),d0
    bne       9f                                | error writing, exit
9:  movem.l   (a7)+,d0-d7/a0-a6
    rts

    .align 4
memcard_hdr:
    .byte     'X','E','V','I','O','U','S',' '
    .byte     ' ',' ',' ',' ',' ',' ',' ',' '
    .byte     ' ',' ',' ',' '
    .byte     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    .byte     0,0,0,0,0,0,0,0,0,0,0,0
        
* d0=backdropcolour
osd_debug_hook:
    move.w    d0,(BACKDROPCOLOR)
    rts
        
_end_of_ng_code:
    
    .text

    .align 2  
.include "palette.68k"

    .bss

    .align 4
* using 2 tiles/sprite only
scb1_shadow:                  ds.w  XSNS*4*2
scb3_shadow:                  ds.w  XSNS*2
scb4_shadow:                  ds.w  XSNS*2

fg_offset_lookup_tbl:         ds.w  0x0800
bg_offset_lookup_tbl:         ds.w  0x0800
fg_colorram_lookup_tbl:       ds.w  256
bg_colorram_lookup_tbl:       ds.w  512

.align 2
btm_sprite:                   ds.w    1
bg_scroll_x_r:                ds.w    1

p1_input_r:                   ds.b    1
p2_input_r:                   ds.b    1

snd_playing:                  ds.b    0x20

    .align 4
memcard_buf:
    mc_title:                 ds.b  20
                              ds.b  28
    mc_scores:                ds.b  16*5

_end_of_ng_data:
    