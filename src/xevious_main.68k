***
***  XEVIOUS MAIN CPU 68K core implementation
***    (transcoded from Z80 arcade code)
*** (c) 2022 tcdev
***

* exports

    * ROM
    .global _start_of_xevious_main_rom
    .global xevious_im1_irq
    .global xevious_reset
    .global save_PC_to_fn_tbl_and_ret
    .global start
    .global null_fn
    .global display_char
    .global _end_of_xevious_main_rom
    
    * RAM
    .global fg_colorram
    .global bg_colorram
    .global fg_videoram
    .global bg_videoram
    .global num_credits
    
* debugging only
    .global main_loop
    .global obj_tbl
    .global obj_handler_tbl
    .global add_obj_handler
    .global area_object_tbl_tbl
    .global area_1_obj_tbl
    .global _ram_start
    .global main_debug1
    .global main_debug2

.include "xevious.inc"

.macro SET_REENTRY_ADDR_HERE
    move.l    #0f,(a6)
0:    
.endm   

.macro SET_REENTRY_ADDR addr
    move.l    #\addr,(a6)
.endm

_start_of_xevious_main_rom:

xevious_reset: | $0000
    jsr       xevious_sub_reset                 | obviously 68K only
    bra       start

exit_caller: | $001D
    lea       (4,a7),a7
    
null_fn: | $001f
    rts

add_to_score: | $0020
    moveq     #3-1,d7
    lea       curr_player_score_lsb,a1
    andi      #0x0f,ccr                         | clear X flag
add_to_score_cont: | $0054
    move.b    (a0)+,d0                          | addition byte
    move.b    (a1),d1                           | score byte
    abcd      d0,d1                             | add BCD digits
    move.b    d1,(a1)                           | update score
    subq.l    #1,a1                             | byte-swapped
    dbf       d7,add_to_score_cont              | all bytes
    bcc.b     1f                                | no overflow
    jsr       set_score_to_9999990
1:  bsr.b     check_1_2_for_new_high_score_and_update
    bra       check_for_extra_solvalou
    
check_1_2_for_new_high_score_and_update: | $1311
    lea       curr_player_score_msb,a1
    bsr.b     check_for_new_high_score_and_update
    lea       other_player_score_msb,a1
    
check_for_new_high_score_and_update: | $131A
    lea       high_score_msb,a0
    moveq     #3-1,d7                           | scores are 3 bytes
    
check_new_high_score: | $131F
    move.b    (a1),d1                           | player score byte
    cmp.b     (a0),d1                           | less than high score byte?
    bcs.b     9f                                | yes, return
    bne       update_high_score                 | greater, go
    addq.l    #1,a0                             | byte-swapped
    addq.l    #1,a1                             | byte-swapped
    dbf       d7,check_new_high_score           | all bytes
9:  rts

update_high_score: | $1329
    move.b    (a1),(a0)                         | update high score byte
    addq.l    #1,a0                             | byte-swapped
    addq.l    #1,a1                             | byte_swapped
    dbf       d7,update_high_score              | all bytes
    move.b    (curr_player),d0
    addq.b    #1,d0
    *move.b    d0,(unk_8027)                    | appears unused by any CPU
    jmp       display_high_score
         
check_for_extra_solvalou: | $133A
    jsr       display_player_scores
    *** There is a call to a protection check routine here
    tst.b     (bonus_life_none)
    bne.w     9f
    ** Another Xevious BUG **
    ** whenever next_bonus_life_Ks is less than curr_player_score_Ks
    ** (which will be the case when eg. score=9,999,990)
    ** then C is never set, and an extra Solvalou is awarded
    ** every time this routine is called (points are added to the score)    
    move.w    (next_bonus_life_Ks),d1
    move.w    (curr_player_score_msb),d0        | swapped, Ks in Z80
    sub.w     d1,d0
    add.w     d1,d0                             | reached next bonus word?
    bcs.w     9f                                | no, exit
    move.b    (dswa),d0
    rol.b     #3,d0
    and.w     #3,d0                             | starting lives setting
    beq.b     1f                                | 5, skip
    move.w    #1,d0                             | use 2nd table
1:  lea       bonus_tbl_ptrs,a0
    lsl.w     #2,d0                             | x4 (entry offset)
    move.l    (a0,d0.w),a0                      | table address
    move.b    (dswa),d0
    not.b     d0
    lsr.b     #2,d0
    and.w     #7,d0                             | bonus life setting
    lsl.w     #2,d0                             | x2 (entry offset)
    move.w    (a0,d0.w),d1                      | addition for next bonus
    * this handles the 20K, 60K, every 60K situation
    * when bonus is 20K, and addition is 60K,
    * C is set so next bonus is set to 60K (not 20+60)    
    move.w    (next_bonus_life_Ks),d0
    sub.w     d1,d0
    add.w     d1,d0
    bcs.b     update_next_bonus_life_Ks
    * this handles when there is only 2 bonuses    
    move.b    (dswa),d0
    not.b     d0
    and.w     #7,d0
    cmp.b     #6,d0                             | only 2 bonuses?
    bne.b     2f                                | no, skip
    move.b    #1,(bonus_life_none)              | flag no more bonuses
2:  andi      #0x0f,ccr                         | clear X
    abcd      d1,d0
    move.b    d0,(next_bonus_life_Ks+1)         | LSB
    lsr.w     #8,d1
    lsr.w     #8,d0
    abcd      d1,d0
    move.b    d0,(next_bonus_life_Ks)           | MSB

award_extra_solvalou: | $1396
    addq.b    #1,(curr_player_solvalou_left)
    ** TBD sound
    bra       display_solvalou_left

9:  rts
    
update_next_bonus_life_Ks: | $13A3
    move.w    d1,(next_bonus_life_Ks)
    bra       award_extra_solvalou
    
save_PC_to_fn_tbl_and_ret: | $0030
    move.l    (a7)+,(a6)                        | pop return and store in table
    rts                                         | return up the call stack
        
xevious_im1_irq: | $0038
    movem.l   d0-d7/a0-a6,-(a7)
    move.w    #0x4F00,d0                        | red
    jsr       osd_debug_hook
    jsr       update_sprite_hw_and_other_things
    move.w    #0x8000,d0                        | black
    jsr       osd_debug_hook
    movem.l   (a7)+,d0-d7/a0-a6
    *** hack
    bsr.b     xevious_nmi
    rts

xevious_nmi: | $0066
    *** this routine in no way resembles the Z80 equivalent
    *** which accessed inputs via the 06XX custom chips
    *** - we just read inputs directly here
    movem.l   d0-d7/a0-a6,-(a7)
    move.w    #0x4F00,d0                        | red
    jsr       osd_debug_hook
    jsr       osd_read_p1_inputs
    move.b    d0,(P1_inputs)
    jsr       osd_read_p2_inputs
    move.b    d0,(P2_inputs)
    move.w    #0x8000,d0                        | black
    jsr       osd_debug_hook
    movem.l   (a7)+,d0-d7/a0-a6
    rts
        
update_sprite_hw_and_other_things: | $0096
    * copy sprites from shadow to OSD
    move.w    #0,d0                             | start at sprite 0
    jsr       osd_update_32_sprite_hw
    bsr.b     read_dipswitches
    move.b    #1,(vb_semaphore_sub)
    move.b    #1,(vb_semaphore_main)
    rts
    
read_dipswitches: | $0115
    jsr       osd_read_dipswitches
    move.b    d0,(dswa)
    move.b    d1,(dswb)
    rts
    
start: | $012E
    * zero $8000-$83FF (including sprite shadow)
    lea       vb_semaphore_main,a0
0:  clr.b     (a0)+
    cmpa.l    #watermark_0x8400,a0
    bne.b     0b
    * $0388 not interested in coinage information
    * $03F9 zeroes $8000-$81FF after tests 
    * - not required as we don't run self-tests
    clr.b     (maincpu_inited)                  | during RAM tests
    * $0414 setup function table in RAM
    lea       main_fn_tbl_ROM,a0
    lea       main_fn_tbl_RAM,a1
    moveq     #32-1,d7                          | 32 functions to copy
1:  move.l    (a0)+,(a1)+
    dbf       d7,1b
    *** brings SUB,SUB2 CPUs out of RESET here
    move.b    #1,(maincpu_inited)
    jsr       osd_ack_vblank_interrupt
    jsr       osd_enable_vblank_interrupt
    
restart_main_loop: | $0437
    move.b    (vb_semaphore_main),d0
    subq.b    #1,d0                             | signalled?
    bne       restart_main_loop                 | no, spin
    clr.b     (vb_semaphore_main)               | reset
    addq.b    #1,(countup_timer_1)

    ***
    *** The sub CPU spins waiting on vb_semaphore_sub, which is set 
    *** in the VBLANK interrupt handler at the same time
    *** as vb_sempahore_main above.
    *** Since we only have 1 processor, handle it sequentially here
    ***
    jsr       xevious_sub_cpu
    ***

    move.w    #0x20F0,d0                        | green
    jsr       osd_debug_hook

    * loops through main function table
    * - A6 points to current function table entry
    lea       main_fn_tbl_RAM,a6
    moveq     #32-1,d7                          | 32 functions
main_loop: | $0447
    move.l    (a6),a0                           | get jump address
    movem.l   d7/a6,-(a7)
    jsr       (a0)                              | call function
    movem.l   (a7)+,d7/a6
    lea       (4,a6),a6                         | next table entry
    dbf       d7,main_loop

    move.w    #0x8000,d0                        | black
    jsr       osd_debug_hook

    jsr       osd_kick_wdog
    bra.b     restart_main_loop

    .align 4      
main_fn_tbl_ROM: | $045B
    .long     main_fn_0__main_thread
    .long     main_fn_1__handle_solvalou
    .long     main_fn_2__handle_objects
    .long     main_fn_3__init_bacura
    .long     main_fn_4__spawn_flying_enemies
    .long     main_fn_5__inc_num_bacura
    .long     null_fn                           | protection
    .long     null_fn                           | protection_check
    .long     null_fn                           | check_fn_7_code
    .long     null_fn
    .long     null_fn
    .long     null_fn
    .long     null_fn
    .long     null_fn
    .long     null_fn
    .long     null_fn
    .long     null_fn
    .long     null_fn
    .long     null_fn
    .long     null_fn
    .long     null_fn
    .long     null_fn
    .long     null_fn
    .long     null_fn
    .long     null_fn
    .long     null_fn
    .long     null_fn
    .long     null_fn
    .long     null_fn
    .long     null_fn
    .long     main_fn_30__handle_shooting
    .long     main_fn_31__handle_bombing

main_fn_0__main_thread: | $049B
    jsr       zero_share1
    jsr       clear_fg_to_transparent
    jsr       clear_bg_to_black
    jsr       init_high_score_table
    
    * added for 68K transcode
    lea       high_score_1st_msb,a0
    lea       RAM_high_score,a1
    jsr       osd_read_high_scores
    
    * don't need to worry about cocktail mode
    move.b    #1,(scroll_disabled)
    move.w    #0xfff8,(scroll_delta)
    
main_thread_main_loop: | $04BB
    clr.b     (is_real_game)
    .ifne OPT_SKIP_TITLE
    bra       coined_up
    .endif
    tst.b     (num_credits)                     | zero?
    bne       coined_up                         | no, skip
    move.w    #2,(attract_mode_stage)
    jsr       save_PC_to_fn_tbl_and_ret

attract_mode_main_loop: | $04D6
    move.w    (attract_mode_stage),d0
    subq.w    #1,d0
    lea       attract_mode_jump_tbl,a0
    lsl.w     #2,d0                             | jump table offset
    move.l    (a0,d0.w),a0
    jmp       (a0)                              | go

flash_insert_coin_and_check_credits: | $04E3
    jsr       display_insert_coin_flashing
check_credits: | $04E6
    tst.b     (num_credits)                     | zero?
    beq       9f                                | yes, exit
coined_up:    
    jsr       zero_obj_state_tbl
    clr.w     (attract_mode_stage)
    move.b    #1,(scroll_disabled)              | disable
    jsr       clear_fg_to_transparent
    jsr       clear_bg_to_black
    jsr       display_push_start_button
    jsr       display_all_scores
    jsr       display_copyright_msgs
    jsr       display_xevious_logo_flashing
    jsr       save_PC_to_fn_tbl_and_ret
*
* loop here waiting for 1P or 2P start button
*
    jsr       display_credits   
    jsr       display_1_only_or_1_2_players
    tst.b     (start_pressed)                   | set in SUB CPU
    .ifeq OPT_SKIP_TITLE
    beq.w     9f
    .endif
    move.b    #1,(is_real_game)
    clr.b     (curr_player)
    clr.b     (start_pressed)
    lea       curr_player_score_msb,a0          | byte swapped
  .ifne OPT_START_SCORE
    move.b    #(OPT_START_SCORE>>20)&0xff,(a0)+
    move.b    #(OPT_START_SCORE>>12)&0xff,(a0)+
    move.b    #(OPT_START_SCORE>>4)&0xff,(a0)+
  .else
    clr.b     (a0)+
    clr.b     (a0)+
    clr.b     (a0)+
  .endif
    lea       starting_solvalou_tbl,a0
    move.b    (dswa),d0
    lsr.b     #5,d0
    and.w     #3,d0                             | lives setting
    move.b    (d0.w,a0),d0                      | lives   
    move.b    d0,(curr_player_solvalou_left)
    move.w    #OPT_START_AREA-1,(area)
    clr.b     (enemy_AI_level)
    move.b    (dswa),d0
    lsr.b     #5,d0
    and.w     #3,d0                             | lives setting
    eori.b    #3,d0                             | +ve logic
    beq.b     1f
    moveq     #1,d0
1:  lea       first_bonus_life_tbls,a0
    lsl.w     #4,d0                             | table offset
    move.l    (a0,d0.w),a0                      | get table address
    move.b    (dswa),d0
    not.b     d0
    lsr.b     #2,d0
    and.w     #7,d0                             | bonus life setting 
    lsl.w     #1,d0
    move.w    (a0,d0.w),(next_bonus_life_Ks)
    move.b    #1,(solvalou_number)              | used in AI
    move.b    (dswa),d1
    not.b     d1
    ror.b     #2,d1
    moveq     #0,d0
    and.w     #7,d1                             | bonus life setting (again)
    bne.b     2f
    addq.b    #1,d0
2:  move.b    d0,(bonus_life_none)
    tst.b     (two_player_game)                 | 2 players?
    beq.b     main_gameplay_loop                | no, skip
    lea       curr_player_score_msb,a0
    lea       other_player_score_msb,a1
    move.w    #64-1,d7                          | 64 bytes to copy
3:  move.b    (a0)+,(a1)+                       | init P2 settings
    dbf       d7,3b
    ** TBD sound
    
main_gameplay_loop: | $0593
    subq.b    #1,(curr_player_solvalou_left)
    move.w    (area),d0
    lea       area_offset_in_map_tbl,a0
    move.b    (a0,d0.w),(area_offset_in_map)
    move.w    #0xd00,(scroll_cntr)
    lea       area_object_tbl_tbl,a0
    lsl.w     #2,d0                             | offset for area in table
    move.l    (a0,d0.w),(area_obj_ptr)          | init area object ptr
    clr.b     (num_flying_enemies)
    clr.b     (flying_enemy_type_tbl_offset)
    clr.b     (num_bacura)
    clr.b     (bacura_inc_cnt)
    clr.b     (solvalou_exploding)
    jsr       clear_fg_to_transparent
    jsr       fill_bg_with_forest
    jsr       display_all_scores
    jsr       display_solvalou_left
    lea       main_fn_31__handle_bombing,a0
    move.l    a0,(main_fn_tbl_RAM+4*31)         | reset entry point
    lea       main_fn_1__handle_solvalou,a0
    move.l    a0,(main_fn_tbl_RAM+4*1)          | reset entry point
    clr.b     (scroll_disabled)
    ** TBD sound
    move.b    #0xa0,(countdown_timer_1)
    jsr       display_player_start_msgs
    jsr       save_PC_to_fn_tbl_and_ret
    subq.b    #1,(countdown_timer_1)            | time to wipe start msgs?
    beq.b     1f                                | yes, skip
    rts
1:  jsr       wipe_player_start_msgs
    jsr       save_PC_to_fn_tbl_and_ret
    tst.b     (scroll_disabled)                 | disabled?
    beq.w     9f                                | no, return
    jsr       fill_bg_with_forest
    move.b    #64,(countdown_timer_1)
    * this is handled in the SUB CPU...
    * so not quite sure why this needs to be done here (as well)?
    move.b    (scroll_cntr),d0                  | MSB
    sub.b     #14,d0
    cmp.b     #54,d0                            | more than 70% thru?
    bcc.b     2f                                | no, skip
    addq.w    #1,(area)                         | next area
    cmp.b     #16,(area)                        | last area?
    bne.b     2f                                | no, skip
    move.w    #6,(area)                         | restart at area=7
    * decrement the AI level according to the
    * STARTING LIVES dipswitch setting
2:  move.b    (dswb),d0
    not.b     d0
    rol.b     #3,d0 
    and.w     #3,d0                             | starting lives
    movea.l   #enemy_AI_dec_value,a0
    move.b    (enemy_AI_level),d1
    sub.b     (a0,d0.w),d1                      | subtract table entry
    bcc.b     3f                                | skip if positive
    clr.b     d1
3:  move.b    d1,(enemy_AI_level)
    jsr       save_PC_to_fn_tbl_and_ret
    subq.b    #1,(countdown_timer_1)
    bne.b     9f
    * remove all solvalou-related objects
    moveq     #7-1,d7                           | 7 solvolou objects
    lea       obj_tbl+_OBJSIZE*0x20,a0          | bomb target
4:  clr.b     (_STATE,a0)
    clr.b     (_ATTR,a0)
    lea       (_OBJSIZE,a0),a0
    dbf       d7,4b
    tst.b     (curr_player_solvalou_left)       | any solvalou left?
    bne       main_gameplay_loop_cont           | yes, continue
    bra       check_for_high_score
9:  rts

game_over: | $064E
    tst.b     (two_player_game)                 | two players?
    beq.b     2f                                | no, skip
    jsr       clear_fg_to_transparent
    jsr       fill_bg_with_forest
    jsr       display_all_scores
    jsr       display_game_over_player_1_2
    move.b    #128,(countdown_timer_1)          | init timer
    jsr       save_PC_to_fn_tbl_and_ret
    subq.b    #1,(countdown_timer_1)
    beq.b     1f
    rts
1:  jsr       wipe_game_over_player_1_2
    
2:  tst.b     (other_player_solvalou_left)      | other player still playing?
    beq.b     game_over_1_player                | no, go

next_player: | $0674
    jsr       swap_curr_other_player
    eor.b     #1,(curr_player)                  | switch player
    bra       main_gameplay_loop
    
main_gameplay_loop_cont: | $0682
    tst.b     (other_player_solvalou_left)      | other player still playing?
    bne.b     next_player                       | yes, go
    bra       main_gameplay_loop

game_over_1_player: | $068B
    jsr       clear_fg_to_transparent
    jsr       fill_bg_with_forest
    jsr       display_all_scores
    jsr       display_game_over
    move.b    #128,(countdown_timer_1)          | init timer
    jsr       save_PC_to_fn_tbl_and_ret
    subq.b    #1,(countdown_timer_1)
    beq.b     1f
    rts
1:  jsr       wipe_game_over_player_1_2
    tst.b     (curr_player)                     | player 1?
    beq       main_thread_main_loop             | yes, go
    jsr       swap_curr_other_player
    clr.b     (curr_player)                     | set player=1
    bra       main_thread_main_loop

*** $06B6-$06E0 contains code that blats memory
*** and is never called. Why is it here?

zero_share1: | $06E1
    lea       main_2_fn_tbl_1,a0
1:  clr.b     (a0)+
    cmpa.l    #watermark_0x8000,a0
    bne.b     1b
    rts
            
zero_obj_state_tbl: | $06F0
    lea       obj_tbl,a5
    moveq     #32-1,d7                          | 32 objects
1:  clr.w     (_STATE,a5)                       | state,bank
    lea       (32,a5),a5                        | next object
    dbf       d7,1b
    lea       obj_tbl+_OBJSIZE*0x3A,a5          | flying enemies
    *** There was a BUG in the original
    *** which cleared 6 bytes, rather than 6 objects (12 bytes)
    moveq     #6-1,d7
2:  clr.w     (_STATE,a5)                       | state,bank
    lea       (32,a5),a5                        | next object
    dbf       d7,2b
    rts
    
clear_fg_to_transparent: | $070D
    moveq     #0,d0                             | video offset
    move.w    #0x800-1,d7                       | length
    moveq     #0x24,d1                          | fg_attrib
1:  jsr       osd_w_fg_colorram
    addq.w    #1,d0
    dbf       d7,1b
    moveq     #0,d0                             | video offset
    move.w    #0x800-1,d7                       | length
    moveq     #0x24,d1                          | fg_tile
2:  jsr       osd_w_fg_videoram
    addq.w    #1,d0                             | next offset
    dbf       d7,2b
    rts

clear_bg_to_black: | $072A
    moveq     #0,d0                             | offset
    moveq     #3,d1                             | colour
    move.w    #0x800-1,d7
1:  jsr       osd_w_bg_colorram
    addq.w    #1,d0
    dbf       d7,1b
    moveq     #0,d0                             | offset
    moveq     #0,d1                             | tile
    move.w    #0x800-1,d7
2:  jsr       osd_w_bg_videoram
    addq.w    #1,d0
    dbf       d7,2b
    rts

fill_bg_with_forest: | $0747
    moveq     #0,d0                             | offset
    moveq     #0,d1                             | colour
    move.w    #0x800-1,d7
1:  jsr       osd_w_bg_colorram
    addq.w    #1,d0
    dbf       d7,1b
    moveq     #0,d0                             | offset
    move.w    #0x88,d1                          | starting tile
    moveq     #0x1c-1,d7                        | one column
2:  jsr       osd_w_bg_videoram
    addq.w    #1,d0                             | inc offset
    addq.w    #1,d1                             | next tile
    dbf       d7,2b
    lea       bg_videoram,a0                    | start of copy
    move.w    #0x7e4-1,d7                       | length
    moveq     #0,d1
3:  move.b    (a0)+,d1
    jsr       osd_w_bg_videoram                 | copy tile
    addq.w    #1,d0                             | inc offset
    dbf       d7,3b
    rts

swap_curr_other_player: | $076D
    lea       curr_player_score_msb,a0
    lea       other_player_score_msb,a1
    moveq     #64-1,d7                          | 64 bytes to swap
1:  move.b    (a0),d0
    move.b    (a1),(a0)+
    move.b    d0,(a1)+
    dbf       d7,1b
    rts
    
display_player_start_msgs: | $077F
    moveq     #0,d0
    move.b    (curr_player),d0
    lea       player_1_2_str_tbl,a0
    lsl.w     #2,d0                             | calc offset
    move.l    (a0,d0.w),a0                      | ptr to P1/P2 string addr
    move.w    #0x1217,d0                        | screen col,row
    moveq     #10,d7                            | 10 bytes to display
    moveq     #BANK_FG_VIDEORAM,d2
    jsr       display_string
    move.w    #0x1019,d0                        | screen col,row
    movea.l   #strREADY,a0
    moveq     #6,d7
    moveq     #BANK_FG_VIDEORAM,d2
    jsr       display_string
    movea.l   #strSOLVALOU_LEFT,a0
    move.w    #0x131B,d0                        | screen col,row
    moveq     #13,d7
    moveq     #BANK_FG_VIDEORAM,d2
    jsr       display_string
    move.w    #0x151B,d0                        | screen col,row
    move.b    (curr_player_solvalou_left),d1
    jsr       display_char                      | this could be a jmp
    rts                                         | preseverved to document
    
wipe_player_start_msgs: | $07B7
    move.w    #0x1217,d0                        | screen col,row
    moveq     #10,d7                            | length
    moveq     #0x24,d1                          | tile
    moveq     #BANK_FG_VIDEORAM,d2
    jsr       display_char_B_times
    move.w    #0x1019,d0                        | screen col,row
    moveq     #6,d7                             | length
    moveq     #0x24,d1                          | tile
    moveq     #BANK_FG_VIDEORAM,d2
    jsr       display_char_B_times
    moveq     #16,d7                            | length
    move.w    #0x151B,d0                        | screen col,row
    moveq     #0x24,d1                          | tile
    moveq     #BANK_FG_VIDEORAM,d2
    jsr       display_char_B_times              | this could be a jmp    
    rts                                         | preseverved to document
        
display_copyright_msgs: | $07DC
    move.w    #0x161f,d0                        | screen col,row
    lea       strCOPYRIGHT,a0
    moveq     #19,d7                            | string length
    moveq     #BANK_FG_VIDEORAM,d2
    jsr       display_string
    move.w    #0x1021,d0                        | screen col,row
    lea       strNAMCO,a0
    moveq     #7,d7                             | string length
    jsr       display_string
    move.w    #0x1021,d0                        | screen col,row
    moveq     #7,d7                             | length
    move.w    #0x1a,d1                          | attr
    moveq     #BANK_FG_COLORRAM,d2
    jsr       display_char_B_times              | this could be a jmp    
    rts                                         | preseverved to document

display_credits: | $0801
    move.w    #0x923,d0                         | screen col,row
    lea       strCREDIT,a0
    moveq     #6,d7                             | string length
    moveq     #BANK_FG_VIDEORAM,d2
    jsr       display_string
    sub.w     #0x0100,d0                        | skip column
    move.b    (num_credits),d1                  | BCD
    lsr.b     #4,d1
    and.w     #0x0f,d1                          | tens
    jsr       display_char
    move.b    (num_credits),d1
    and.w     #0x0f,d1                          | units
    bra       display_char
    
display_1_only_or_1_2_players: | $0823
    moveq     #0,d0
    move.b    (num_credits),d0
    cmp.b     #1,d0
    beq.b     1f
    clr.w     d0
1:  lea       one_only_one_or_two_str_tbl,a0
    lsl.w     #2,d0                             | calc offset
    movea.l   (a0,d0.w),a0
    move.w    #0x1519,d0                        | screen col,row
    moveq     #18,d7                            | string length
    moveq     #BANK_FG_VIDEORAM,d2
    bra       display_string        
    
display_push_start_button: | $083C
    move.w    #0x1517,d0                        | screen col,row
    lea       strPUSH_START_BUTTON,a0
    moveq     #17,d7                            | string length
    moveq     #BANK_FG_VIDEORAM,d2
    bra       display_string

wipe_game_over_player_1_2: | $0849
    move.w    #0x1118,d0                        | screen col,row
    moveq     #9,d7
    moveq     #BANK_FG_VIDEORAM,d2
    move.b    #0x24,d1                          | space
    jsr       display_char_B_times
    move.w    #0x121A,d0                        | screen col,row
    moveq     #10,d7
    jsr       display_char_B_times

display_game_over: | $085D
    move.w    #0x1118,d0                        | screen col,row
    lea       strGAME_OVER,a0
    moveq     #9,d7
    moveq     #BANK_FG_VIDEORAM,d2
    bra       display_string

display_game_over_player_1_2: | $086A
    jsr       display_game_over
    moveq     #0,d0
    move.b    (curr_player),d0
    lea       player_1_2_str_tbl,a0
    lsl.b     #2,d0                             | calc offset
    move.l    (a0,d0.w),a0                      | get string address
    move.w    #0x121A,d0                        | screen col,row
    moveq     #10,d7
    moveq     #BANK_FG_VIDEORAM,d2
    bra       display_string
        
display_insert_coin_flashing: | $0881
    move.b    (countup_timer_1),d0
    move.b    d0,d1                             | copy
    and.b     #0x0f,d0                          | timer expired?
    bne.b     9f                                | no, return
    lsr.b     #4,d1
    and.b     #1,d1                             | timer to wipe msg?
    beq.b     wipe_insert_coin                  | yes, go
    move.w    #0x121C,d0                        | offset
    lea       strINSERT_COIN,a0
    moveq     #11,d7                            | string length
    move.w    #BANK_FG_VIDEORAM,d2
    bra       display_string
9:  rts

wipe_insert_coin: | $089E
    move.w    #0x121C,d0                        | offset
    moveq     #11,d7                            | string length
    move.w    #BANK_FG_VIDEORAM,d2
    moveq     #0x24,d1                          | tile
    bra       display_char_B_times
        
display_xevious_logo_flashing: | $08AA
    move.w    #4,(bg_scroll_x_shadow)
    moveq     #BANK_BG_VIDEORAM,d2
    move.w    #0x1509,d0                        | screen col,row
    lea       xevious_logo_flashing_pt1,a0
    moveq     #18,d7                            | string length
    jsr       display_string
    move.w    #0x160A,d0                        | screen col,row
    lea       xevious_logo_flashing_pt2,a0
    moveq     #19,d7                            | string length
    jsr       display_string
    move.w    #0x150B,d0                        | screen col,row
    lea       xevious_logo_flashing_pt3,a0
    moveq     #18,d7                            | string length
    jsr       display_string
    move.w    #0x160C,d0                        | screen col,row
    lea       xevious_logo_flashing_pt4,a0
    moveq     #19,d7                            | string length
    jsr       display_string
    move.w    #0x170D,d0                        | screen col,row
    lea       xevious_logo_flashing_pt5,a0
    moveq     #20,d7                            | string length
    jsr       display_string
    move.w    #0x170E,d0                        | screen col,row
    lea       xevious_logo_flashing_pt6,a0
    moveq     #19,d7                            | string length
    jsr       display_string
    move.w    #0x170F,d0                        | screen col,row
    lea       xevious_logo_flashing_pt7,a0
    moveq     #17,d7                            | string length
    jsr       display_string
    move.w    #0x1510,d0                        | screen col,row
    move.w    #0xf9,d1                          | tile
    jsr       display_char
    moveq     #BANK_BG_COLORRAM,d2
    move.w    #0x1509,d0                        | screen col,row
    moveq     #0x0D,d1                          | attr
    moveq     #18,d7                            | string length
    jsr       display_char_B_times
    move.w    #0x160A,d0                        | screen col,row
    moveq     #0x0d,d1                          | attr
    moveq     #19,d7                            | string length
    jsr       display_char_B_times
    move.w    #0x150B,d0                        | screen col,row
    moveq     #0x11,d1                          | attr
    moveq     #2,d7                             | string length
    jsr       display_char_B_times
    move.w    #0x15,d1                          | attr
    moveq     #15,d7                            | string length
    jsr       display_char_B_times
    moveq     #0x11,d1                          | attr
    jsr       display_char
    move.w    #0x160C,d0                        | screen col,row
    moveq     #0x13,d1                          | attr
    moveq     #2,d7                             | string length
    jsr       display_char_B_times
    moveq     #0x17,d1                          | attr
    moveq     #16,d7                            | string length
    jsr       display_char_B_times
    moveq     #0x13,d1                          | attr
    jsr       display_char
    move.w    #0x170D,d0                        | screen col,row
    moveq     #0x13,d1                          | attr
    moveq     #2,d7                             | string length
    jsr       display_char_B_times
    moveq     #0x17,d1                          | attr
    moveq     #16,d7                            | string length
    jsr       display_char_B_times
    moveq     #0x0f,d1                          | attr
    jsr       display_char
    moveq     #0x13,d1                          | attr
    jsr       display_char
    move.w    #0x170E,d0                        | screen col,row
    moveq     #0x13,d1                          | attr
    jsr       display_char
    moveq     #0x19,d1                          | attr
    moveq     #17,d7                            | string length
    jsr       display_char_B_times
    moveq     #0x18,d1                          | attr
    jsr       display_char
    move.w    #0x170F,d0                        | screen col,row
    moveq     #0x18,d1                          | attr
    moveq     #2,d7                             | string length
    jsr       display_char_B_times
    moveq     #0x19,d1                          | attr
    jsr       display_char
    moveq     #0x18,d1                          | attr
    moveq     #14,d7                            | string length
    jsr       display_char_B_times
    move.w    #0x1510,d0                        | screen col,row
    moveq     #0x18,d1                          | attr
    jsr       display_char
    moveq     #BANK_FG_VIDEORAM,d2
    move.w    #0x150B,d0                        | screen col,row
    lea       xevious_logo_flashing_pt8,a0
    moveq     #17,d7                            | string length
    jsr       display_string
    move.w    #0x130C,d0                        | screen col,row
    lea       xevious_logo_flashing_pt9,a0
    moveq     #14,d7                            | string length
    jsr       display_string
    move.w    #0x140D,d0                        | screen col,row
    lea       xevious_logo_flashing_pt10,a0
    moveq     #16,d7                            | string length
    jsr       display_string
    move.w    #0x150E,d0                        | screen col,row
    lea       xevious_logo_flashing_pt11,a0
    moveq     #16,d7                            | string length
    jsr       display_string
    moveq     #0x1A,d1                          | red
    
set_colour_xevious_flashing_logo:
    moveq     #BANK_FG_COLORRAM,d2
    move.w    #0x150B,d0                        | screen col,row
    moveq     #17,d7                            | string length
    jsr       display_char_B_times
    move.w    #0x130C,d0                        | screen col,row
    moveq     #14,d7                            | string length
    jsr       display_char_B_times
    move.w    #0x140D,d0                        | screen col,row
    moveq     #16,d7                            | string length
    jsr       display_char_B_times
    move.w    #0x150E,d0                        | screen col,row
    moveq     #16,d7                            | string length
    bra       display_char_B_times

display_xevious_logo_yellow: | $09E8
    moveq     #BANK_FG_VIDEORAM,d2
    move.w    #0x160A,d0                        | screen col,row
    lea       xevious_logo_yellow_pt1,a0
    moveq     #19,d7                            | string length
    jsr       display_string
    move.w    #0x150B,d0                        | screen col,row
    lea       xevious_logo_yellow_pt2,a0
    moveq     #18,d7                            | string length
    jsr       display_string
    move.w    #0x150C,d0                        | screen col,row
    lea       xevious_logo_yellow_pt3,a0
    moveq     #18,d7                            | string length
    jsr       display_string
    move.w    #0x160D,d0                        | screen col,row
    lea       xevious_logo_yellow_pt4,a0
    moveq     #19,d7                            | string length
    jsr       display_string
    move.w    #0x170E,d0                        | screen col,row
    lea       xevious_logo_yellow_pt5,a0
    moveq     #20,d7                            | string length
    jsr       display_string
    move.w    #0x170F,d0                        | screen col,row
    lea       xevious_logo_yellow_pt6,a0
    moveq     #13,d7                            | string length
    jsr       display_string
    moveq     #0x1B,d1                          | yellow
    move.w    #0x160A,d0                        | screen col,row
    moveq     #BANK_FG_COLORRAM,d2
    moveq     #19,d7                            | string length
    jsr       display_char_B_times    
    move.w    #0x150B,d0                        | screen col,row
    moveq     #18,d7                            | string length
    jsr       display_char_B_times    
    move.w    #0x150C,d0                        | screen col,row
    moveq     #18,d7                            | string length
    jsr       display_char_B_times    
    move.w    #0x160D,d0                        | screen col,row
    moveq     #19,d7                            | string length
    jsr       display_char_B_times    
    move.w    #0x170E,d0                        | screen col,row
    move.q    #20,d7                            | string length
    jsr       display_char_B_times    
    move.w    #0x170F,d0                        | screen col,row
    move.q    #13,d7                            | string length
    bra       display_char_B_times    
    
xevious_logo_flashing_pt8:
    .byte 0x2A, 0x51, 0x52, 0x53, 0x52, 0x54, 0x55, 0x56, 0x24, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D
    .byte 0x52
xevious_logo_flashing_pt9:
    .byte 0x5E, 0x5F, 0x2A, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A
xevious_logo_flashing_pt10:
    .byte 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A
xevious_logo_flashing_pt11:
    .byte 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x7F, 0x88, 0x89
xevious_logo_flashing_pt1:
    .byte 0xC0, 0xC1, 0xC2, 0xC3, 0xC2, 0xC4, 0xC5, 0xC1, 0xC6, 0xC7, 0xC1, 0xC8, 0xC1, 0xC9, 0xCA, 0xCB
    .byte 0xCA, 0xCC
xevious_logo_flashing_pt2:
    .byte 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC
    .byte 0xDD, 0xDE, 0xDF
xevious_logo_flashing_pt3:
    .byte 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF
    .byte 0xF0, 0xF1
xevious_logo_flashing_pt4:
    .byte 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF, 0xA0, 0xA1
    .byte 0xA2, 0xA3, 0xA4
xevious_logo_flashing_pt5:
    .byte 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4
    .byte 0xB5, 0xB6, 0xB7, 0xB8
xevious_logo_flashing_pt6:
    .byte 0xB9, 0xBA, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBC, 0xBD, 0xBD, 0xBD, 0xBE, 0xBB, 0xBB, 0xBB
    .byte 0xBB, 0xBF, 0xF0
xevious_logo_flashing_pt7:
    .byte 0xF1, 0xF2, 0xBB, 0xF3, 0xF4, 0xF4, 0xF4, 0xF4, 0xF5, 0xF6, 0xF6, 0xF6, 0xF7, 0xF4, 0xF4, 0xF4
    .byte 0xF8
xevious_logo_yellow_pt1:
    .byte 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8D, 0x8F, 0x90, 0x87, 0x91, 0x92, 0x93, 0x94, 0x87, 0x95, 0x96
    .byte 0x97, 0x98, 0x99
xevious_logo_yellow_pt2:
    .byte 0x9A, 0x9B, 0x9C, 0x9D, 0x9C, 0x9E, 0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8
    .byte 0xA9, 0xAA
xevious_logo_yellow_pt3:
    .byte 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xA7, 0xB9
    .byte 0x9A, 0xBA
xevious_logo_yellow_pt4:
    .byte 0xAB, 0xBB, 0xAA, 0x9A, 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 0x9A, 0xC3, 0xAA, 0xC4, 0xC5
    .byte 0xC6, 0xC7, 0xC8
xevious_logo_yellow_pt5:
    .byte 0xAB, 0xBB, 0xC9, 0xCA, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xCB, 0xCA, 0xCA
    .byte 0xD3, 0xD4, 0xD5, 0xD6
xevious_logo_yellow_pt6:
    .byte 0xD7, 0xAA, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0xD8, 0xD9, 0xD9, 0xD9, 0xDA

strINSERT_COIN: | $0B8C
    .byte 0x12, 0x17, 0x1C, 0xE, 0x1B, 0x1D, 0x24, 0xC, 0x18, 0x12, 0x17

strGAME_OVER: | $0B97
    .byte 0x10, 0xA, 0x16, 0xE, 0x24, 0x18, 0x1F, 0xE, 0x1B

strPUSH_START_BUTTON:                           | "PUSH START BUTTON"
    .byte 0x19, 0x1E, 0x1C, 0x11, 0x24, 0x1C, 0x1D, 0xA, 0x1B, 0x1D, 0x24, 0xB, 0x1E, 0x1D, 0x1D, 0x18
    .byte 0x17
    
    .align 4
one_only_one_or_two_str_tbl:
    .long strONE_OR_TWO_PLAYERS
    .long strONE_PLAYER_ONLY
strONE_PLAYER_ONLY:                             | " ONE PLAYER ONLY  "
    .byte 0x24, 0x18, 0x17, 0xE, 0x24, 0x19, 0x15, 0xA, 0x22, 0xE, 0x1B, 0x24, 0x18, 0x17, 0x15, 0x22
    .byte 0x24, 0x24
strONE_OR_TWO_PLAYERS:                          | "ONE OR TWO PLAYERS"
    .byte 0x18, 0x17, 0xE, 0x24, 0x18, 0x1B, 0x24, 0x1D, 0x20, 0x18, 0x24, 0x19, 0x15, 0xA, 0x22, 0xE
    .byte 0x1B, 0x1C
strCREDIT:                                      | "CREDIT"
    .byte 0xC, 0x1B, 0xE, 0xD, 0x12, 0x1D
strREADY:                                       | "READY!"
    .byte 0x1B, 0xE, 0xA, 0xD, 0x22, 0x2C

    .align 4
player_1_2_str_tbl: | $0BE5
    .long strPLAYER_ONE
    .long strPLAYER_TWO

strPLAYER_ONE:
    .byte 0x19, 0x15, 0xA, 0x22, 0xE, 0x1B, 0x24, 0x18, 0x17, 0xE

strPLAYER_TWO:
    .byte 0x19, 0x15, 0xA, 0x22, 0xE, 0x1B, 0x24, 0x1D, 0x20, 0x18

strSOLVALOU_LEFT:
    .byte 0x1C, 0x18, 0x15, 0x1F, 0xA, 0x15, 0x18, 0x1E, 0x24, 0x15, 0xE, 0xF, 0x1D
    
starting_solvalou_tbl:  | $0C0A
    .byte 5, 2, 1, 3

    .align 4
* these tables work as byte-swapped too!
first_bonus_life_tbls:
    .long first_bonus_life_Ks_5
    .long first_bonus_life_Ks_123
first_bonus_life_Ks_5:
    .word 0x20
    .word 0x10
    .word 0x20
    .word 0x20
    .word 0x20
    .word 0x30
    .word 0x20
    .word 0xFFFF
first_bonus_life_Ks_123:
    .word 0x20
    .word 0x10
    .word 0x10
    .word 0x20
    .word 0x20
    .word 0x20
    .word 0x20
    .word 0xFFFF

* enemy AI decrement value
* subtracted from AI level each new solvalou
* - depends on starting lives DIPSW setting
enemy_AI_dec_value: | $0C34
    .byte 0x10, 0x18, 8, 0

xevious_flashing_logo_colour_tbl: | $0C38
    .byte 0x1A, 0x17, 0x18, 7, 0x3A, 0x1B, 0x1F, 0x15

    .align 4
attract_mode_jump_tbl: | $0C40
    .long     attract_mode_gameplay
    .long     attract_mode_title_screen
    .long     attract_mode_gameplay
    .long     attract_mode_high_score_table

attract_mode_title_screen: | $0C48
    jsr       clear_bg_to_black
    jsr       clear_fg_to_transparent
    jsr       display_copyright_msgs
    jsr       display_all_scores
    jsr       display_xevious_logo_flashing
    move.b    #0x40,(countdown_timer_1)
    SET_REENTRY_ADDR_HERE
    subq.b    #1,(countdown_timer_1)            | timer expired?
    beq.b     animate_sparkle_appearing         | yes, continue
    bra       flash_insert_coin_and_check_credits

animate_sparkle_appearing: | $0C6E
    movea.l   #obj_tbl+_OBJSIZE*0x0f,a5         | sparkle object
    move.w    #0xd60,(_X,a5)
    move.w    #0x1660,(_Y,a5)
    move.w    #0x300F,(_CODE,a5)                | code,color
    move.w    #0x0280,(_STATE,a5)               | state,attr
    clr.b     (_TIMER,a5)                       | init timer
    SET_REENTRY_ADDR_HERE
    lea       obj_tbl+_OBJSIZE*0x0f,a5          | sparkle object
    addq.b    #1,(_TIMER,a5)                    | inc timer
    cmp.b     #0x10,(_TIMER,a5)                 | expired?
    beq.b     animate_sparkle_moving            | yes, go
    move.b    (_TIMER,a5),d0
    lsr.b     #1,d0
    and.b     #7,d0
    add.b     #0x30,d0                          | convert to sparkle sprite
    move.b    d0,(_CODE,a5)
    bra       flash_insert_coin_and_check_credits

animate_sparkle_moving: | $0CA9
    lea       obj_tbl+_OBJSIZE*0x0f,a5          | sparkle object
    move.b    #0x78,(_TIMER,a5)                 | init timer
    SET_REENTRY_ADDR_HERE
    lea       obj_tbl+_OBJSIZE*0x0f,a5          | sparkle object
    addq.b    #1,(_TIMER,a5)                    | inc timer
    beq.b     animate_sparkle_disappearing
    move.b    (_TIMER,a5),d0
    and.b     #7,d0
    add.b     #0x38,d0                          | convert to sparkle sprite
    move.b    d0,(_CODE,a5)
    add.w     #0xffe0,(_Y,a5)
    bra       flash_insert_coin_and_check_credits

animate_sparkle_disappearing: | $0CD3
    lea       obj_tbl+_OBJSIZE*0x0f,a5          | sparkle object
    move.b    #0x10,(_TIMER,a5)                 | init timer
    SET_REENTRY_ADDR_HERE
    lea       obj_tbl+_OBJSIZE*0x0f,a5          | sparkle object
    subq.b    #1,(_TIMER,a5)                    | dec timer
    beq.b     animate_flashing_logo
    move.b    (_TIMER,a5),d0
    lsr.b     #1,d0
    and.b     #7,d0
    add.b     #0x30,d0                          | convert to sparkle sprite
    move.b    d0,(_CODE,a5)
    bra       flash_insert_coin_and_check_credits

animate_flashing_logo: | $0CF5
    clr.b     (countdown_timer_1)               | init timer
    lea       obj_tbl+_OBJSIZE*0x0f,a5          | sparkle object
    clr.b     (_STATE,a5)                       | remove
    SET_REENTRY_ADDR_HERE
    btst      #0,(countup_timer_1)              | timer expired?
    bne       flash_insert_coin_and_check_credits
    subq.b    #1,(countdown_timer_1)            | dec timer
    beq.b     exit_attract_mode_title_screen
    move.b    (countdown_timer_1),d0
    and.w     #7,d0                             | use timer for colour index
    lea       xevious_flashing_logo_colour_tbl,a0
    move.b    (d0.w,a0),d1                      | get colour
    jsr       set_colour_xevious_flashing_logo
    bra       flash_insert_coin_and_check_credits

exit_attract_mode_title_screen: | $0D21
    jsr       zero_obj_state_tbl
    move.w    #3,(attract_mode_stage)
    SET_REENTRY_ADDR attract_mode_main_loop
    bra       flash_insert_coin_and_check_credits
                
attract_mode_gameplay: | $0D35
    clr.b     (curr_player)                     | player 1
    clr.b     (area)
    clr.b     (enemy_AI_level)
    lea       area_offset_in_map_tbl,a0
    move.b    (d0.w,a0),(area_offset_in_map)
    move.w    #0xd00,(scroll_cntr)
    clr.w     d0                                | area 1 (offset=0)
    movea.l   #area_object_tbl_tbl,a0
    lsl.w     #1,d0                             | redundant
    move.l    (a0,d0.w),(area_obj_ptr)          | init area object ptr
    jsr       clear_fg_to_transparent
    jsr       fill_bg_with_forest
    jsr       display_all_scores
    jsr       display_copyright_msgs
    jsr       display_xevious_logo_yellow
    clr.b     (num_flying_enemies)
    clr.b     (flying_enemy_type_tbl_offset)
    clr.b     (num_bacura)
    clr.b     (bacura_inc_cnt)
    clr.b     (scroll_disabled)                 | enabled
    SET_REENTRY_ADDR_HERE
    tst.b     (scroll_disabled)                 | disabled?
    bne.b     exit_attract_mode_gameplay        | yes, done, exit
    bra       flash_insert_coin_and_check_credits

exit_attract_mode_gameplay: | $0D8C
    jsr       zero_obj_state_tbl
    addq.w    #1,(attract_mode_stage)           | next stage
    SET_REENTRY_ADDR attract_mode_main_loop
    bra       flash_insert_coin_and_check_credits
    
attract_mode_high_score_table: | $0DA2
    jsr       flash_logo_and_high_score_table
    move.b    #0x40,(countdown_timer_1)         | init timer
    SET_REENTRY_ADDR_HERE
    move.b    (countup_timer_1),d0
    and.b     #7,d0                             | timer expired?
    bne       check_credits                     | no, exit
    subq.b    #1,(countdown_timer_1)            | timer expired?
    beq       exit_attract_mode_high_score_table
    bra       check_credits

exit_attract_mode_high_score_table: | $0DC4
    move.w    #1,(attract_mode_stage)
    SET_REENTRY_ADDR attract_mode_main_loop
    bra       flash_insert_coin_and_check_credits

display_all_scores: | $0DD5
    jsr       display_high_score
    jsr       display_player_scores
    bra       display_high_score_text

* *** UNUSED CODE $0DDE-$E22

* calculates ratio between 2 differences
* d0=larger diff, d1=smaller diff
* returns d1=16-bit ratio 0-256/256
calc_dX_dY_ratio: | $0E23
    lsl.w     #8,d1                             | shift smaller diff into high byte
    move.b    d0,d2                             | save larger diff
    moveq     #0,d0
    moveq     #16-1,d7
1:  lsl.w     #1,d1
    roxl.b    #1,d0
    bcs.b     2f
    cmp.b     d2,d0
    bcs.b     3f
2:  sub.b     d2,d0
    addq.w    #1,d1
3:  dbf       d7,1b
    rts

* *** UNUSED CODE/DATA $0E35-$EB1

* d0=xdiff, d1=ydiff, ret: d2=index
get_index_for_angle: | $0EB2
    movem.l   d0-d1,-(a7)
    jsr       get_index_for_quadrant_angle
    movem.l   (a7)+,d0-d1
    btst.b    #7,d0                             | xdiff -ve?
    beq.b     1f                                | no, skip
    not.b     d2
    add.b     #0x81,d2                          | adjust for polarity
1:  btst.b    #7,d1                             | ydiff -ve?
    beq.b     9f                                | no, skip
    neg.b     d2                                | adjust for polarity
9:  rts

* d0=xdiff, d1=ydiff
get_index_for_quadrant_angle: | $0CE4
    tst.b     d1
    bpl.b     1f
    neg.b     d1
1:  tst.b     d0
    bpl.b     2f
    neg.b     d0
2:  cmp.b     d1,d0                             | ydiff > xdiff?
    bcs.b     swap_for_large_small
    
get_index_for_abs_angle: | $0ECD
    jsr       calc_dX_dY_ratio
    lsr.w     #3,d1
    lea       octant_angle_tbl,a3               | base address
    move.b    (a3,d1.w),d2                      | get_entry
    rts

swap_for_large_small: | $0EDE
    exg       d0,d1
    jsr       get_index_for_abs_angle
    not.b     d2
    add.b     #0x41,d2
    rts

octant_angle_tbl: | $0EE7
    .byte 0, 1, 3, 4, 5, 6, 8, 9, 0xA, 0xB, 0xC, 0xD, 0xF, 0x10, 0x11, 0x12
    .byte 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1D, 0x1E, 0x1F, 0x1F
    .byte 0x20
    .align 2

* *** PROTECTION ROUTINTE $0F08-$0F4A
* main_fn_6__protection
    
* returns in d0
pseudo_random_gen: | $0F4B
    moveq     #0,d0
    move.b    (pseudo_random_seed+1),d0         | LSB
    mulu      #5,d0
    addq.b    #1,d0
    move.b    d0,(pseudo_random_seed+1)         | save LSB
    moveq     #0,d1
    move.b    (pseudo_random_seed),d1           | MSB
    and.b     #0x84,d1
    beq.b     1f
    eor.b     #0x84,d1
    bne.b     2f
1:  ori       #(1<<4),ccr                       | set extend
2:  move.b    (pseudo_random_seed),d1           | MSB again
    addx.b    d1,d1
    move.b    d1,(pseudo_random_seed)           | save MSB
    add.b     d1,d0                             | d0 = return value
    rts
    
display_solvalou_left: | $0F68
    moveq     #0,d7
    move.b    (curr_player_solvalou_left),d7
    beq.b     9f
    moveq     #0x25,d1                          | tile (solvalou icon)
    move.w    #0x1B23,d0                        | screen col,row
    movem.w   d0/d7,-(a7)
    moveq     #BANK_FG_VIDEORAM,d2
    jsr       display_char_B_times
    movem.w   (a7)+,d0/d7
    moveq     #BANK_FG_COLORRAM,d2
    moveq     #0x2A,d1                          | colour
    bra       display_char_B_times
9:  rts

* *** UNUSED block of $FF $0F83-$0FFF
* *** padding for ROM device #1 (xvi_1.3p)
  
flash_logo_and_high_score_table: | $1000
    jsr       clear_fg_to_transparent
    jsr       clear_bg_to_black
    jsr       display_xevious_logo_flashing
    bra.s     display_high_score_table

cls_display_high_score_table: | $100B
    jsr       clear_fg_to_transparent
    jsr       fill_bg_with_forest

display_high_score_table: | $1011
    jsr       display_player_scores
    jsr       display_high_score_text
    jsr       display_high_score
    move.w    #0x1615,d0                        | screen col,row
    lea       strBest_Five_WARRIORS,a0
    moveq     #BANK_FG_VIDEORAM,d2
    moveq     #18,d7                            | string length
    jsr       display_string
    move.w    #0x1918,d0                        | screen col,row
    lea       str1st,a0
    moveq     #3,d7                             | string length
    jsr       display_string
    move.w    #0x1418,d0                        | screen col,row
    lea       high_score_1st_msb,a0
    jsr       display_score
    move.w    #0x0B18,d0                        | screen col,row
    lea       high_score_1st_name,a0
    moveq     #10,d7
    jsr       display_string
    move.w    #0x191A,d0                        | screen col,row
    lea       str2nd,a0
    moveq     #3,d7                             | string length
    jsr       display_string
    move.w    #0x141A,d0                        | screen col,row
    lea       high_score_2nd_msb,a0
    jsr       display_score
    move.w    #0x0B1A,d0                        | screen col,row
    lea       high_score_2nd_name,a0
    moveq     #10,d7
    jsr       display_string
    move.w    #0x191C,d0                        | screen col,row
    lea       str3rd,a0
    moveq     #3,d7                             | string length
    jsr       display_string
    move.w    #0x141C,d0                        | screen col,row
    lea       high_score_3rd_msb,a0
    jsr       display_score
    move.w    #0x0B1C,d0                        | screen col,row
    lea       high_score_3rd_name,a0
    moveq     #10,d7
    jsr       display_string
    move.w    #0x191E,d0                        | screen col,row
    lea       str4th,a0
    moveq     #3,d7                             | string length
    jsr       display_string
    move.w    #0x141E,d0                        | screen col,row
    lea       high_score_4th_msb,a0
    jsr       display_score
    move.w    #0x0B1E,d0                        | screen col,row
    lea       high_score_4th_name,a0
    moveq     #10,d7
    jsr       display_string
    move.w    #0x1920,d0                        | screen col,row
    lea       str5th,a0
    moveq     #3,d7                             | string length
    jsr       display_string
    move.w    #0x1420,d0                        | screen col,row
    lea       high_score_5th_msb,a0
    jsr       display_score
    move.w    #0x0B20,d0                        | screen col,row
    lea       high_score_5th_name,a0
    moveq     #10,d7
    bra       display_string

strBest_Five_WARRIORS:
    .byte 0xB, 0x3A, 0x48, 0x49, 0x24, 0xF, 0x3E, 0x4B, 0x3A, 0x24, 0x20, 0xA, 0x1B, 0x1B, 0x12, 0x18
    .byte 0x1B, 0x1C                            | "Best Five Warriors"
str1st:
    .byte 1, 0x48, 0x49                         | "1st"
str2nd:
    .byte 2, 0x43, 0x39                         | "2nd"
str3rd:
    .byte 3, 0x47, 0x39                         | "3rd"
str4th:
    .byte 4, 0x49, 0x3D                         | "4th"
str5th:
    .byte 5, 0x49, 0x3D                         | "5th"
    
    .align 2

init_high_score_table: | $10D9
    lea       ROM_high_score_tbl,a0
    lea       high_score_1st_msb,a1             | byte-swapped
    moveq     #0x50-1,d7
1:  move.b    (a0)+,(a1)+
    dbf       d7,1b
    lea       ROM_high_score,a0
    lea       RAM_high_score,a1
    moveq     #3-1,d7
2:  move.b    (a0)+,(a1)+
    dbf       d7,2b
    rts

ROM_high_score: 
  .byte 0, 0x40, 0
ROM_high_score_tbl: | $10F0
  .byte 0, 0x40, 0
  .byte 0x16, 0x50, 0x17, 0x36, 0x40, 0x36, 0x42, 0x4A, 0x47, 0x36
  .byte 0, 0, 0
  .byte 0, 0x35, 0
  .byte 0xE, 0x3E, 0x47, 0x47, 0x4E, 0x24, 0x16, 0x44, 0x4A, 0x50
  .byte 0, 0, 0
  .byte 0, 0x30, 0
  .byte 0xE, 0x4B, 0x3A, 0x4F, 0x44, 0x44, 0x24, 0xE, 0x43, 0x39
  .byte 0, 0, 0
  .byte 0, 0x25, 0
  .byte 0x1C, 0x50, 0x18, 0x40, 0x36, 0x42, 0x44, 0x49, 0x44, 0x24
  .byte 0, 0, 0
  .byte 0, 0x20, 0
  .byte 0x1C, 0x50, 0x14, 0x44, 0x3F, 0x3E, 0x42, 0x36, 0x24, 0x24
  .byte 0, 0, 0
  .align 2

check_for_high_score: | $1143
    lea       curr_player_score_msb,a0          | byte-swapped
    lea       RAM_test_result_final_score,a1
    moveq     #3-1,d7
1:  move.b    (a0)+,(a1)+
    dbf       d7,1b                             | copy score to buffer
    lea       name_buffer+1,a0
    move.b    #0x24,(a1)
    moveq     #9-1,d7
2:  move.b    (a1)+,(a0)+
    dbf       d7,2b                             | clear name buffer
                                                
    moveq     #5-1,d7                           | 5 scores to check
compare_high_score_entry: | $115B               
    lea       RAM_test_result_final_score,a0    
    move.w    d7,d0                             | iteration
    addq.w    #1,d0                             | (68k only)
    lsl.w     #4,d0                             | x16
    move.w    d0,d2                             | copy
    *addq.w    #2,d0                            | x16+2 (not for 68K)
    lea       (a0,d0.w),a0                      | entry address
    lea       RAM_test_result_final_score,a1    
    move.b    (a1),d1                           
    cmp.b     (a0),d1                           | MSB score higher?
    bcs.b     score_lower_than_entry            | no, go
    bne.b     move_high_score_entry_down        | higher, go
    lea       (1,a0),a0                         
    lea       (1,a1),a1                         
    move.b    (a1),d1                           
    cmp.b     (a0),d1                           | next byte score higher?
    bcs.b     score_lower_than_entry            | no, go
    bne.b     move_high_score_entry_down        | higher, go
    lea       (1,a0),a0                         
    lea       (1,a1),a1                         
    move.b    (a1),d1                           
    cmp.b     (a0),d1                           | LSB score higher?
    bcs.b     score_lower_than_entry            | no, go
                                                
move_high_score_entry_down: | $117E             
    lea       RAM_test_result_final_score,a0    
    lea       (a0,d2.w),a0                      | ptr entry to move down
    lea       (0x10,a0),a1                      | ptr next entry
    move.l    d7,-(a7)                          | save entry index
    moveq     #16-1,d7                          | #bytes for each entry
3:  move.b    (a0)+,(a1)+                       | move entry byte
    dbf       d7,3b                             | all bytes
    move.l    (a7)+,d7                          | restore score index
    dbf       d7,compare_high_score_entry

score_lower_than_entry: | $1191
    move.w    d7,d0
    addq.w    #1,d0                             | (68k only)
    move.b    d0,(new_high_score_entry_index)
    cmp.b     #5,d0
    beq       game_over
    lea       high_score_1st_msb,a1             | byte-swapped
    lsl.w     #4,d0                             | calc offset
    lea       (a1,d0.w),a1
    lea       RAM_test_result_final_score,a0
    moveq     #16-1,d7                          | 16 bytes to copy
4:  move.b    (a0)+,(a1)+                       | copy new entry to table
    dbf       d7,4b
    jsr       cls_display_high_score_table
    jsr       display_high_score_entry_screen
    move.w    #0x1900,d0                        | screen col
    moveq     #0,d1
    move.b    (new_high_score_entry_index),d1
    add.w     d1,d1
    add.w     #0x18,d1
    add.w     d1,d0                             | screen col,row
    moveq     #24,d7                            | 24 chars to fill
    moveq     #BANK_FG_COLORRAM,d2
    moveq     #0x1B,d1                          | attrib
    jsr       display_char_B_times
    and.w     #0x00ff,d0                        | screen row
    or.w      #0x0b00,d0                        | screen col
    move.w    d0,d1                             | save a copy of offset
    lea       high_score_1st_name,a0
    moveq     #0,d0
    move.b    (new_high_score_entry_index),d0
    lsl.w     #4,d0                             | x16
    lea       (a0,d0.w),a0                      | ptr entry (name)
    move.b    #10,(name_entry_char_cnt)         | 10 chars for name entry
    move.b    #0x80,(countdown_timer_1)         | init timer
    move.w    d1,(name_entry_curr_char_screen_offset)
    move.l    a0,(name_entry_ptr_curr_char)
    jsr       save_PC_to_fn_tbl_and_ret
    lea       P1_inputs,a0
    * looks like bit 4 is a debounced version of bit 5
    * = at least that's the way to get input to work
    btst.b    #4,(a0)                           | Button 1?        
    beq.b     name_entry_append_char            | yes, go
    bsr       check_lowercase
    move.w    (name_entry_curr_char_screen_offset),d0
    moveq     #BANK_FG_VIDEORAM,d2
    jsr       display_char
    move.b    (countup_timer_1),d0
    move      d0,d1                             | copy
    and.w     #7,d1                             | timer expired?
    bne.b     9f                                | no, skip
    and.w     #0x1f,d0                          | expired?
    bne.b     1f                                | no, continue
    subq.b    #1,(countdown_timer_1)            | expired?
    beq.b     name_entry_finished               | yes, exit
1:  lea       P1_inputs,a0
    move.b    (a0),d0                           | get input
    and.b     #0x0f,d0                          | joystick only
    cmp.b     #2,d0                             | right?
    beq.b     name_entry_inc_char               | yes, go
    cmp.b     #6,d0                             | left?
    bne.b     9f                                | no, exit
name_entry_dec_char: | $123D
    movea.l   (name_entry_ptr_curr_char),a0
    move.b    (a0),d0                           | char
    subq.b    #1,d0                             | dec
    cmp.b     #9,d0                             | before 'A'?
    bne.b     2f                                | no, skip
    move.b    #0x24,d0                          | char=' '
2:  move.b    d0,(a0)                           | save char
9:  rts

name_entry_append_char: | $124A
    bsr.b     check_lowercase
    move.b    d1,(a0)+                          | store new char
    move.l    a0,(name_entry_ptr_curr_char)     | save ptr
    move.w    (name_entry_curr_char_screen_offset),d0
    moveq     #BANK_FG_VIDEORAM,d2
    jsr       display_char
    move.w    d0,(name_entry_curr_char_screen_offset)
    subq.b    #1,(name_entry_char_cnt)          | last char?
    bne.b     9f                                | no, skip
    
name_entry_finished: | $1262
    * some writes to $A00X addresses, sound???
    
    * added for 68K transcode
    lea       high_score_1st_msb,a0
    lea       RAM_high_score,a1
    jsr       osd_write_high_scores
    
    bra       game_over

9:  rts

name_entry_inc_char: | $1272
    movea.l   (name_entry_ptr_curr_char),a0
    move.b    (a0),d0                           | char
    addq.b    #1,d0                             | inc
    cmp.b     #0x25,d0                          | after <space>?
    bne.b     1f                                | no, skip
    move.b    #0x0a,d0                          | char='A'
1:  move.b    d0,(a0)                           | save char
9:  rts

* returns character in d1
check_lowercase: | $127F
    move.b    (dswb),d1                         | inputs
    moveq     #0,d0
    lsr.b     #1,d1                             | B2?
    bcs.b     1f                                | no, skip
    move.b    #0x2c,d0                          | modififier for lowercase
1:  movea.l   (name_entry_ptr_curr_char),a0
    move.b    (a0),d1                           | get char
    add.b     d0,d1                             | add modifier
    rts

display_high_score_entry_screen: | $12A1
    move.w    #0x1509,d0                        | screen col,row
    lea       strCONGRATULATIONS,a0
    moveq     #BANK_FG_VIDEORAM,d2
    moveq     #16,d7                            | string length
    jsr       display_string
    move.w    #0x160C,d0                        | screen col,row
    lea       strENTER_YOUR_INITIAL,a0
    moveq     #18,d7                            | string length
    jsr       display_string
    moveq     #BANK_FG_COLORRAM,d2
    move.w    #0x1509,d0                        | screen col,row
    moveq     #0x1a,d1                          | attr
    moveq     #16,d7                            | string length
    jsr       display_char_B_times
    move.w    #0x160C,d0                        | screen col,row
    moveq     #18,d7                            | string length
    bra       display_char_B_times

strCONGRATULATIONS: | $12CD
    .byte 0xC, 0x18, 0x17, 0x10, 0x1B, 0xA, 0x1D, 0x1E, 0x15, 0xA, 0x1D, 0x12, 0x18, 0x17, 0x1C, 0x2C
                                                | "CONGRATULATIONS"
strENTER_YOUR_INITIAL: | $12DD
    .byte 0xE, 0x17, 0x1D, 0xE, 0x1B, 0x24, 0x22, 0x18, 0x1E, 0x1B, 0x24, 0x12, 0x17, 0x12, 0x1D, 0x12
    .byte 0xA, 0x15                               | "ENTER YOUR INITIAL"
    
display_high_score_text: | $12EF
    move.w    #0x1200,d0                        | screen col,row
    lea       strHIGH_SCORE,a0
    moveq     #10,d7                            | string length
    moveq     #BANK_FG_VIDEORAM,d2
    jsr       display_string
    move.w    #0x1200,d0                        | screen col,row
    moveq     #10,d7                            | string length
    moveq     #0x1f,d1                          | attr
    moveq     #BANK_FG_COLORRAM,d2
    jsr       display_char_B_times
    rts

* a1=1 byte beyond score
* - still works with byte-swapped score
set_score_to_9999990: | $1309
    moveq     #3-1,d7
1:  move.b    #0x99,-(a1)
    dbf       d7,1b
    rts

* *** MOVED UP TO FOLLOW add_to_score
*check_1_2_for_new_high_score_and_update: | $1311
*check_for_new_high_score_and_update: | $131A
*check_new_high_score: | $131F
*update_high_score: | $1329
*check_for_extra_solvalou: | $133A
*award_extra_solvalou: | $1396
*update_next_bonus_life_Ks: | $13A3

* *** protection_check: | $13A9-$13E7
       
    .align 4
bonus_tbl_ptrs: | $13FB
    .long bonus_tbl_5
    .long bonus_tbl_123
    
    .align 2    
bonus_tbl_5:    
    .word 0x70
    .word 0x50
    .word 0x50
    .word 0x60
    .word 0x80
    .word 0x100
    .word 0x80
    .word 0xFFFF
    
bonus_tbl_123:  
    .word 0x60
    .word 0x40
    .word 0x50
    .word 0x50
    .word 0x70
    .word 0x80
    .word 0x60
    .word 0xFFFF
    
* d0=offset (MSB=31-col,LSB=row), d2=bank
display_string: | $141F
    subq.w    #1,d7                             | adjust (optimise?)
    moveq     #0,d1
1:  move.b    (a0)+,d1                          | character
    jsr       display_char
    dbf       d7,1b   
    rts

display_player_scores: | $1427
    moveq     #BANK_FG_VIDEORAM,d2
    move.w    #0x1B01,d0                        | screen col,row P1
    move.w    #0x0801,d3                        | screen col,row P2
    tst.b     (curr_player)                     | P1?
    beq.b     1f                                | yes, skip
    exg       d0,d3                             | use P2 offset
1:  move.w    d3,-(a7)                          | save other offset
    lea       curr_player_score_msb,a0
    bsr.b     display_score
    move.w    (a7)+,d0                          | restore other offset
    tst.b     (two_player_game)                 | 2P game?
    beq       display_7_spaces                  | no, skip
    lea       other_player_score_msb,a0
    * fall thru to display score

* a0=score(ptr MSB)
display_score: | $1447
    moveq     #3-1,d7                           | bytes in score
    moveq     #5,d6                             | pad bytes
    bsr.b     display_bcd_value
    clr.b     d1
* fall thru to display a trailing zero
        
* d0=coffset (MSB=31-col,LSB=row) d1=char, d2=bank
* col is updated
display_char: | $144F
    movem.l   d0/d2/a0,-(a7)
    jsr       calc_screen_addr
    *** lookup osd routine based on bank
    *** - can this be optimised?
    movea.l   (osd_w_video_bank_tbl,pc,d2.w),a0
    jsr       (a0)
    movem.l   (a7)+,d0/d2/a0
    sub.w     #0x0100,d0                        | next column
    rts

    .align 4
osd_w_video_bank_tbl:
    .long     osd_w_fg_colorram
    .long     osd_w_bg_colorram
    .long     osd_w_fg_videoram
    .long     osd_w_bg_videoram

display_7_spaces:
    moveq     #0x24,d1                          | ' '
    moveq     #7,d7
    * fall thru to display 7 blanks

* d0=offset (MSB=31-col,LSB=row) d1=char, d2=bank, d7=B
display_char_B_times: | $145D
    subq.w    #1,d7
1:  bsr.w     display_char
    dbf       d7,1b
    rts
    
display_high_score: | $1463
    moveq     #BANK_FG_VIDEORAM,d2
    move.w    #0x1101,d0                        | col,row
    lea       high_score_msb,a0
    bra       display_score

* d7=bytes, d6=pads
display_bcd_value: | $146D
    moveq     #0,d1
    move.b    (a0),d1                           | byte
    lsr.b     #4,d1                             | high nibble
    bne.b     1f
    moveq     #0x24,d1                          | space
    subq.b    #1,d6                             | dec pads
    bpl.b     2f
    moveq     #0,d1                             | 0
1:  moveq     #0,d6                             | clear pad bytes
2:  move.l    d6,-(a7)
    bsr.w     display_char
    move.l    (a7)+,d6
    move.b    (a0),d1                           | byte
    and.b     #0x0f,d1                          | low nibble
    bne.b     3f
    moveq     #0x24,d1                          | space
    subq.b    #1,d6                             | dec pad bytes
    bpl.b     4f
    moveq     #0,d1                             | 0
3:  moveq     #0,d6                             | clear pad bytes
4:  move.l    d6,-(a7)
    bsr.w     display_char
    move.l    (a7)+,d6
    addq.l    #1,a0                             | we've reversed order
    dbf       d7,display_bcd_value
    rts

* d0=offset (MSB=31-col,LSB=row)
* d6 (trashed)
calc_screen_addr: | $0038
    sub.w     #0x0100,d0
    move.w    d0,d6
    addq.w    #4,d6
    and.w     #0x003f,d6
    add.w     #0x0300,d0
    lsr.w     #2,d0
    and.w     #0x07C0,d0
    or.w      d6,d0
    rts

main_fn_1__handle_solvalou: | $14BB
    jsr       save_PC_to_fn_tbl_and_ret
    tst.b     (scroll_disabled)
    bne       9f
    lea       obj_tbl+_OBJSIZE*0x22,a5         | crosshairs
    move.w    #0x0280,(_STATE,a5)
    move.w    #0x1420,(_CODE,a5)
    lea       obj_tbl+_OBJSIZE*0x23,a5         | solvalou
    move.w    #0x0200,(_STATE,a5)
    move.w    #0x5001,(_CODE,a5)
    move.w    #0x2500,(_X,a5)
    move.w    #0x0F00,(_Y,a5)
    jsr       save_PC_to_fn_tbl_and_ret
    tst.b     (scroll_disabled)
    bne.b     main_fn_1__handle_solvalou
    tst.w     (attract_mode_stage)
    bne.b     update_solvalou
    ** TBD SOUND
    nop

update_solvalou: | $14F7
    jsr       handle_solvalou_inputs
    jsr       update_solvalou_sprite_XY
    jsr       handle_crosshairs                 | colour and position
    jsr       check_solvalou_hit
    * player hit
.ifeq OPT_INVINCIBLE
    bcc       9f
.else
    rts
.endif  
    * solvalou hit/dead
    ** TBD SOUND
    tst.w     (attract_mode_stage)
    bne.b     explode_solvalou
    * there was some 06XX stuff here
    nop
    
explode_solvalou: | $151C
    move.b    #1,(solvalou_exploding)
    lea       obj_tbl+_OBJSIZE*0x23,a5          | solvalou
    clr.b     (_TIMER,a5)
    clr.b     (_TIMER1,a5)
    move.b    #0xc0,(_CODE,a5)
    move.b    #0x30,(_COLOUR,a5)
    jsr       save_PC_to_fn_tbl_and_ret
    lea       obj_tbl+_OBJSIZE*0x23,a5          | solvalou
    tst.b     (scroll_disabled)                 | disabled?
    bne       main_fn_1__handle_solvalou        | yes, exit
    move.b    (_TIMER,a5),d0
    addq.b    #1,d0                             | inc timer    
    and.w     #7,d0                             | expired?
    move.b    d0,(_TIMER,a5)
    bne.b     animate_solvalou_explosion        | no, go
    move.b    (_TIMER1,a5),d0
    addq.b    #1,d0                             | inc timer1
    move.b    d0,(_TIMER1,a5)
    cmp.b     #7,d0                             | expired?
    beq.b     finish_solvalou_exploding         | yes, go
    cmp.b     #2,d0                             | time to adjust sprite size?
    bne.b     1f                                | no, skip
    bsr.w     adj_for_small_explosion_frame
1:  cmp.b     #4,d0
    bne.b     2f
    bsr.w     adj_for_big_explosion_frame
2:  cmp.b     #6,d0
    bne.b     3f
    bsr.w     adj_for_small_explosion_frame
3:  add.b     #0x30,d0                          | calc colour
    move.b    d0,(_COLOUR,a5)
    
animate_solvalou_explosion: | $155E
    lea       solvalou_explosion_tbl,a0
    moveq     #0,d0
    move.b    (_TIMER1,a5),d0
    lsl.w     #1,d0
    move.b    (countup_timer_1),d1
    and.w     #0x0c,d1                          | cycle yflip,xflip
    add.b     (a0,d0.w),d1
    move.b    d1,(_ATTR,a5)                     | size
    move.b    (1,a0,d0.w),(_CODE,a5)            | code
9:  rts

finish_solvalou_exploding: | $1574
    move.b    #32,(_TIMER,a5)
    clr.b     (_STATE,a5)
    jsr       save_PC_to_fn_tbl_and_ret
    lea       obj_tbl+_OBJSIZE*0x23,a5          | solvalou
    subq.b    #1,(_TIMER,a5)
    bne.b     9f
    addq.b    #1,(solvalou_number)
    move.b    #1,(scroll_disabled)
    clr.b     (solvalou_exploding)
    bra       main_fn_1__handle_solvalou
9:  rts    

* colour, sprite code
solvalou_explosion_tbl:
    .byte 0, 0xC0
    .byte 0, 0xC1
    .byte 3, 0xC4
    .byte 3, 0xC8
    .byte 0, 0xC2
    .byte 0, 0xC3
    .byte 3, 0xCC

adj_for_small_explosion_frame: | $15A1
    addq.b    #1,(_Y,a5)                        | MSB
    subq.b    #1,(_X,a5)                        | MSB
    move.b    #0x2e,(_COLOUR,a5)
    rts

adj_for_big_explosion_frame: | $15B1
    subq.b    #1,(_Y,a5)                        | MSB
    addq.b    #1,(_X,a5)                        | MSB
    rts

update_solvalou_sprite_XY: | $15C1
    lea       obj_tbl+_OBJSIZE*0x23,a5         | solvalou
    move.w    (_X,a5),d0
    move.b    (_dX,a5),d1
    ext.w     d1
    lsl.w     #1,d1
    add.w     d1,d0
    cmp.w     #144*32,d0                        | too small?
    bcc.b     1f                                | no, skip
    move.w    #144*32,d0                        | set to 144
1:  cmp.w     #304*32,d0                        | too big?
    bcs.b     2f                                | no, skip
    move.w    #304*32,d0                        | set to 304
2:  move.w    d0,(_X,a5)
    move.w    (_Y,a5),d0
    move.b    (_dY,a5),d1
    ext.w     d1
    lsl.w     #1,d1
    add.w     d1,d0
    cmp.w     #16*32,d0                         | too small?
    bcc.b     3f                                | no, skip
    move.w    #16*32,d0                         | set to 16
3:  cmp.w     #224*32,d0                        | too big?
    bcs.b     4f                                | no, skip
    move.w    #224*32,d0                        | set to 224
4:  move.w    d0,(_Y,a5)        
    rts

handle_solvalou_inputs: | $15FE
    tst.w     (attract_mode_stage)              | attract mode?
    bne.b     gen_rnd_dir                       | yes, go
    lea       P1_inputs,a0
    moveq     #0,d1
    move.b    (curr_player),d1
    move.b    (a0,d1.w),d0                      | read inputs
    and.w     #0x0f,d0                          | joystick only
set_solvalou_dXdY:
    lea       dir_delta_tbl,a1
    add.w     d0,d0                             | entry offset
    lea       obj_tbl+_OBJSIZE*0x23,a5
    move.b    (a1,d0.w),(_dX,a5)
    move.b    (1,a1,d0.w),(_dY,a5)
    rts

gen_rnd_dir: | $1622
    move.b    (countup_timer_1),d0
    and.b     #0x0f,d0
    beq.b     1f
    rts
1:  jsr       pseudo_random_gen
    and.b     #0x0f,d0
    cmp.b     #9,d0
    bcc.b     1b
    bra.b     set_solvalou_dXdY

* input read from 51xx/60xx hardware
* - only returns 9 directions (0-8)
* - dir=8 results in no movement
dir_delta_tbl: | $1633
    .byte 0xF0, 0                               | U
    .byte 0xF0, 0xF0                            | U+R
    .byte 0, 0xE8                               | R
    .byte 0x10, 0xF0                            | D+R
    .byte 0x10, 0                               | D
    .byte 0x10, 0x10                            | D+L
    .byte 0, 0x18                               | L
    .byte 0xF0, 0x10                            | U+L
    .byte 0, 0                                  | none/invalid

check_solvalou_hit: | $1645
    move.b    (sprite_shadow_msb+2*0x23+0),d3   | solvalou spriteY
    move.b    (sprite_shadow_msb+2*0x23+1),d4   | solvalou spriteX
    
    lea       obj_tbl+_OBJSIZE*0x27,a1          | 1st bullet
    lea       sprite_shadow_msb+2*0x27,a3       | 1st object sprite coords
    moveq     #25-1,d7                          | 19 bullets + 6 flying enemies
check_bullets_and_flying: | $1655
    bsr.b     check_bullet_or_flying_hit_solvalou
    bcs.b     9f
    lea       (_OBJSIZE,a1),a1                  | next object
    addq.l    #2,a3                             | next sprite coords
    dbf       d7,check_bullets_and_flying
    
    lea       obj_tbl+_OBJSIZE*0x10,a1          | 1st bacura object
    lea       sprite_shadow_msb+2*0x10,a3       | 1st bacura sprite coords
    moveq     #16-1,d7                          | 16 bacura
check_bacura: | $1665
    bsr.b     check_bacura_hit_solvalou
    bcs.b     9f
    lea       (_OBJSIZE,a1),a1                  | next object
    addq.l    #2,a3                             | next sprite coords
    dbf       d7,check_bacura
9:  rts

check_bullet_or_flying_hit_solvalou: | $1670
    cmp.b     #2,(_STATE,a1)                    | active?
    bne.b     loc_1693                          | no, exit
    move.b    d3,d0                             | solvalou spriteY
    sub.b     (0,a3),d0                         | sub object spriteY
    subq.b    #8,d0
    add.b     #16,d0
    bcc.b     9f
    move.b    (1,a3),d0                         | object spriteX
    sub.b     d4,d0                             | sub solvalou spriteX
    subq.b    #4,d0
    addq.b    #8,d0
9:  rts

loc_1693: | $1693
    tst.b     d0                                | clear C
    rts

check_bacura_hit_solvalou: | $1695
    cmp.b     #2,(_STATE,a1)                    | active?
    bne.b     loc_1693                          | no, exit
    move.b    d3,d0                             | solvalou spriteY
    sub.b     (0,a3),d0                         | sub object spriteY
    sub.b     #28,d0
    add.b     #40,d0
    bcc.b     9f
    move.b    (1,a3),d0                         | object spriteX
    sub.b     d4,d0                             | sub solvalou spriteX
    subq.b    #8,d0
    add.b     #16,d0
9:  rts
    
handle_crosshairs: | $16B8
    lea       obj_tbl+_OBJSIZE*0x21,a5          | bomb
    move.b    (_STATE,a5),d0
    cmp.b     #2,d0                             | active?
    beq.b     1f                                | yes, skip
    moveq     #1,d2
1:  add.b     #31,d2                            | save colour
    moveq     #0,d7
    move.b    (countup_timer_1),d1
    and.b     #4,d1                             | time to check bombed objects?
    beq.b     update_crosshair                  | no, skip
    move.b    (sprite_shadow_msb+2*0x22+0),d3   | crosshairs spriteY
    move.b    (sprite_shadow_msb+2*0x22+1),d4   | crosshairs spriteX
    lea       sprite_shadow_msb+2*0x02,a3
    lea       obj_tbl+_OBJSIZE*0x02,a5          | ground_based objects
    moveq     #14-1,d7                          | 14 objects to check
2:  bsr.b     check_targeted_ground_object
    bcs.b     set_active_crosshair_colour
    addq.l    #2,a3
    lea       (_OBJSIZE,a5),a5                  | next object
    dbf       d7,2b                             | loop thru all objects
    moveq     #0,d7                             | to match Z80 exit condition
    
update_crosshair: | $16E8
    lea       obj_tbl+_OBJSIZE*0x22,a5          | crosshairs
    add.b     d7,d2                             | calc colour
    move.b    d2,(_COLOUR,a5)   
    lea       obj_tbl+_OBJSIZE*0x23,a4          | solvalou
    move.w    (_X,a4),d0
    add.w     #0xf400,d0
    move.w    d0,(_X,a5)                        | crosshair spriteX
    move.w    (_Y,a4),(_Y,a5)                   | crosshair spriteY
    rts

set_active_crosshair_colour: | $16FE
    moveq     #9,d7
    bra.b     update_crosshair

loc_1702:
    tst.b     d0                                | clear carry
    rts
    
* d3=crosshairs spriteY[7:0]??, d4=crosshairs spriteX[8:1]??
* a3=sprite_shadow_msb (object) a5=obj_tbl(object)
check_targeted_ground_object: | $1704
    cmp.b     #2,(_STATE,a5)                    | object active?
    bne.b     loc_1702                          | no, return
    move.b    d3,d0                             | object spriteY shadow
    sub.b     (0,a3),d0                         | compare object spriteY
    sub.b     #0x0a,d0
    add.b     #0x14,d0                          | Y matches?
    bcc.b     9f                                | no, exit
    move.b    (1,a3),d0                         | object spriteX shadow
    sub.b     d4,d0
    subq.b    #5,d0
    add.b     #0x0a,d0                          | C = matches
9:  rts
    
main_fn_30__handle_shooting: | $1727
    jsr       save_PC_to_fn_tbl_and_ret
    tst.b     (scroll_disabled)                 | disabled?
    bne.w     9f                                | yes, return
    move.b    #0x14,(shot_timer_init_value)
    move.b    #0x01,(shot_timer)
    clr.b     (shot_flag)
* insert function to handle 3 shots
    lea       main_fn_30_shot_fn,a0             | get handler address
    move.l    a0,(main_30_fn_tbl)               | insert 1st slot
    lea       main_30_fn_tbl,a0                 | get table address
    lea       (4,a0),a1                         | 2nd slot address
    moveq     #2-1,d7                           | 2 copies to make
1:  move.l    (a0)+,(a1)+                       | copy slot to next
    dbf       d7,1b                             | loop thru all slots
    jsr       save_PC_to_fn_tbl_and_ret
    tst.b     (scroll_disabled)                 | disabled?
    bne.b     main_fn_30__handle_shooting       | yes, exit
    tst.b     (solvalou_exploding)
    bne.b     2f                                | yes, skip shooting
    bsr.b     handle_shooting
2:  movea.l   #main_30_fn_tbl,a6
    lea       obj_tbl+_OBJSIZE*0x24,a5          | 1st bullet object
    lea       sprite_shadow_msb+2*0x24,a3
    moveq     #3-1,d7                           | 3 bullet objects
3:  movea.l   (a6),a0
    movem.l   d7/a3/a4/a6,-(a7)
    jsr       (a0)                              | call handler
    movem.l   (a7)+,d7/a3/a4/a6
    lea       (4,a6),a6                         | next table entry
    lea       (_OBJSIZE,a5),a5                  | next object
    addq.l    #2,a3                             | next sprite shadow entry
    dbf       d7,3b                             | loop thru all bullets
    clr.b     (shot_flag)
9:  rts

handle_shooting: | $1772
    tst.b     (attract_mode_stage)              | attract mode?
    bne.b     gen_rnd_shot                      | yes, go
    lea       P1_inputs,a1
    btst.b    #5,(a1)                           | Button 1?
loc_1787:
    lea       shot_timer,a0
    beq.b     process_button_1                  | yes (active low), go
    move.b    #1,(a0)                           | reset shot timer
    rts

process_button_1:
    subq.b    #1,(a0)                           | shot timer expired?
    bne.b     9f                                | no, return
    move.b    (shot_timer_init_value),(a0)      | re-init shot timer
    move.b    #1,(shot_flag)                    | flag shooting
9:  rts

gen_rnd_shot: | $179B
    jsr       pseudo_random_gen
    and.b     #0x0f,d0                          | 1/16 chance of firing
    bra.b     loc_1787                          | continue
        
main_fn_30_shot_fn: | $17A2
    jsr       save_PC_to_fn_tbl_and_ret
    move.b    (shot_flag),d0
    subq.b    #1,d0                             | shooting?
    bne.w     9f                                | no, return
    move.b    d0,(shot_flag)                    | clr.b?
* init shot
    move.b    #2,(_STATE,a5)
    move.b    #2,(_EXTRA,a5)                    | temp state
    move.w    #0xffa0,(_dX,a5)
    * (TBD) start shot sound
    lea       obj_tbl+_OBJSIZE*0x23,a0          | solvalou
    move.w    (_X,a0),(_X,a5)                   | copy spriteX to shot
    move.w    (_Y,a0),(_Y,a5)                   | copy spriteY to shot
    jsr       save_PC_to_fn_tbl_and_ret
* update shot
    jsr       check_flying_enemies_shot
    move.b    (countup_timer_1),d0
    move.b    d0,d1                             | save a copy
    and.b     #1,d1
    lsl.b     #3,d1                             | toggle flip
    add.b     #0x80,d1                          | bank=1    
    move.b    d1,(_ATTR,a5)
    move.b    d0,d1                             | timer (again)
    lsr.b     #1,d1
    and.b     #1,d1
    add.b     #0x23,d1
    move.b    d1,(_COLOUR,a5)
    lsr.b     #2,d0                             | timer (again)
    and.b     #1,d0
    add.b     #0x16,d0
    move.b    d0,(_CODE,a5)
    cmp.b     #3,(_STATE,a5)                    | destroyed?
    beq.b     shot_destroyed                    | yes, go
    bsr.b     move_shot
    cmp.w     #0x2800,d0                        | (MSB=40) off-screen?
    bcs.b     9f                                | no, return
delete_shot:
    clr.b     (_STATE,a5)
    bra.w     main_fn_30_shot_fn
9:  rts

* this only happens when the shot hits a bacura
shot_destroyed: | $180D
    move.b    #24,(_dX,a5)                      | reflected
    move.b    #0x23,(_COLOUR,a5)
    move.b    #0xff,(_TIMER,a5)
    jsr       save_PC_to_fn_tbl_and_ret
    addq.b    #1,(_TIMER,a5)
    move.b    (_TIMER,a5),d0
    cmp.b     #8,d0                             | time to deactivate?
    beq.b     delete_shot                       | yes, go
    move.b    d0,d1
    lsr.b     #1,d1
    and.b     #3,d1
    add.b     #0x18,d1                          | generate sprite code
    move.b    d1,(_CODE,a5)
    and.b     #1,d0                             | toggle yflip
    lsl.b     #3,d0
    add.b     #0x80,d0                          | bank=1
    move.b    d0,(_ATTR,a5)                     | bank,yflip
    
move_shot: | $184B
    move.w    (_dX,a5),d0
    lsl.w     #1,d0
    add.w     (_X,a5),d0                        | update spriteX
    move.w    d0,(_X,a5)                        | need a copy in d0
    rts
    
gen_random_bomb_press: | $185B
    jsr       pseudo_random_gen
    bne.b     9f
    bra.b     init_bombing
9:  rts

main_fn_31__handle_bombing: | $1862
    jsr       save_PC_to_fn_tbl_and_ret
    tst.b     (scroll_disabled)                 | disabled?
    bne.w     9f                                | yes, return
    tst.b     (solvalou_exploding)              | exploding?
    bne.w     9f                                | yes, return
    tst.b     (attract_mode_stage)              | in attract mode?
    bne.b     gen_random_bomb_press             | yes, go
* read BUTTON2 from h/w
    btst.b    #0,(dswb)                         | bomb pressed?
    bne.w     9f                                | no, return
    jsr       save_PC_to_fn_tbl_and_ret

init_bombing: | $188C
    lea       obj_tbl+_OBJSIZE*0x20,a0          | bomb target object
    cmp.b     #1,(_STATE,a0)                    | idle?
    bne.w     9f                                | no, return
    jsr       save_PC_to_fn_tbl_and_ret
    lea       obj_tbl+_OBJSIZE*0x23,a2          | solvalou object
    lea       obj_tbl+_OBJSIZE*0x21,a1          | bomb object
    lea       obj_tbl+_OBJSIZE*0x20,a0          | bomb target object
    move.w    (_X,a2),d0                        | solvalou spriteX
    move.w    d0,(_X,a1)                        | copy to bomb
    add.w     #0xf400,d0                        | adjust for bomb target
    move.w    d0,(_X,a0)                        | copy to bomb target
    move.w    (_Y,a2),d0                        | solvalou spriteY
    move.w    d0,(_Y,a1)                        | copy to bomb
    move.w    d0,(_Y,a0)                        | copy to bomb target
    clr.w     (_dX,a1)                          | bomb dX
    clr.b     (_TIMER,a1)
    clr.b     (_TIMER1,a1)
    * (TBD) start bomb sound
    move.w    #0x0280,d0                        | state=2, bank=1
    move.w    d0,(_STATE,a1)                    | bomb
    move.w    d0,(_STATE,a0)                    | bomb target
    move.b    #0x1c,(_CODE,a1)                  | bomb
    move.w    #0x1422,(_CODE,a0)                | bomb target code, colour
    jsr       save_PC_to_fn_tbl_and_ret
* bomb active here
    lea       obj_tbl+_OBJSIZE*0x21,a1          | bomb object
    addq.b    #1,(_TIMER,a1)                    | inc timer
    move.b    (_TIMER,a1),d0
    and.b     #7,d0                             | time to animate?
    bne.b     1f                                | no, skip
    move.b    (_TIMER1,a1),d0
    cmp.b     #2,d0                             | time to animate?
    beq.b     1f                                | no, skip
    addq.b    #1,d0                             | inc timer
    move.b    d0,(_TIMER1,a1)                   | update timer
    addq.b    #1,(_CODE,a1)                     | animate sprite
1:  move.b    (_TIMER,a1),d0
    lsr.b     #2,d0
    and.b     #3,d0
    add.b     #0x25,d0                          | generate colour
    move.b    d0,(_COLOUR,a1)                   | bomb colour
    subq.w    #2,(_dX,a1)
    move.w    (_dX,a1),d0
    lsl.w     #1,d0                             | x2
    add.w     d0,(_X,a1)                        | add new dX
    lea       obj_tbl+_OBJSIZE*0x20,a0          | bomb target
    move.w    (scroll_delta),d0
    neg.w     d0
    lsl.w     #1,d0
    add.w     d0,(_X,a0)                        | scroll bomb target
    bsr.b     check_bomb_finished
    bcs.b     9f
    bra.w     main_fn_31__handle_bombing
9:  rts

check_bomb_finished: | $190B
    lea       obj_tbl+_OBJSIZE*0x20,a0          | bomb target
    lea       obj_tbl+_OBJSIZE*0x21,a1          | bomb object
    move.w    (_X,a0),d0
    sub.w     (_X,a1),d0                        | same?
    bcs.b     9f                                | no, return
    * (TBD) stop bomb sound
    jsr       handle_bombed_obj_and_award_points
    clr.b     (_STATE,a1)                       | bomb object
    clr.b     (_STATE,a0)                       | bomb target
9:  rts

check_flying_enemies_shot: | $1928
    move.b    (0,a3),d3                         | shot spriteY
    move.b    (1,a3),d4                         | shot spriteX
    
    lea       obj_tbl+_OBJSIZE*0x3a,a1          | 1st flying enemy
    lea       sprite_shadow_msb+2*0x3a,a3
    moveq     #6-1,d7                           | 6 enemies to check
1:  bsr.b     check_shot_hit_flying_enemy
    bcc.b     loc_1972
    move.b    #3,(_STATE,a1)                    | enemy hit
    clr.b     (_EXTRA,a5)                       | flag shot to be destroyed
    tst.b     (attract_mode_stage)              | attract mode?
    bne       loc_1972                          | yes, skip
    moveq     #0,d0
    move.b    (_PTS,a1),d0                      | enemy points
    lea       object_value_tbl,a0
    lea       (a0,d0.w),a0                      | address of points value
    *** do we really need to push a3?
    movem.l   d7/a1/a3,-(a7) 
    jsr       add_to_score
    movem.l   (a7)+,d7/a1/a3
    ** TBD sound  
    
loc_1972: | 1972
    lea       (_OBJSIZE,a1),a1                  | next enemy
    addq.l    #2,a3
    dbf       d7,1b
    
    move.b    (_EXTRA,a5),(_STATE,a5)           | update shot state

    lea       obj_tbl+_OBJSIZE*0x10,a1          | 1st bacura
    lea       sprite_shadow_msb+2*0x10,a3
    moveq     #16-1,d7                          | 16 bacura to check
2:  bsr.b     check_shot_hit_bacura
    bcs.b     deactivate_shot
    lea       (_OBJSIZE,a1),a1                  | next bacura
    addq.l    #2,a3
    dbf       d7,2b
    rts

deactivate_shot: | $1997
    move.b    #3,(_STATE,a5)
    ** TBD sound
    rts

* d3=shot spriteY, d4=shot_spriteX, 
* a1=enemy object a3=enemy sprite_shadow_msb
check_shot_hit_flying_enemy: | $19A6
    cmp.b     #2,(_STATE,a1)                    | active?
    bne.b     loc_19C9                          | no, go
    move.b    d3,d0                             | shot sprite Y
    sub.b     (0,a3),d0                         | compare to enemy sprite Y
    sub.b     #16,d0
    add.b     #32,d0                            | hit?
    bcc.b     9f                                | no, exit
    move.b    (1,a3),d0                         | enemy sprite X
    sub.b     d4,d0                             | compare to shot sprite X
    subq.b    #8,d0
    add.b     #16,d0                            | C = hit
9:  rts

loc_19C9: | $19C9
    tst.b     d0                                | clear carry
    rts

check_shot_hit_bacura: | $19CB
    cmp.b     #2,(_STATE,a1)                    | active?
    bne       loc_19C9                          | no, go
    move.b    d3,d0                             | solvalou spriteY
    sub.b     (0,a3),d0                         | compare to bacura spriteY
    sub.b     #24,d0
    add.b     #32,d0                            | hit?
    bcc.b     9f                                | no, return
    move.b    (1,a3),d0                         | bacura spriteX[8:1]
    sub.b     d4,d0                             | solvalou spriteX[8:1]
    subq.b    #8,d0
    add.b     #16,d0                            | C = hit
9:  rts
            
handle_bombed_obj_and_award_points: | $19EE
    movem.l   a0/a1/a3,-(a7)
    move.b    (sprite_shadow_msb+2*0x20+0),d3   | bomb target spriteY
    move.b    (sprite_shadow_msb+2*0x20+1),d4   | bomb target spriteX
    lea       obj_tbl,a1
    lea       sprite_shadow_msb,a3
    moveq     #16-1,d7                          | 16 objects to check
1:  bsr.b     check_object_on_target            | on target?
    bcc.b     loc_1A2C                          | no, skip  
    move.b    #3,(_STATE,a1)                    | state=hit
    tst.b     (attract_mode_stage)              | attract mode?
    bne       loc_1A2C                          | no, skip
    moveq     #0,d0
    move.b    (_PTS,a1),d0
    lea       object_value_tbl,a0
    lea       (a0,d0.w),a0                      | get entry for points
    movem.l   d3/d4/d7/a0/a1/a3,-(a7) 
    jsr       add_to_score
    movem.l   (a7)+,d3/d4/d7/a0/a1/a3
loc_1A2C:
    lea       (_OBJSIZE,a1),a1                  | next enemy
    addq.l    #2,a3
    dbf       d7,1b
    movem.l   (a7)+,a0/a1/a3
    rts

loc_1A34:
    tst.b     d0                                | clear C flag
    rts
    
check_object_on_target: | $1A3D
    cmp.b     #2,(_STATE,a1)                    | active?
    bne.b     loc_1A34                          | no, return
    move.b    d3,d0                             | bomb target spriteY
    sub.b     (0,a3),d0                         | compare object spriteY
    sub.b     #10,d0
    add.b     #20,d0                            | hit?
    bcc.b     9f                                | no, return
    move.b    (1,a3),d0                         | bomb target spriteX
    sub.b     d4,d0                             | compare object spriteX
    subq.b    #5,d0
    add.b     #10,d0                            | C = hit
9:  rts
    
* Barra (pyrmaid) 100 pts
handle_1E_Barra: | $1A60
    move.b    #2,(_STATE,a5)
    clr.b     (_ATTR,a5)
    move.b    #7,(_COLOUR,a5)
    move.b    #0x17,(_CODE,a5)
    move.b    #15,(_PTS,a5)                     | 100 pts
    jsr       save_PC_to_fn_tbl_and_ret
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       handle_bomb_explosion
    jsr       scroll_sprite_X
    bra       add_obj_handler

* Garu Barra (Big) 300 pts
handle_20_Garu_Barra: | $1A89
    move.b    #3,(_STATE,a5)                    | can't destroy outer section
    move.b    #3,(_ATTR,a5)                     | size=2x2
    move.w    #_OBJSIZE,d5                      | next object
    move.b    #2,(_STATE,a5,d5.w)
    clr.b     (_ATTR,a5,d5.w)
    move.b    #0x01,(_X,a5,d5.w)                | MSB
    move.w    (_Y,a5),d0                        | 1st object sprite Y
    sub.w     #0x0100,d0                        | adjust
    move.w    d0,(_Y,a5,d5.w)                   | 2nd object sprite Y
    move.b    #0x17,(_CODE,a5,d5.w)
    move.b    #7,(_COLOUR,a5,d5.w)
    move.b    #27,(_PTS,a5,d5.w)                | 300 pts
    move.b    #0x48,(_CODE,a5)
    movea.l   #garu_barra_handler,a0
    move.l    a0,(4,a6)                         | patch handler for next object
    SET_REENTRY_ADDR_HERE
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    jsr       scroll_sprite_X
    bra       add_obj_handler

* centre of Garu Barra
garu_barra_handler: | $1ADD
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       explode_and_remove_object         | yes, go
    jsr       scroll_sprite_X
    bra       add_obj_handler
        
* Zolbak (Detector Dome / Skylight) 200 pts
* - when destroyed, reduces enemy AI by 2
handle_1F_Zolbak: | $1AF0
    move.b    #2,(_STATE,a5)
    clr.b     (_ATTR,a5)
    move.b    #0x1f,(_CODE,a5)
    move.b    #21,(_PTS,a5)                     | 200 pts
    jsr       save_PC_to_fn_tbl_and_ret
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       reduce_enemy_ai_by_2
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    jsr       scroll_sprite_X
    bra       add_obj_handler

reduce_enemy_ai_by_2: | $1B1F
    move.b    (enemy_AI_level),d0
    subq.b    #2,d0
    bcc       1f
    moveq     #0,d0
1:  move.b    d0,(enemy_AI_level)
    bra       handle_bomb_explosion

* Logram (Sphere Station) 300 pts
* - fire frequency set by $81A3
handle_26_Logram: | $1B2D
    move.b    (ffreq_mask_logram),(_FFREQ,a5)
    bra       handle_logram_init
    
handle_19_Logram_unused: | $1B45

handle_logram_init: | $1B49
    move.b    #2,(_STATE,a5)
    clr.b     (_ATTR,a5)                        | size=0
    move.b    #0x2c,(_CODE,a5)
    move.b    #27,(_PTS,a5)                     | 300 pts
    jsr       pseudo_random_gen
    and.b     (_FFREQ,a5),d0                    | scale with mask
    addq.b    #1,d0
    move.b    d0,(_TIMER,a5)                    | init timer
    jsr       save_PC_to_fn_tbl_and_ret

handle_logram_main: | $1B64
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       handle_bomb_explosion
    move.b    (gnd_stop_firing_row),d0          | MSB
    cmp.b     (_X,a5),d0                        | MSB, too low to fire?
    bcs       handle_logram_exit                | yes, exit
    move.b    (countup_timer_1),d0
    and.b     #7,d0
    bne       set_logram_colour
    subq.b    #1,(_TIMER,a5)                    | dec timer
    bne       set_logram_colour
    SET_REENTRY_ADDR_HERE
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       handle_bomb_explosion
    addq.b    #1,(_TIMER,a5)                    | inc timer
    move.b    (_TIMER,a5),d0
    cmp.b     #0x0c,d0                          | time to fire?
    bne       1f                                | no, skip
    jsr       init_new_bullet
    move.b    (_TIMER,a5),d0
1:  lsr.b     #2,d0
    and.w     #7,d0
    cmp.b     #7,d0
    beq       start_logram_shot_timer
    movea.l   #logram_sprite_anim_tbl,a0
    move.b    (a0,d0.w),(_CODE,a5)

set_logram_colour: | $1BB9
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    jsr       scroll_sprite_X
    bra       add_obj_handler

start_logram_shot_timer: | $1BC9
    jsr       pseudo_random_gen
    and.b     (_FFREQ,a5),d0
    addq.b    #1,d0
    move.b    d0,(_TIMER,a5)
    SET_REENTRY_ADDR handle_logram_main
    bra       set_logram_colour
    
handle_logram_exit: | $1BDC
    SET_REENTRY_ADDR_HERE
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       handle_bomb_explosion
    jsr       scroll_sprite_X
    bra       add_obj_handler

| sprite codes for when firing
logram_sprite_anim_tbl: | $1BF9
    .byte 0x2C
    .byte 0x2D
    .byte 0x2E
    .byte 0x2F
    .byte 0x2E
    .byte 0x2D
    .byte 0x2C
    .align 2

* Derota (Rook) 1,000 pts
handle_1B_Derota: | $1C00
    move.b    (ffreq_mask_derota),(_FFREQ,a5)
    bra       init_derota

* handle_1C_Derota_81B0_unused:
* handle_1A_Derota_unused:
    
init_derota: | $1C1C
    move.b    #2,(_STATE,a5)
    clr.b     (_ATTR,a5)                        | size=1x1
    move.b    #0x27,(_CODE,a5)
    move.b    #48,(_PTS,a5)                     | 1,000 pts
    jsr       pseudo_random_gen
    and.b     (_FFREQ,a5),d0                    | scale with mask
    addq.b    #1,d0
    move.b    d0,(_TIMER,a5)                    | init timer
    jsr       save_PC_to_fn_tbl_and_ret
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       handle_bomb_explosion             | yes, go
    move.b    (_X,a5),d0                        | MSB
    move.b    (gnd_stop_firing_row),d1
    cmp.b     d0,d1                             | stop firing?
    bcs       1f
    jsr       chk_timer_fire_bullet_reinit_timer    | no
1:  move.b    (pulsing_colour_1),(_COLOUR,a5)
    jsr       scroll_sprite_X
    bra       add_obj_handler

* Garu Derota (Daiza) 2,000 pts
handle_21_Garu_Derota: | $1C61
    move.b    #3,(_STATE,a5)                    | can't be destroyed
    move.b    #3,(_ATTR,a5)                     | size=2x2
    move.w    #_OBJSIZE,d5
    move.b    #2,(_STATE,a5,d5.w)               | 2nd object
    clr.b     (_ATTR,a5,d5.w)                   | size=1x1
    move.b    #1,(_X,a5,d5.w)                   | MSB
    move.w    (_Y,a5),d0                        | 1st object spriteY
    sub.w     #0x0100,d0                        | adjust
    move.w    d0,(_Y,a5,d5.w)                   | 2nd object spriteY
    move.b    #0x27,(_CODE,a5,d5.w)
    move.b    #54,(_PTS,a5,d5.w)                | 2,000 pts
    move.b    #0x44,(_CODE,a5)                  | 1st object
    move.b    (ffreq_mask_derota),(_FFREQ,a5,d5.w)
    jsr       pseudo_random_gen                 | random shot timer
    and.b     (_FFREQ,a5,d5.w),d0               | scale with mask
    addq.b    #1,d0
    move.b    d0,(_TIMER,a5,d5.w)               | init timer
    movea.l   #garu_derota_handler,a0
    move.l    a0,(4,a6)                         | patch handler next object
    SET_REENTRY_ADDR_HERE
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    jsr       scroll_sprite_X
    bra       add_obj_handler   

garu_derota_handler: | $1CBE
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       explode_and_remove_object
    jsr       chk_timer_fire_bullet_reinit_timer
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    jsr       scroll_sprite_X
    bra       add_obj_handler   
    
* Boza Logram (Dome Array) 2,000 pts
* - this function creates another 4 objects
*   and initialises them all, patching the
*   handlers into the object handler function table
* 2,000 pts if the centre is hit first (all lograms destroyed)
* 300 pts for each logram hit (before centre)
* 600 ptr for cente after any logram hit first
handle_2D_Boza_Logram: | $1CDE
    * patch 5 handler functions into table
    movea.l   #boza_logram_handler_tbl,a0
    movea.l   a6,a1                             | copy this fn entry address
    moveq     #5-1,d7
1:  move.l    (a0)+,(a1)+                       | patch handler address
    dbf       d7,1b
    * initialise state, attr for all objects
    move.b    #2,(_STATE,a5)
    clr.b     (_ATTR,a5)                        | size=1x1
    lea       (_OBJSIZE,a5),a1                  | 2nd object
    move.l    a1,a2                             | make a copy
    moveq     #4-1,d7                           | 4 objects to fill
2:  move.w    (_STATE,a5),(_STATE,a1)           | copy state, attr
    adda.l    #_OBJSIZE,a1                      | next object
    dbf       d7,2b
    * patch ptr to centre object into outer object tables
    * so the points value of the centre can be updated
    * if an outer logram is hit (first)
    suba.l    #_OBJSIZE,a1                      | address object 5 (centre)
    move.l    a5,a0                             | 1st object
    moveq     #4-1,d7                           | 4 entries to fill
3:  move.l    a1,(_EXTRA,a0)
    adda.l    #_OBJSIZE,a0
    dbf       d7,3b
    * initialise the spriteX values of all objects
    * from a table in ROM
    movea.l   a5,a1                             | 1st object
    movea.l   #boza_logram_spriteX_tbl,a0
    moveq     #5-1,d7                           | 5 entries to copy
4:  move.w    (a0)+,(_X,a1)
    adda.l    #_OBJSIZE,a1
    dbf       d7,4b
    * initialise the spriteY value of all objects
    * calculated from the spriteY value of the 1st object
    move.w    (_Y,a5),d0                        | spriteY
    move.w    d0,d1                             | copy
    add.w     #0x0180,d1                        | adjust
    move.w    d1,(_Y,a2)                        | 2nd object
    adda.l    #_OBJSIZE,a2                      | 3rd object
    move.w    d0,d1
    sub.w     #0x180,d1                         | adjust
    move.w    d1,(_Y,a2)
    adda.l    #_OBJSIZE,a2                      | 4th object
    move.w    d0,(_Y,a2)
    adda.l    #_OBJSIZE,a2                      | 5th object
    move.w    d0,(_Y,a2)
    rts

    .align 4
boza_logram_handler_tbl: | $1D47
    .long handle_boza_logram_outer
    .long handle_boza_logram_outer
    .long handle_boza_logram_outer
    .long handle_boza_logram_outer
    .long handle_boza_logram_centre

boza_logram_spriteX_tbl: | $1D51
    .word 0, 0x180, 0x180, 0x300, 0x180
    
handle_boza_logram_centre: | $1D5B
    move.b    #0x3a,(_CODE,a5)
    move.b    #54,(_PTS,a5)                     | 2,000 pts
    SET_REENTRY_ADDR_HERE
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       destroy_all_outer_lograms         | yes, go
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    jsr       scroll_sprite_X
    bra       add_obj_handler
    
destroy_all_outer_lograms: | $1D8A
    move.l    a5,a1
    move.b    #3,d0                             | state=3
    suba.l    #_OBJSIZE,a1
    move.b    d0,(_STATE,a1)                    | outer 4
    suba.l    #_OBJSIZE,a1
    move.b    d0,(_STATE,a1)                    | outer 3
    suba.l    #_OBJSIZE,a1
    move.b    d0,(_STATE,a1)                    | outer 2
    suba.l    #_OBJSIZE,a1
    move.b    d0,(_STATE,a1)                    | outer 1
    bra       handle_bomb_explosion   

handle_boza_logram_outer: | $1D9E
    move.b    #0x2c,(_CODE,a5)
    move.b    #27,(_PTS,a5)                     | 300 pts
    move.b    (ffreq_mask_boza_logram),(_FFREQ,a5)
    jsr       pseudo_random_gen
    and.b     (_FFREQ,a5),d0                    | scale with mask
    addq.b    #1,d0
    move.b    d0,(_TIMER,a5)                    | init shot timer
    jsr       save_PC_to_fn_tbl_and_ret

boza_logram_outer_main: | $1DBB
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       update_centre_points_value        | yes, go
    move.b    (gnd_stop_firing_row),d0
    cmp.b     (_X,a5),d0                        | too low to fire?
    bcs       boza_logram_outer_idle            | yes, skip
    move.b    (countup_timer_1),d0
    and.b     #7,d0                             | time to dec timer?
    bne       pulse_boza_logram_outer           | no, go
    subq.b    #1,(_TIMER,a5)                    | time for fire?
    bne       pulse_boza_logram_outer           | no, go
    SET_REENTRY_ADDR_HERE
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       update_centre_points_value        | yes, go
    addq.b    #1,(_TIMER,a5)
    move.b    (_TIMER,a5),d0
    cmp.b     #0x0c,d0                          | time to shoot?
    bne       1f                                | no, skip
    jsr       init_new_bullet
    move.b    (_TIMER,a5),d0
1:  lsr.b     #2,d0
    and.b     #7,d0
    cmp.b     #7,d0                             | start next shot timer?
    beq       boza_logram_init_shot_timer       | yes, go
    movea.l   #boza_logram_outer_sprite_tbl,a0
    move.b    (a0,d0.w),(_CODE,a5)

pulse_boza_logram_outer: | $1E0E
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    jsr       scroll_sprite_X
    bra       add_obj_handler

update_centre_points_value: | $1E1E
    move.l    (_EXTRA,a5),a0
    move.b    #36,(_PTS,a0)                     | 600 pts
    bra       handle_bomb_explosion

boza_logram_init_shot_timer: | $1E2B
    jsr       pseudo_random_gen
    and.b     (_FFREQ,a5),d0                    | scale with mask
    addq.b    #1,d0
    move.b    d0,(_TIMER,a5)                    | init shot timer
    SET_REENTRY_ADDR boza_logram_outer_main
    bra       pulse_boza_logram_outer
    
boza_logram_outer_idle: | $1E3E
    SET_REENTRY_ADDR_HERE
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       update_centre_points_value
    jsr       scroll_sprite_X
    bra       add_obj_handler

boza_logram_outer_sprite_tbl: | $1E5A
    .byte 0x2C, 0x2D, 0x2E, 0x2F, 0x2E, 0x2D, 0x2C
    .align 2
    
* Sol Tower (Citadel) 2,000/2,000 pts
* - hidden, scored when hit (appears)
* - scored again when destroyed
handle_1D_Sol_Tower: | $1E61
    move.b    #2,(_STATE,a5)
    clr.b     (_ATTR,a5)                        | bank=0,size=1x1
    .ifeq OPT_REVEAL_SOL_TOWER
    clr.b     (_CODE,a5)                        | invisible
    .else
    move.b    #0xb6,(_CODE,a5)
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    .endif
    move.b    #54,(_PTS,a5)                     | 2,000 pts
    jsr       save_PC_to_fn_tbl_and_ret
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       handle_sol_tower_rising           | yes, go
    jsr       scroll_sprite_X
    bra       add_obj_handler

handle_sol_tower_rising: | $1E85
    move.b    #0xff,(_TIMER,a5)                 | init timer
    SET_REENTRY_ADDR_HERE
    addq.b    #1,(_TIMER,a5)                    | inc timer
    move.b    (_TIMER,a5),d0
    lsr.b     #4,d0
    and.b     #7,d0
    cmp.b     #7,d0
    beq       sol_tower_risen
    cmp.b     #4,d0
    bne       1f
    move.b    #3,(_ATTR,a5)                     | size=2x2
1:  movea.l   #sol_tower_animation_tbl,a0
    move.b    (a0,d0.w),(_CODE,a5)
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    jsr       scroll_sprite_X
    bra       add_obj_handler

sol_tower_risen: | $1EC8
    move.b    #2,(_STATE,a5)
    SET_REENTRY_ADDR_HERE
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       handle_bomb_explosion             | yes, go
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    jsr       scroll_sprite_X
    bra       add_obj_handler
    
* these are sprite codes for the Sol Tower as it rises
sol_tower_animation_tbl: | $1EF1
    .byte 0xA8
    .byte 0xA9
    .byte 0xAA
    .byte 0xAB
    .byte 0xAE
    .byte 0xB2
    .byte 0xB6
    .align 2

* Brag Spario, 500 pts
* - released by Garu Zakato (big bomb) when it explodes
handle_09_Brag_Spario: | $1EF8
    move.b    #2,(_STATE,a5)
    move.b    #0x15,(_CODE,a5)
    move.b    #0x26,(_COLOUR,a5)
    move.b    #33,(_PTS,a5)                     | 500 pts
    jsr       save_PC_to_fn_tbl_and_ret
    move.b    #2,(_STATE,a5)                    | again?
    clr.w     d0                                | init ddX=0
    movea.l   #obj_tbl+_OBJSIZE*0x23,a1         | Solvalou
    move.b    (_X,a1),d1                        | MSB
    cmp.b     (_X,a5),d1                        | MSB
    bcs       brag_spario_ddX_sub_2
    beq       brag_spario_update_ddX
    addq.w    #2,d0                             | ddX=2
    
brag_spario_update_ddX: | $1F23
* only storing ddX to use further down
    move.w    d0,(_ddX,a5)
    clr.w     d0                                | init ddY=0
    move.b    (_Y,a1),d1                        | MSB
    cmp.b     (_Y,a5),d1                        | MSB
    bcs       brag_spario_ddY_sub_2
    beq       brag_spario_update_dY
    addq.w    #2,d0                             | ddY=2
    
 brag_spario_update_dY: | $1F33
 * note it doesn't store ddY
    add.w     d0,(_dY,a5)                       | update dY
    move.w    (_ddX,a5),d0
    add.w     d0,(_dX,a5)                       | update dX
    move.b    (countup_timer_1),d0
    and.b     #0x0c,d0                          | flipy,flipx
    add.b     #0x80,d0                          | bank=1
    move.b    d0,(_ATTR,a5)
    jsr       move_object_dX_dY
    bra       add_obj_handler

brag_spario_ddX_sub_2: | $1F54
    subq.w    #2,d0
    bra       brag_spario_update_ddX
    
brag_spario_ddY_sub_2: | $1F58
    subq.w    #2,d0
    bra       brag_spario_update_dY

handle_54_Bonus_Flag: | $1F5C
    move.b    #2,(_STATE,a5)
    clr.b     (_ATTR,a5)                        | size=1x1
    jsr       gen_rnd_spriteY
    clr.b     (_CODE,a5)                        | invisible
    move.b    #48,(_PTS,a5)                     | 1,000 pts
    SET_REENTRY_ADDR_HERE
    .ifne OPT_REVEAL_BONUS_FLAG   
    bra       reveal_bonus_flag
    .endif
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       reveal_bonus_flag                 | yes, go   
    jsr       scroll_sprite_X
    bra       add_obj_handler

reveal_bonus_flag: | $1F8D
    move.b    #0x80,(_ATTR,a5)                  | bank=1
    move.b    #0x0e,(_COLOUR,a5)
    move.b    #0x1f,(_CODE,a5)
    jsr       save_PC_to_fn_tbl_and_ret
    jsr       check_flag_collected
    bcs       score_bonus_flag
    jsr       scroll_sprite_X
    bra       add_obj_handler

score_bonus_flag: | $1FA8
    btst.b    #1,(dswb)
    bne       inc_num_solvalou
    movea.l   #pts_10000,a0
    jsr       add_to_score
    bra       remove_bonus_flag

inc_num_solvalou: | $1FB7
    addq.b    #1,(curr_player_solvalou_left)
    jsr       display_solvalou_left
    ** fall thru
    
remove_bonus_flag: | $1FC3
    clr.b     (_STATE,a5)
    clr.b     (_TYPE,a5)
    bra       add_obj_handler
    
check_flag_collected: | $1FD6
    move.b    (sprite_shadow_msb+2*0x23+0),d3   | solvolou spriteY
    sub.b     (sprite_shadow_msb+2*0x00+0),d3           
    sub.b     #0x0a,d3
    add.b     #0x14,d3
    bcc       9f
    move.b    (sprite_shadow_msb+2*0x23+1),d4   | solvalou spriteX[8:1]
    sub.b     (sprite_shadow_msb+2*0x00+1),d4
    subq.b    #5,d4
    add.b     #0x0a,d4
9:  rts

* Toroid (Fleet/Coin) 30 pts
handle_0A_Toroid: | $2000
    jsr       init_toroid
    jsr       save_PC_to_fn_tbl_and_ret
    jsr       is_close_to_solvalou_Y
    bcs       toroid_toggle_dir
    
handle_toroid:
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    jsr       move_object_dX_dY
    bra       add_obj_handler

* Toroid (Fleet/Coin) 30 pts
handle_0B_Toroid_shoots: | $2018
    jsr       init_toroid
    jsr       save_PC_to_fn_tbl_and_ret
    jsr       is_close_to_solvalou_Y
    bcs       init_toroid_shot
    bra       handle_toroid

* d0=spriteY (MSB)        
toroid_toggle_dir:
    subq.b    #2,d0
    bcs       toroid_pre_swing_left
    
toroid_pre_swing_right:
    SET_REENTRY_ADDR_HERE
    
toroid_swing_right:
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       flying_enemy_hit                  | yes, go
    addq.b    #1,(_TIMER,a5)                    | inc timer
    move.b    (_TIMER,a5),d0
    lsr.b     #1,d0
    and.w     #7,d0
    movea.l   #toroid_sprite_tbl,a0
    move.b    (a0,d0.w),(_CODE,a5)
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    subq.w    #1,(_dY,a5)
    jsr       move_object_dX_dY
    bra       add_obj_handler

toroid_pre_swing_left: | $205F
    SET_REENTRY_ADDR_HERE
    
toroid_swing_left: | $205F
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       flying_enemy_hit                  | yes, go
    addq.b    #1,(_TIMER,a5)                    | inc timer
    move.b    (_TIMER,a5),d0
    lsr.b     #1,d0
    and.w     #7,d0
    addq.b    #8,d0
    move.b    d0,(_CODE,a5)
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    addq.w    #1,(_dY,a5)
    jsr       move_object_dX_dY
    bra       add_obj_handler
    
init_toroid_shot: | $2092
    move.l    d0,-(a7)
    move.w    sr,-(a7)                          | save C
    jsr       init_new_bullet
    move.w    (a7)+,sr                          | restore C
    move.l    (a7)+,d0
    subq.b    #2,d0
    bcs       toroid_pre_swing_left
    bra       toroid_pre_swing_right

toroid_sprite_tbl: | $209F
    .byte 0xF, 0xE, 0xD, 0xC, 0xB, 0xA, 9, 8

init_toroid: | $20A7
    move.b    #2,(_STATE,a5)
    clr.b     (_ATTR,a5)                        | bank=0, size=1x1
    jsr       gen_rnd_spriteY
    movea.l   #angle_dX_dY_toroid_tbl,a2
    jsr       calc_dX_dY_for_vector_to_solvalou
    move.b    #6,(_PTS,a5)                      | 30 pts
    move.b    #8,(_CODE,a5)
    clr.b     (_TIMER,a5)                       | init timer
    rts

is_close_to_solvalou_Y: | $20CB
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       loc_20E2                          | yes, go
    move.b    (obj_tbl+_OBJSIZE*0x23+_Y),d0     | solvalou spriteY MSB
    sub.b     (_Y,a5),d0
    subq.b    #2,d0
    addq.b    #4,d0                             | C=close
    rts

loc_20E2: | $20E2
    adda.l    #4,a7                             | bypass caller
    bra       flying_enemy_hit
            
* Torkan (Scout Ship/Beetle) - 50 pts   
handle_0F_Torkan: | $20E7
    move.b    #2,(_STATE,a5)
    clr.b     (_ATTR,a5)                        | size=1x1
    jsr       gen_random_Y_store_obj
    movea.l   #angle_dX_dY_tbl,a2
    jsr       calc_dX_dY_for_vector_to_solvalou
    move.b    #9,(_PTS,a5)                      | 50 pts
    move.b    #0x10,(_CODE,a5)
    jsr       pseudo_random_gen                 | rnd shot timer
    and.b     #0x3f,d0
    add.b     #0x40,d0
    move.b    d0,(_TIMER,a5)                    | init timer
    jsr       save_PC_to_fn_tbl_and_ret
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       flying_enemy_hit                  | yes, go
    subq.b    #1,(_TIMER,a5)                    | time to shoot?
    beq       torkan_shoot                      | yes, go
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    jsr       move_object_dX_dY   
    bra       add_obj_handler
    
torkan_shoot: | $2131
    jsr       init_new_bullet
    SET_REENTRY_ADDR_HERE
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       flying_enemy_hit                  | yes, go
    addq.b    #1,(_TIMER,a5)
    move.b    (_TIMER,a5),d0
    lsr.b     #2,d0
    and.b     #0x0f,d0
    cmp.b     #7,d0
    beq       loc_2169
    add.b     #0x10,d0
    move.b    d0,(_CODE,a5)                     | animate sprite
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    jsr       scroll_sprite_X        
    bra       add_obj_handler

loc_2169: | $2169
    movea.l   #obj_tbl+_OBJSIZE*0x23,a1         | solvalou
    move.b    (_X,a1),d0                        | MSB
    sub.b     (_X,a5),d0                        | MSB
    move.b    (_Y,a1),d1                        | MSB
    sub.b     (_Y,a5),d1                        | MSB
    jsr       get_index_for_angle
    movea.l   #angle_dX_dY_terrazi_torkan_tbl,a2
    add.b     #0x80,d2
    jsr       get_dX_dY_and_cpy_to_obj
    SET_REENTRY_ADDR_HERE
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       flying_enemy_hit                  | yes, go
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    jsr       move_object_dX_dY
    bra       add_obj_handler

* Zoshi (Octopus) 100 pts
handle_0E_Zoshi: | $21B1
    move.b    #2,(_STATE,a5)
    clr.b     (_ATTR,a5)                        | bank=0,size=1x1
    move.b    #40,(_X,a5)
    jsr       gen_rnd_spriteY
    bra       zoshi_0D_init_cont

* Zoshi (Octopus) 100 pts
handle_0D_Zoshi: | $21C4
    move.b    #2,(_STATE,a5)
    clr.b     (_ATTR,a5)                        | bank=0,size=1x1
    jsr       gen_random_Y_store_obj
    
zoshi_0D_init_cont: | $21D3
    movea.l   #angle_dX_dY_toroid_tbl,a2
    jsr       calc_dX_dY_for_vector_to_solvalou
    move.b    #15,(_PTS,a5)                     | 100 pts
    move.b    (ffreq_mask_zoshi),(_FFREQ,a5)
    jsr       pseudo_random_gen
    and.b     d0,(_FFREQ,a5)                    | scale with mask
    addq.b    #1,d0
    move.b    d0,(_TIMER,a5)                    | init shot timer
    jsr       save_PC_to_fn_tbl_and_ret
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       flying_enemy_hit                  | yes, go
    move.b    (countup_timer_1),d0
    and.w     #7,d0
    bne       zoshi_0D_main
    subq.b    #1,(_TIMER,a5)                    | time to shoot?
    bne       zoshi_0D_main                     | no, go
    jsr       pseudo_random_gen                 | random shot timer
    and.b     (_FFREQ,a5),d0                    | scale with mask  
    addq.b    #1,d0
    move.b    d0,(_TIMER,a5)                    | re-init shot timer
    movea.l   #angle_dX_dY_toroid_tbl,a2
    jsr       calc_dX_dY_for_vector_to_solvalou
    jsr       init_new_bullet
    
zoshi_0D_main: | $221E
    move.b    (countup_timer_1),d0
    and.w     #3,d0
    add.b     #0x28,d0
    move.b    d0,(_CODE,a5)
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    jsr       move_object_dX_dY
    bra       add_obj_handler

* Zoshi (Octopus) 70 pts
handle_0C_Zoshi: | $2235
    move.b    #2,(_STATE,a5)
    clr.b     (_ATTR,a5)                        | bank=0, size=1x1
    jsr       gen_random_Y_store_obj
    movea.l   #angle_dX_dY_toroid_tbl,a2
    jsr       calc_dX_dY_for_vector_to_solvalou
    move.b    #12,(_PTS,a5)                     | 70 pts
    move.b    (ffreq_mask_zoshi),(_FFREQ,a5)
    jsr       pseudo_random_gen                 | random shot timer
    and.b     (_FFREQ,a5),d0                    | scale with mask
    addq.b    #1,d0
    move.b    d0,(_TIMER,a5)                    | init shot timer
    jsr       save_PC_to_fn_tbl_and_ret
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       flying_enemy_hit                  | yes, go
    move.b    (countup_timer_1),d0
    and.w     #7,d0
    bne       zoshi_0C_main
    subq.b    #1,(_TIMER,a5)                    | time to shoot?
    bne       zoshi_0C_main                     | no, go
    jsr       pseudo_random_gen                 | random shot timer
    and.b     (_FFREQ,a5),d0                    | scale with mask  
    addq.b    #1,d0
    move.b    d0,(_TIMER,a5)                    | re-init shot timer
    jsr       pseudo_random_gen
    movea.l   #angle_dX_dY_toroid_tbl,a2
    jsr       get_dX_dY_and_cpy_to_obj
    jsr       init_new_bullet
    
zoshi_0C_main: | $2294
    move.b    (countup_timer_1),d0
    and.w     #3,d0
    add.b     #0x28,d0
    move.b    d0,(_CODE,a5)
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    jsr       move_object_dX_dY
    bra       add_obj_handler
      
handle_56_Jara: | $22AC
    jsr       jara_init
    jsr       save_PC_to_fn_tbl_and_ret
    jsr       jara_check_proximity              | close to solvalou?
    bcs       jara_set_dir                      | yes, go
    
loc_22B5: | $22B5
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    jsr       move_object_dX_dY    
    bra       add_obj_handler

jara_set_dir: | $22C4
    subq.b    #6,d0
    bcs       jara_moving_left
    
jara_moving_right: | $22C8
    SET_REENTRY_ADDR_HERE
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       flying_enemy_hit                  | yes, go
    addq.b    #1,(_TIMER,a5)
    move.b    (_TIMER,a5),d0
    lsr.b     #1,d0
    and.w     #7,d0
    cmp.b     #6,d0
    bne       1f
    moveq     #0,d0
    move.b    d0,(_TIMER,a5)                    | reinit timer    
1:  movea.l   #jara_56_sprite_tbl,a0
    move.b    (a0,d0.w),(_CODE,a5)
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    subq.w    #1,(_dY,a5)
    jsr       move_object_dX_dY
    bra       add_obj_handler

* Jara (Spinner) 150 pts
handle_55_Jara: | $2306
    jsr       jara_init
    jsr       save_PC_to_fn_tbl_and_ret
    jsr       jara_check_proximity              | close to solvalou?
    bcs       jara_shoot                        | yes, go
    bra       loc_22B5
    
jara_shoot: | $2311
    move.l    d0,-(a7)
    jsr       init_new_bullet
    move.l    (a7)+,d0
    subq.b    #6,d0
    bcs       jara_moving_left
    bra       jara_moving_right
    
jara_moving_left: | $231E
    SET_REENTRY_ADDR_HERE
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       flying_enemy_hit                  | yes, go
    addq.b    #1,(_TIMER,a5)
    move.b    (_TIMER,a5),d0
    lsr.b     #1,d0
    and.w     #7,d0
    cmp.b     #6,d0
    bne       1f
    moveq     #0,d0
    move.b    d0,(_TIMER,a5)                    | re-init timer
1:  movea.l   #jara_55_sprite_tbl,a0
    move.b    (a0,d0.w),(_CODE,a5)
    move.b    (pulsing_colour_1),(_CODE,a5)
    addq.w    #1,(_dY,a5)
    jsr       move_object_dX_dY
    bra       add_obj_handler
    
jara_56_sprite_tbl: | $235C
    .byte 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5
    
jara_55_sprite_tbl: | $2362
    .byte 0xA5, 0xA4, 0xA3, 0xA2, 0xA1, 0xA0

jara_init: | $2368
    move.b    #2,(_STATE,a5)
    clr.b     (_ATTR,a5)                        | bank=0, size=1x1
    jsr       gen_rnd_spriteY
    movea.l   #angle_dX_dY_terrazi_torkan_tbl,a2
    jsr       calc_dX_dY_for_vector_to_solvalou
    move.b    #18,(_PTS,a5)                     | 150 pts
    move.b    #0xa0,(_CODE,a5)
    clr.b     (_TIMER,a5)                       | init anim timer
    rts

jara_check_proximity: | $238C
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       jara_hit
    move.b    (obj_tbl+_OBJSIZE*0x23+_Y),d0     | solvalou spriteY MSB
    sub.b     (_Y,a5),d0                        | MSB
    subq.b    #6,d0
    add.b     #0x0c,d0
    rts
    
jara_hit: | $23A3
    adda.l    #4,a7                             | bypass caller
    bra       flying_enemy_hit
    
* Kapi (Rhombus) 300 pts
handle_10_Kapi: | $23A8
    move.b    #2,(_STATE,a5)
    clr.b     (_ATTR,a5)                        | size=1x1
    jsr       gen_random_Y_store_obj
    movea.l   #angle_dX_dY_tbl,a2
    jsr       calc_dX_dY_for_vector_to_solvalou
    move.b    #27,(_PTS,a5)                     | 300 pts
    move.b    #0x20,(_CODE,a5)
    jsr       pseudo_random_gen
    add.b     #63,d0
    add.b     #48,d0                            | 48-111
    move.b    d0,(_TIMER,a5)                    | init shot timer
    move.b    (ffreq_mask_kapi),(_FFREQ,a5)
    jsr       save_PC_to_fn_tbl_and_ret
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       flying_enemy_hit                  | yes, go
    subq.b    #1,(_TIMER,a5)                    | time to shoot?
    beq       kapi_10_fire                      | yes, g0
    move.b    (pulsing_colour_1),(_COLOUR,a5)   
    jsr       move_object_dX_dY   
    bra       add_obj_handler

kapi_10_fire: | $23F7
    clr.b     (_TIMER1,a5)
    move.w    #1,d1
    movea.l   #obj_tbl+_OBJSIZE*0x23,a0
    move.b    (_Y,a0),d0                        | MSB
    cmp.b     (_Y,a5),d0                        | compare
    bcs       1f
    move.w     #-1,d1
1:  move.w    d1,(_ddY,a5)
    move.b    #1,(_TIMER,a5)
    jsr       chk_timer_fire_bullet_reinit_timer
    SET_REENTRY_ADDR_HERE
    cmp.b     #3,(_STATE,a5)
    beq       flying_enemy_hit
    jsr       chk_timer_fire_bullet_reinit_timer
    addq.b    #1,(_TIMER1,a5)
    move.b    (_TIMER1,a5),d0
    lsr.b     #3,d0
    and.b     #7,d0
    cmp.b     #7,d0
    beq       loc_2455
    add.b     #32,d0
    move.b    d0,(_CODE,a5)
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    move.w    (_ddY,a5),d0
    add.w     d0,(_dY,a5)
    subq.w    #2,(_dX,a5)
    jsr       move_object_dX_dY   
    bra       add_obj_handler

loc_2455: | $2455
    SET_REENTRY_ADDR_HERE
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       flying_enemy_hit
    jsr       chk_timer_fire_bullet_reinit_timer
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    move.w    (_ddY,a5),d0
    add.w     d0,(_dY,a5)
    subq.w    #2,(_dX,a5)
    jsr       move_object_dX_dY   
    bra       add_obj_handler

* Terrazi (Limuroid), 700 pts    
handle_11_Terrazi: | $2487
    move.b    #2,(_STATE,a5)
    clr.b     (_ATTR,a5)                        | size=1x1
    jsr       gen_rnd_spriteY
    movea.l   #angle_dX_dY_terrazi_torkan_tbl,a2
    jsr       calc_dX_dY_for_vector_to_solvalou
    move.b    #39,(_PTS,a5)                     | 700 pts
    move.b    #1,(_CODE,a5)
    move.b    (ffreq_mask_terrazi),(_FFREQ,a5)
    jsr       pseudo_random_gen                 | random shot timer
    and.b     (_FFREQ,a5),d0                    | scale with mask
    move.b    d0,(_TIMER,a5)                    | init shot timer
    jsr       save_PC_to_fn_tbl_and_ret
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       flying_enemy_hit                  | yes, go
    movea.l   #obj_tbl+_OBJSIZE*0x23,a0
    move.b    (_Y,a0),d0                        | MSB
    sub.b     (_Y,a5),d0                        | object
    subq.b    #4,d0
    addq.b    #8,d0                             | too close to fire?
    bcs       terrazi_main_cont                 | yes, go
    jsr       chk_timer_fire_bullet_reinit_timer
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    jsr       move_object_dX_dY
    bra       add_obj_handler

terrazi_main_cont: | $24E2
    moveq     #2,d1
    subq.b    #4,d0
    bcs       1f
    move.w    #-2,d1
1:  move.w    d1,(_dY,a5)
    move.b    #0xff,(_TIMER,a5)                 | init timer
    SET_REENTRY_ADDR_HERE
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       flying_enemy_hit                  | yes, go
    jsr       chk_timer_fire_bullet_reinit_timer
    addq.w    #1,(_ddX,a5)
    move.w    (_ddX,a5),d0
    lsr.b     #3,d0
    and.b     #7,d0
    cmp.b     #7,d0
    beq       terrazi_main_cont_2
    addq.b    #1,d0
    move.b    d0,(_CODE,a5)
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    move.w    (_ddY,a5),d0
    add.w     d0,(_dY,a5)                       | update dY
    subq.w    #2,(_dX,a5)
    jsr       move_object_dX_dY
    bra       add_obj_handler    

terrazi_main_cont_2: | $2535
    SET_REENTRY_ADDR_HERE
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       flying_enemy_hit                  | yes, go
    jsr       chk_timer_fire_bullet_reinit_timer
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    move.w    (_ddY,a5),d0
    add.w     d0,(_dY,a5)                       | update dY
    subq.w    #2,(_dX,a5)
    jsr       move_object_dX_dY
    bra       add_obj_handler    

* Zakato (Teleporter) 100 pts
handle_12_Zakato: | $2567
    jsr       init_teleport
    move.b    #15,(_PTS,a5)                     | 100 pts
    clr.w     (_dY,a5)
    move.w    #16,(_dX,a5)
    jsr       save_PC_to_fn_tbl_and_ret
    jsr       zakato_teleport
    bcc       zakato_12_main
    jsr       scroll_sprite_X
    bra       add_obj_handler    

zakato_12_main: | $257E
    jsr       pseudo_random_gen
    and.w     #0xff,d0
    add.b     #1,d0
    move.b    d0,(_TIMER,a5)
    move.b    #0x11,(_CODE,a5)
    move.b    #0x80,(_ATTR,a5)                  | bank=1, size=1x1
    move.b    #2,(_STATE,a5)
    SET_REENTRY_ADDR_HERE
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       flying_enemy_hit                  | yes, go   
    subq.b    #1,(_TIMER,a5)
    beq       zakato_shoot
    move.b    (pulsing_colour_2),(_COLOUR,a5)
    jsr       move_object_dX_dY
    bra       add_obj_handler

zakato_shoot: | $25B9
    move.b    #0xff,(_TIMER,a5)
    move.b    #3,(_STATE,a5)                    | destroyed
    jsr       init_new_bullet
    
zakato_explode_and_remove: | $25C2
    SET_REENTRY_ADDR_HERE
    jsr       zakato_explode
    bcc       remove_zakato
    jsr       scroll_sprite_X
    bra       add_obj_handler    

* Zakato (Teleporter) 200 pts
handle_13_Zakato: | $25D7
    jsr       init_teleport
    move.b    #21,(_PTS,a5)                     | 200 pts
    clr.b     (_dY,a5)                          | MSB
    move.b    #16,(_dX,a5)                      | MSB
    jsr       save_PC_to_fn_tbl_and_ret
    jsr       zakato_teleport
    bcc       zakato_13_main
    jsr       scroll_sprite_X
    bra       add_obj_handler    

zakato_13_main: | $25EE
    move.b    #0x11,(_CODE,a5)
    move.b    #0x80,(_ATTR,a5)                  | bank=1,size=1x1
    move.b    #2,(_STATE,a5)
    SET_REENTRY_ADDR_HERE
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       flying_enemy_hit                  | yes, go   
    move.b    (obj_tbl+_OBJSIZE*0x23+_Y),d0     | MSB
    sub.b     (_Y,a5),d0                        | MSB
    subq.b    #4,d0
    addq.b    #8,d0
    bcs       zakato_shoot
    move.b    (pulsing_colour_2),(_COLOUR,a5)
    jsr       move_object_dX_dY
    bra       add_obj_handler

* Zakato (Teleporter) 150 pts
handle_14_Zakato: | $262E
    jsr       init_teleport
    move.b    #18,(_PTS,a5)                     | 150 pts
    jsr       save_PC_to_fn_tbl_and_ret
    jsr       zakato_teleport
    bcc       zakato_14_main
    jsr       scroll_sprite_X
    bra       add_obj_handler    

zakato_14_main: | $263F
    jsr       pseudo_random_gen
    and.w     #0x3f,d0
    addq.b    #1,d0
    move.b    d0,(_TIMER,a5)                    | init shot timer
    move.b    #0x80,(_ATTR,a5)                  | bank=1,size=1x1
    move.b    #2,(_STATE,a5)
    movea.l   #angle_dX_dY_tbl,a2
    jsr       calc_dX_dY_for_vector_to_solvalou
    SET_REENTRY_ADDR_HERE
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       flying_enemy_hit                  | yes, go   
    subq.b    #1,(_TIMER,a5)                    | time to shoot?
    beq       zakato_shoot                      | yes, go    
    move.b    (pulsing_colour_2),(_COLOUR,a5)
    jsr       move_object_dX_dY
    bra       add_obj_handler

* Zakato (Teleporter) 300 pts
handle_15_Zakato: | $2684:
    jsr       init_teleport
    move.b    #27,(_PTS,a5)                     | 300 pts
    jsr       save_PC_to_fn_tbl_and_ret
    jsr       zakato_teleport
    bcc       zakato_15_main
    jsr       scroll_sprite_X
    bra       add_obj_handler    

zakato_15_main: | $2695
    move.b    #0x11,(_CODE,a5)
    move.b    #0x80,(_ATTR,a5)                  | bank=1,size=1x1
    move.b    #2,(_STATE,a5)
    movea.l   #angle_dX_dY_tbl,a2
    jsr       calc_dX_dY_for_vector_to_solvalou
    SET_REENTRY_ADDR_HERE
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       flying_enemy_hit                  | yes, go   
    move.b    (obj_tbl+_OBJSIZE*0x23+_Y),d0     | MSB
    sub.b     (_Y,a5),d0                        | MSB
    subq.b    #4,d0
    addq.b    #8,d0
    bcs       zakato_shoot
    move.b    (pulsing_colour_2),(_COLOUR,a5)
    jsr       move_object_dX_dY
    bra       add_obj_handler

* Brag Zakato (Cracker) 600 pts
handle_16_Brag_Zakato: | $26DF
    jsr       init_teleport
    move.b    #36,(_PTS,a5)                     | 600 pts
    jsr       save_PC_to_fn_tbl_and_ret
    jsr       zakato_teleport
    bcc       brag_zakato_16_main
    jsr       scroll_sprite_X
    bra       add_obj_handler    
    
brag_zakato_16_main: | $26F0
    jsr       pseudo_random_gen
    and.w     #0x3f,d0
    addq.b    #1,d0
    move.b    d0,(_TIMER,a5)                    | init shot timer
    move.b    #0x12,(_CODE,a5)
    movea.l   #angle_dX_dY_tbl,a2
    jsr       calc_dX_dY_for_vector_to_solvalou
    move.b    #2,(_STATE,a5)
    move.b    #0x80,(_ATTR,a5)                  | bank=1,size=1x1
    SET_REENTRY_ADDR_HERE
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       flying_enemy_hit                  | yes, go   
    subq.b    #1,(_TIMER,a5)                    | time to explode?
    beq       brag_zakato_explode               | yes, go
    move.b    (pulsing_colour_2),(_COLOUR,a5)
    jsr       move_object_dX_dY
    bra       add_obj_handler

* Brag Zakato (Cracker) 1,500 pts
handle_17_Brag_Zakato: | $2736
    jsr       init_teleport
    move.b    #51,(_PTS,a5)                     | 1,500 pts
    jsr       save_PC_to_fn_tbl_and_ret
    jsr       zakato_teleport
    bcc       brag_zakato_17_main
    jsr       scroll_sprite_X
    bra       add_obj_handler    
    
brag_zakato_17_main: | $2747
    move.b    #0x12,(_CODE,a5)
    movea.l   #angle_dX_dY_tbl,a2
    jsr       calc_dX_dY_for_vector_to_solvalou
    move.b    #2,(_STATE,a5)
    move.b    #0x80,(_ATTR,a5)                  | bank=1,size=1x1
    SET_REENTRY_ADDR_HERE
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       flying_enemy_hit                  | yes, go   
    move.b    (obj_tbl+_OBJSIZE*0x23+_Y),d0     | MSB
    sub.b     (_Y,a5),d0                        | MSB
    subq.b    #4,d0
    addq.b    #8,d0
    bcs       brag_zakato_explode
    move.b    (pulsing_colour_2),(_COLOUR,a5)
    jsr       move_object_dX_dY
    bra       add_obj_handler

brag_zakato_explode: | $2791
    move.b    #0xff,(_TIMER,a5)
    move.b    #3,(_STATE,a5)                    | too late to destroy
    jsr       brag_zakato_shoot
    bra       zakato_explode_and_remove
        
remove_zakato: | $279D
    clr.b     (_TYPE,a5)
    clr.b     (_STATE,a5)
    bra       add_obj_handler

zakato_explode: | $27A8
    addq.b    #1,(_TIMER,a5)
    move.b    (_TIMER,a5),d0
    cmp.b     #0x10,d0                          | time to expland sprite?
    bne       1f                                | no, skip
    subq.b    #1,(_X,a5)                        | MSB
    addq.b    #1,(_Y,a5)                        | MSB
1:  move.l    d0,d1                             | copy
    lsr.b     #2,d0
    and.w     #7,d0
    cmp.b     #5,d0                             | done?
    bcc       9f                                | yes, exit
    movea.l   #zakato_exploding_sprite_tbl,a0
    lsl.w     #1,d0
    move.b    (a0,d0.w),(_CODE,a5)
    lsl.b     #2,d1
    and.w     #0x0c,d1                          | xflip,yflip
    add.b     (1,a0,d0.w),d1                    | combine with bank,size
    ori.b     #(1<<0),ccr                       | set carry
9:  rts

* sprite (code, attr) pairs
zakato_exploding_sprite_tbl: | $27DB
    .byte 4, 0x80
    .byte 5, 0x80
    .byte 6, 0x80
    .byte 7, 0x80
    .byte 8, 0x83
    .byte 0xC, 0x83

zakato_teleport: | $27E7
    addq.b    #1,(_TIMER,a5)
    move.b    (_TIMER,a5),d0
    cmp.b     #8,d0
    bne       zakato_teleport_sparkles
    addq.b    #1,(_X,a5)                        | MSB
    subq.b    #1,(_Y,a5)                        | MSB
    
zakato_teleport_sparkles: | $27FB
    move.b    d0,d1                             | copy
    lsr.b     #2,d0
    and.w     #7,d0
    cmp.b     #5,d0
    bcc       9f
    movea.l   #zakato_teleport_sprite_tbl,a0
    lsl.w     #1,d0
    move.b    (a0,d0.w),(_CODE,a5)
    lsl.b     #2,d1
    and.w     #0x0c,d1                          | xflip,yflip
    add.b     (1,a0,d0.w),d1                    | combine with bank,size
    move.b    d1,(_ATTR,a5)
    ori.b     #(1<<0),ccr                       | set carry
9:  rts

* the sparkles that appear as it appears
zakato_teleport_sprite_tbl: | $281A
    .byte 0xC, 0x83
    .byte 8, 0x83
    .byte 7, 0x80
    .byte 6, 0x80
    .byte 5, 0x80
    .byte 4, 0x80

init_teleport: | $2826
    move.b    #3,(_STATE,a5)                    | indestructible
    jsr       pseudo_random_gen
    and.w     #0x0f,d0
    add.b     #5,d0
    move.b    d0,(_X,a5)                        | MSB
    jsr       gen_random_Y_store_obj
    add.b     #1,(_Y,a5)                        | MSB
    move.b    #0x24,(_COLOUR,a5)
    move.b    #0xff,(_TIMER,a5)                 | init timer
    *** TBD sound
    rts
    
* Garu Zakota (Bullseye) 1,000/500 pts
* - big exploding bomb preceding the later Andor Geneses
handle_18_Garu_Zakato: | $284C
    move.b    #2,(_STATE,a5)
    move.b    #0x80,(_ATTR,a5)                  | bank=1
    jsr       gen_random_Y_store_obj
    move.b    #0x13,(_CODE,a5)
    move.b    #48,(_PTS,a5)                     | 1,000 pts
    move.w    #48,(_dX,a5)
    clr.w     (_dY,a5)
    jsr       pseudo_random_gen
    and.b     #0x1f,d0                          | 0-31
    add.b     #32,d0                            | 32-63
    move.b    d0,(_TIMER,a5)                    | init timer
    jsr       save_PC_to_fn_tbl_and_ret
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       flying_enemy_hit                  | yes, go   
    subq.b    #1,(_TIMER,a5)                    | time to explode?
    beq       garu_zakato_explode               | yes, go
    move.b    (pulsing_colour_2),(_COLOUR,a5)
    jsr       move_object_dX_dY
    bra       add_obj_handler

garu_zakato_explode: | $2897
    jsr       init_garu_zakato_explosion
    *** TBD sound
    clr.b     (_TYPE,a5)
    clr.b     (_STATE,a5)
    bra       add_obj_handler

animate_r_sheonite_1: | $28C0
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    movea.l   #r_sheonite_code_tbl_1,a0
    move.b    (countup_timer_1),d0
    lsr.b     #1,d0
    and.w     #3,d0
    move.b    (a0,d0.w),(_CODE,a5)
    bra       move_object_dX_dY_2

r_sheonite_code_tbl_1: | $28D9
    .byte 0x32, 0x33, 0x30, 0x31

handle_31_right_sheonite: | $28DD
    move.b    #3,(_STATE,a5)                    | indestructible
    clr.b     (_ATTR,a5)                        | bank=0, size=0
    move.b    #0x30,(_Y,a5)                     | MSB
    jsr       save_PC_to_fn_tbl_and_ret
    movea.l   #obj_tbl+_OBJSIZE*0x23,a1         | solvalou
    move.b    (_X,a1),d0                        | MSB
    subq.b    #2,d0
    sub.b     (_X,a5),d0                        | MSB
    move.b    (_Y,a1),d1                        | MSB
    subq.b    #2,d1
    sub.b     (_Y,a5),d1                        | MSB
    jsr       get_index_for_angle
    movea.l   #angle_dX_dY_sheonite_tbl,a2
    jsr       get_dX_dY_and_cpy_to_obj
    move.b    (_X,a1),d0                        | solvalou X MSB
    subq.b    #2,d0
    cmp.b     (_X,a5),d0
    bne       animate_r_sheonite_1
    SET_REENTRY_ADDR_HERE
    tst.b     (countup_timer_1)
    bne       1f
    tst.b     (sheonite_end_flag)               | time to start retreating?
    bne       animate_r_sheonite_2
1:  jsr       set_r_sheonite_above_solvalou
    movea.l   #r_sheonite_code_tbl_1,a0
    move.b    (countup_timer_1),d0
    lsr.b     #1,d0
    and.w     #3,d0
    move.b    (a0,d0.w),(_CODE,a5)
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    rts

animate_r_sheonite_2: | $2950
    SET_REENTRY_ADDR_HERE
    jsr       set_r_sheonite_above_solvalou
    move.b    (countup_timer_1),d0
    lsr.b     #2,d0
    and.w     #7,d0
    cmp.b     #7,d0                             | still docking?
    beq       r_sheonite_combining                | yes, go
    movea.l   #r_sheonite_code_tbl_2,a0
    move.b    (a0,d0.w),(_CODE,a5)
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    rts

r_sheonite_code_tbl_2: | $2974
    .byte 0x32, 0x32, 0x32, 0x32, 0x34, 0x35, 0x36
    .align 2

r_sheonite_combining: | $297B
    move.b    #0xe0,(_TIMER,a5)                 | init timer
    SET_REENTRY_ADDR_HERE
    addq.b    #1,(_TIMER,a5)                    | time to retreat?
    beq       r_sheonite_retreat                | yes, go
    movea.l   #obj_tbl+_OBJSIZE*0x23,a1         | solvalou
    moveq     #0,d0
    move.b    (_TIMER,a5),d0
    ext.w     d0
    lsl.w     #3,d0                             | x8
    add.w     (_Y,a1),d0                        | calc spriteY
    move.w     d0,(_Y,a5)                       | update spriteY
    move.w    (_X,a1),d0
    sub.w     #0x0200,d0                        | calc spriteX
    move.w    d0,(_X,a5)                        | update spriteX
    move.b    (pulsing_colour_1),(_COLOUR,a5)    
    rts

r_sheonite_retreat: | $29B1
    movea.l   #obj_tbl+_OBJSIZE*0x23,a1         | solvalou
    move.w    (_X,a1),d0
    sub.w     #0x0200,d0
    move.w    d0,(_X,a5)                        | set object spriteX
    move.w    (_Y,a1),(_Y,a5)                   | set object spriteY
    clr.w     (_dY,a5)
    move.w    #0xFFA0,(_dX,a5)
    *** TBD sound
    SET_REENTRY_ADDR_HERE
    movea.l   #r_sheonite_code_tbl_1,a0
    move.b    (countup_timer_1),d0
    lsr.b     #1,d0
    and.w     #3,d0
    move.b    (a0,d0.w),(_CODE,a5)
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    jsr       move_object_dX_dY
    bra       add_obj_handler    

set_r_sheonite_above_solvalou: | $29F7
    movea.l   #obj_tbl+_OBJSIZE*0x23,a1         | solvalou
    move.w    (_X,a1),d0
    sub.w     #0x0200,d0
    move.w    d0,(_X,a5)
    move.w    (_Y,a1),d0
    sub.w     #0x0200,d0
    move.w    d0,(_Y,a5)
    rts

animate_l_sheonite_1: | $2A11
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    movea.l   #l_sheonite_code_tbl_1,a0
    move.b    (countup_timer_1),d0
    lsr.b     #1,d0
    and.w     #3,d0
    move.b    (a0,d0.w),(_CODE,a5)
    bra       move_object_dX_dY_2

l_sheonite_code_tbl_1: | $2A2A
    .byte 0x32, 0x31, 0x30, 0x33

handle_32_left_sheonite: | $2A2E
    move.b    #3,(_STATE,a5)                    | indestructible
    clr.b     (_ATTR,a5)                        | bank=0, size=1x1
    jsr       save_PC_to_fn_tbl_and_ret
    movea.l   #obj_tbl+_OBJSIZE*0x23,a1         | solvalou
    move.b    (_X,a1),d0                        | MSB
    subq.b    #2,d0
    sub.b     (_X,a5),d0                        | MSB
    move.b    (_Y,a1),d1                        | MSB
    addq.b    #2,d1
    sub.b     (_Y,a5),d1                        | MSB
    jsr       get_index_for_angle
    movea.l   #angle_dX_dY_sheonite_tbl,a2
    jsr       get_dX_dY_and_cpy_to_obj
    move.b    (_X,a1),d0                        | solvalou X MSB
    subq.b    #2,d0
    cmp.b     (_X,a5),d0
    bne       animate_l_sheonite_1
    move.b    (_Y,a1),d0                        | solvalou Y MSB
    addq.b    #2,d0
    cmp.b     (_Y,a5),d0                        | MSB
    bne       animate_l_sheonite_1
    SET_REENTRY_ADDR_HERE
    tst.b     (countup_timer_1)
    bne       1f
    tst.b     (sheonite_end_flag)
    bne       animate_l_sheonite_2
1:  jsr       set_l_sheonite_above_solvalou
    movea.l   #l_sheonite_code_tbl_1,a0
    move.b    (countup_timer_1),d0
    lsr.b     #1,d0
    and.w     #3,d0
    move.b    (a0,d0.w),(_CODE,a5)
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    rts

animate_l_sheonite_2: | $2A9D
    SET_REENTRY_ADDR_HERE
    jsr       set_l_sheonite_above_solvalou
    move.b    (countup_timer_1),d0
    lsr.b     #2,d0
    and.w     #7,d0
    cmp.b     #7,d0
    beq       l_sheonite_combining
    movea.l   #l_sheonite_code_tbl_2,a0
    move.b    (a0,d0.w),(_CODE,a5)
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    rts

l_sheonite_code_tbl_2: | $2AC1
    .byte 0x32, 0x32, 0x32, 0x32, 0x37, 0x38, 0x39
    .align 2
    
l_sheonite_combining: | $2AC8
    move.b    #0x20,(_TIMER,a5)                 | init timer
    SET_REENTRY_ADDR_HERE
    subq.b    #1,(_TIMER,a5)
    beq       l_sheonite_remove
    movea.l   #obj_tbl+_OBJSIZE*0x23,a1         | solvalou
    moveq     #0,d0
    move.b    (_TIMER,a5),d0
    lsl.w     #3,d0                             | x8
    add.w     (_Y,a1),d0                        | calc object spriteY
    move.w    d0,(_Y,a5)                        | update spriteY
    move.w    (_X,a1),d0                        | solvalou spriteX
    sub.w     #0x0200,d0                        | calc object spriteX
    move.w    d0,(_X,a5)                        | update spriteX
    move.b    (pulsing_colour_1),(_COLOUR,a5)    
    rts

l_sheonite_remove: | $2AFE
    clr.b     (_TYPE,a5)
    clr.b     (_STATE,a5)
    bra       add_obj_handler
         
set_l_sheonite_above_solvalou: | $2B09
    movea.l   #obj_tbl+_OBJSIZE*0x23,a1         | solvalou
    move.w    (_X,a1),d0
    sub.w     #0x0200,d0
    move.w    d0,(_X,a5)
    move.w    (_Y,a1),d0
    add.w     #0x0200,d0
    move.w    d0,(_Y,a5)
    rts

handle_01_Bacura: | $2B23
    move.b    #2,(_STATE,a5)
    move.b    #0x82,(_ATTR,a5)                  | bank=1, size=1x2
    move.w    #16,(_dX,a5)
    jsr       gen_random_Y_store_obj
    addq.b    #1,(_Y,a5)                        | MSB
    jsr       save_PC_to_fn_tbl_and_ret
    move.w    (_X,a5),d0                        | spriteX[8:0]<<5
    lsr.w     #7,d0                             | spritex[8:2]
    and.w     #7,d0                             | spriteX[4:2]
    movea.l   #bacura_sprite_tbl,a0
    lsl.w     #1,d0                             | x2
    move.b    (a0,d0.w),(_COLOUR,a5)
    move.b    (1,a0,d0.w),(_CODE,a5)
    jsr       move_object_dX
    bra       add_obj_handler

* sprite colour, code tuples
* - sprite size is 1x2
bacura_sprite_tbl: | $2B5D
    .byte 0x2B, 0x20
    .byte 0x2C, 0x21
    .byte 0x2B, 0x24
    .byte 0x2C, 0x25
    .byte 0x2B, 0x28
    .byte 0x2C, 0x29
    .byte 0x2B, 0x2C
    .byte 0x2C, 0x2D
       
handle_06_Bullet: | $2B6D
    movea.l   #angle_dX_dY_tbl,a2
    jsr       calc_dX_dY_for_vector_to_solvalou
    jsr       save_PC_to_fn_tbl_and_ret
    jsr       move_object_dX_dY
    bra       add_obj_handler

handle_07_Garu_Zakato_Bullet: | $2B79
    jsr       move_object_dX_dY
    bra       add_obj_handler
                        
handle_2C_Grobda_stationary: | $2B83
    move.w    #8,d0                             | dX=8 (stop)
    jsr       activate_and_set_object_dX
    move.b    #21,(_PTS,a5)                     | 200 pts
    move.b    #0x4c,(_CODE,a5)
    jsr       save_PC_to_fn_tbl_and_ret
    jsr       check_object_hit
    bra       set_object_colour_and_move_dX

* 
* Grobda (Tank/Stingray) 400 pts
* - moving
handle_35_Grobda_fwd: | $2B96
    move.w    #14,d0                            | dX=14 (fwd)
    jsr       activate_and_set_object_dX
    move.b    #30,(_PTS,a5)                     | 400 pts
    jsr       save_PC_to_fn_tbl_and_ret
    jsr       check_object_hit
    jsr       animate_grobda_forwards
    bra       set_object_colour_and_move_dX

* Grobda (Tank/Stingray) 600 pts
* - moves forward (forever) when in crosshairs
handle_36_Grobda_crosshairs_fwd: | $2BA6
    move.w    #8,d0                             | dX=8 (stop)
    jsr       activate_and_set_object_dX
    move.b    #36,(_PTS,a5)                     | 600 pts
    move.b    #0x4c,(_CODE,a5)
    jsr       save_PC_to_fn_tbl_and_ret
    jsr       check_object_hit
    jsr       check_grobda_in_crosshairs
    bcs       grobda_start_moving_fwd   
    bra       set_object_colour_and_move_dX

grobda_start_moving_fwd: | $2BBE
    move.w    #14,(_dX,a5)                      | dX=14 (fwd)
    SET_REENTRY_ADDR_HERE
    jsr       check_object_hit
    jsr       animate_grobda_forwards
    bra       set_object_colour_and_move_dX
        
set_object_colour_and_move_dX: | $2BD5
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    jsr       move_object_dX
    bra       add_obj_handler

* Grobda (Tank/Stingray) 1,000 pts
* - moving, stops when in crosshairs
handle_38_Grobda_fwd_crosshairs_stop_fwd: | $2C2E
    move.w    #14,d0                            | dX=14 (fwd)
    jsr       activate_and_set_object_dX
    move.b    #48,(_PTS,a5)                     | 1,000 pts
    jsr       save_PC_to_fn_tbl_and_ret
    jsr       check_object_hit
    jsr       check_grobda_in_crosshairs
    bcs       grobda_stops_in_crosshairs
    jsr       animate_grobda_forwards
    bra       set_object_colour_and_move_dX

grobda_stops_in_crosshairs: | $2C44
    move.w    #8,(_dX,a5)                       | stop
    SET_REENTRY_ADDR_HERE
    jsr       check_object_hit
    subq.b    #1,(_TIMER,a5)                    | start moving again?
    beq       1f                                | yes, go
    bra       set_object_colour_and_move_dX
1:  move.w    #14,(_dX,a5)                      | fwd
    SET_REENTRY_ADDR_HERE
    jsr       check_object_hit
    jsr       animate_grobda_forwards
    bra       set_object_colour_and_move_dX

* Grobda (Tank/Stingray) 1,500 pts
* - darts backwards when targeted
handle_39_Grobda_targeted_back_stop: | $2C77
    move.w    #8,d0                             | dX=8 (stop)
    jsr       activate_and_set_object_dX
    move.b    #51,(_PTS,a5)                     | 1,500 pts
    move.b    #0x4c,(_CODE,a5)
    jsr       save_PC_to_fn_tbl_and_ret
    jsr       check_object_hit
    jsr       check_targeted_and_init_timer
    bcs       grobda_dart_back
    bra       set_object_colour_and_move_dX

grobda_dart_back: | $2C90
    move.w    #2,(_dX,a5)                       | backwards
    SET_REENTRY_ADDR_HERE
    jsr       check_object_hit
    subq.b    #1,(_TIMER,a5)                    | dec timer
    beq       grobda_stop
    jsr       animate_grobda_backwards
    bra       set_object_colour_and_move_dX

grobda_stop: | $2CAD
    move.w    #8,(_dX,a5)                       | stop
    SET_REENTRY_ADDR_HERE
    jsr       check_object_hit
    bra       set_object_colour_and_move_dX

* Grobda (Tank/Stingray) 2,000 pts
* - moving, darts forward when targeted
handle_3A_Grobda_fwd_crosshairs_darts_fwd: | $2CC4
    move.w    #14,d0                            | dX=14 (fwd)
    jsr       activate_and_set_object_dX
    move.b    #54,(_PTS,a5)                     | 2,000 pts
    jsr       save_PC_to_fn_tbl_and_ret
    jsr       check_object_hit
    jsr       check_grobda_in_crosshairs
    bcs       grobda_darts_fwd_in_crosshairs
    jsr       animate_grobda_forwards
    bra       set_object_colour_and_move_dX
    
grobda_darts_fwd_in_crosshairs: | $2CDB
    move.w    #22,(_dX,a5)                      | fast fwd
    SET_REENTRY_ADDR_HERE
    jsr       check_object_hit
    subq.b    #1,(_TIMER,a5)                    | stop darting?
    beq       1f                                | yes, go
    jsr       animate_grobda_fast_forward
    bra       set_object_colour_and_move_dX
1:  move.w    #14,(_dX,a5)                      | fwd
    SET_REENTRY_ADDR_HERE
    jsr       check_object_hit
    jsr       animate_grobda_forwards
    bra       set_object_colour_and_move_dX

* Grobda (Tank/Stingray) 2,500 pts
* - moving, darts back then forward when targeted
handle_3B_Grobda_fwd_targeted_back_fwd: | $2D10
    move.w    #14,d0                            | dX=14 (fwd)
    jsr       activate_and_set_object_dX
    move.b    #57,(_PTS,a5)                     | 2,500 pts
    jsr       save_PC_to_fn_tbl_and_ret
    jsr       check_object_hit
    jsr       check_targeted_and_init_timer
    bcs       grobda_3B_dart_back
    jsr       animate_grobda_forwards
    bra       set_object_colour_and_move_dX

grobda_3B_dart_back: | $2D27
    move.w    #2,(_dX,a5)                       | backwards
    SET_REENTRY_ADDR_HERE
    jsr       check_object_hit
    subq.b    #1,(_TIMER,a5)                    | time to change dir?
    beq       grobda_3B_dart_fwd                | yes, go
    jsr       animate_grobda_backwards
    bra       set_object_colour_and_move_dX

grobda_3B_dart_fwd: | $2D44
    move.w    #14,(_dX,a5)                      | forward
    SET_REENTRY_ADDR_HERE
    jsr       check_object_hit
    jsr       animate_grobda_forwards
    bra       set_object_colour_and_move_dX

handle_3C_Grobda_targeted_fast_fwd: | $2D5C
    move.w    #8,d0                             | dX=8 (stop)
    jsr       activate_and_set_object_dX
    move.b    #63,(_PTS,a5)                     | 10,000 pts
    move.b    #0x4c,(_CODE,a5)
    jsr       save_PC_to_fn_tbl_and_ret
loc_2D68:   
    jsr       check_object_hit
    jsr       check_targeted_and_init_timer
    bcs       1f
    bra       set_object_colour_and_move_dX   
1:  move.w    #22,(_dX,a5)                      | fast fwd
    SET_REENTRY_ADDR_HERE
    jsr       check_object_hit
    subq.b    #1,(_TIMER,a5)                    | dec timer
    beq       2f
    jsr       animate_grobda_fast_forward
    bra       set_object_colour_and_move_dX
2:  move.w    #8,(_dX,a5)                       | stop
    SET_REENTRY_ADDR_HERE
    bra       loc_2D68    
        
* Grobda (Tank/Stingray) 200 pts
* - stationary (same behaviour as $2C)
handle_3D_Grobda_stationary_in_water: | $2DA3
    move.w    #8,d0                             | dX=8 (stop)
    jsr       activate_and_set_object_dX
    move.b    #21,(_PTS,a5)                     | 200 pts
    move.b    #0x4c,(_CODE,a5)
    jsr       save_PC_to_fn_tbl_and_ret
    jsr       check_object_hit_and_remove
    bra       set_object_colour_and_move_dX

* Grobda (Tank/Stingray) 400 pts
* - moving
handle_3E_Grobda_fwd_in_water: | $2DB7
    move.w    #14,d0                            | dX=14 (fwd)
    jsr       activate_and_set_object_dX
    move.b    #30,(_PTS,a5)                     | 400 pts
    jsr       save_PC_to_fn_tbl_and_ret
    jsr       check_object_hit_and_remove
    jsr       animate_grobda_forwards
    bra       set_object_colour_and_move_dX

* Grobda (Tank/Stingray) 600 pts
* - moves forward when in crosshairs
handle_3F_Grobda_crosshairs_fwd_in_water: | $2DC8
    move.w    #8,d0                             | dX=8 (stop)
    jsr       activate_and_set_object_dX
    move.b    #36,(_PTS,a5)                     | 600 pts
    move.b    #0x4c,(_CODE,a5)
    jsr       save_PC_to_fn_tbl_and_ret
    jsr       check_object_hit_and_remove
    jsr       check_grobda_in_crosshairs
    bcs       1f
    bra       set_object_colour_and_move_dX
1:  move.w    #14,(_dX,a5)                      | fwd
    SET_REENTRY_ADDR_HERE
    jsr       check_object_hit_and_remove
    jsr       animate_grobda_forwards
    bra       set_object_colour_and_move_dX

* Grobda (Tank/Stingray) 2,500 pts
* - moves forward, then back, then fwd when targeted
handle_40_Grobda_fwd_targeted_back_fwd_in_water: | $2DF9
    move.w    #14,d0                            | dX=14 (fwd)
    jsr       activate_and_set_object_dX
    move.b    #57,(_PTS,a5)                     | 2,500 pts
    jsr       save_PC_to_fn_tbl_and_ret
    jsr       check_object_hit_and_remove
    jsr       check_targeted_and_init_timer
    bcs       1f
    jsr       animate_grobda_forwards
    bra       set_object_colour_and_move_dX
1:  move.w    #2,(_dX,a5)                       | backwards
    SET_REENTRY_ADDR_HERE
    jsr       check_object_hit_and_remove
    subq.b    #1,(_TIMER,a5)                    | time to move fwd?
    beq       2f                                | yes, go
    jsr       animate_grobda_backwards
    bra       set_object_colour_and_move_dX
2:  move.w    #14,(_dX,a5)                      | forwards    
    SET_REENTRY_ADDR_HERE
    jsr       check_object_hit_and_remove
    jsr       animate_grobda_forwards
    bra       set_object_colour_and_move_dX

check_object_hit: | $2E45
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       1f                                | yes, go
    rts
1:  adda.l    #4,a7                             | return up call stack
    bra       handle_bomb_explosion

check_object_hit_and_remove: | $2E55
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       1f                                | yes, go
    rts
1:  adda.l    #4,a7                             | return up call stack
    bra       explode_and_remove_object

animate_grobda_forwards: | $2E65
    move.b    (countup_timer_1),d0
    lsr.b     #1,d0
    and.b     #3,d0
    add.b     #0x4c,d0                          | animate sprite
    move.b    d0,(_CODE,a5)
    rts
            
animate_grobda_backwards: | $2E71
    move.b    (countup_timer_1),d0
    lsr.b     #1,d0
    and.b     #3,d0
    neg.b     d0
    and.b     #3,d0
    add.b     #0x4c,d0                          | animate sprite
    move.b    d0,(_CODE,a5)
    rts
            
animate_grobda_fast_forward: | $2E81
    move.b    (countup_timer_1),d0
    and.b     #3,d0
    add.b     #0x4c,d0                          | animate sprite
    move.b    d0,(_CODE,a5)
    rts
            
* d0.w=dX
activate_and_set_object_dX: | $2E8C
    move.b    #2,(_STATE,a5)
    clr.b     (_ATTR,a5)                        | size=0
    move.w    d0,(_dX,a5)
    clr.w     (_dY,a5)
    rts

check_targeted_and_init_timer: | $2EA0
    movea.l   #obj_tbl+_OBJSIZE*0x20,a0
    move.b    (_X,a0),d0                        | MSB X crosshairs
    sub.b     (_X,a5),d0                        | MSB X object
    subq.b    #2,d0
    addq.b    #4,d0
    bcc       9f
    move.b    (_Y,a0),d0                        | MSB Y crosshairs
    sub.b     (_Y,a5),d0                        | MSB Y object
    subq.b    #2,d0
    addq.b    #4,d0
    bcc       9f
    move.b    #48,(_TIMER,a5)                   | init timer
    ori.b     #(1<<0),ccr                       | restore C flag
9:  rts
    
check_grobda_in_crosshairs: | $2EBB
    movea.l   #obj_tbl+_OBJSIZE*0x22,a0         | crosshairs
    move.b    (_X,a0),d0                        | MSB X
    sub.b     (_X,a5),d0
    subq.b    #2,d0
    addq.b    #4,d0
    bcc       9f
    move.b    (_Y,a0),d0                        | MSB Y
    sub.b     (_Y,a5),d0
    subq.b    #2,d0
    addq.b    #4,d0
    bcc       9f
    move.b    #48,(_TIMER,a5)                   | init timer
    ori.b     #(1<<0),ccr                       | restore C flag
9:  rts

* Domogram (Defence Site/Slider) 800 pts
* - timer table is shot timer
*   - offset=1 is num vectors remaining
* - timer2 table is path vector length
* - type table (repurposed) is shot animation timer
* - path data addr in object extra table
* - path data length in object timer table+1
handle_2E_Domogram: | $2ED6
    move.b    #2,(_STATE,a5)
    clr.b     (_ATTR,a5)                        | size=1x1
    move.b    #0x3c,(_CODE,a5)
    move.b    #42,(_PTS,a5)                     | 800 pts
    move.b    #1,(_VECLEN,a5)                   | flag vector finished
    move.b    (ffreq_mask_domogram),(_FFREQ,a5)
    jsr       pseudo_random_gen                 | random shot timer
    and.b     (_FFREQ,a5),d0                    | scale with mask
    addq.b    #1,d0
    move.b    d0,(_TIMER,a5)                    | init shot timer
    clr.b     (_TYPE,a5)                        | repurpose as shot animation timer
    jsr       save_PC_to_fn_tbl_and_ret
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       handle_bomb_explosion             | yes, go
    subq.b    #1,(_VECLEN,a5)                   | vector done?
    bne       domogram_main                     | no, go
* get next path vector
    move.l    (_EXTRA,a5),a0                    | ptr path data
    move.b    (a0)+,(_VECLEN,a5)
    moveq     #0,d2
    move.b    (a0)+,d2                          | vector index
    move.l    a0,(_EXTRA,a5)                    | store updated ptr path data
    movea.l   #domogram_vector_tbl,a2
    jsr       cpy_dY_dX_to_obj
    subq.b    #1,(_NVEC,a5)                     | dec num vectors
    beq       domogram_done_all_vectors
    bra       domogram_main

domogram_done_all_vectors: | $2F3E
    SET_REENTRY_ADDR_HERE
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       handle_bomb_explosion             | yes, go
    * fall thru
    
domogram_main: | $2F54
    tst.b     (_TYPE,a5)                        | animation shot timer
    bne       domogram_shooting
    move.b    (gnd_stop_firing_row),d0
    cmp.b     (_X,a5),d0                        | MSB. stop firing?
    bcs       domogram_colour_and_move          | yes, go
    move.b    (countup_timer_1),d0
    and.b     #7,d0                             | time to dec shot timer?
    bne       domogram_colour_and_move          | no, go
    subq.b    #1,(_TIMER,a5)                    | time to shoot?
    bne       domogram_colour_and_move          | no, go
    move.b    #24,(_TYPE,a5)                    | init animation timer
    
domogram_shooting: | $2F76
    subq.b    #1,(_TYPE,a5)                     | dec animation timer
    move.b    (_TYPE,a5),d0
    cmp.b     #12, d0                           | time to spawn bullet?
    bne       domogram_animate_sprite           | no, go
    jsr       init_new_bullet
    jsr       pseudo_random_gen                 | rnd shot timer
    and.b     (_FFREQ,a5),d0                    | scale with mask
    addq.b    #1,d0
    move.b    d0,(_TIMER,a5)                    | init shot timer
    move.b    (_TYPE,a5),d0                     | animation timer
    
domogram_animate_sprite: | $2F8C
    lsr.b     #2,d0
    and.w     #7,d0
    movea.l   #domogram_sprite_tbl,a0
    move.b    (a0,d0.w),(_CODE,a5)

domogram_colour_and_move: | $2F99
    move.b    (pulsing_colour_1),(_COLOUR,a5)
    jsr       move_object_dX_dY
    bra       add_obj_handler

domogram_sprite_tbl: | $2FAB
    .byte 0x3C, 0x3D, 0x3E, 0x3F, 0x3E, 0x3D
    
* domogram dY,dX value pairs
domogram_vector_tbl: | $2FB1
    .byte 0, 0x10
    .byte 2, 0x10
    .byte 4, 0x10
    .byte 6, 0x10
    .byte 8, 0x10
    .byte 8, 0xE
    .byte 8, 0xC
    .byte 8, 0xA
    .byte 8, 8
    .byte 8, 6
    .byte 8, 4
    .byte 8, 2
    .byte 8, 0
    .byte 6, 0
    .byte 4, 0
    .byte 2, 0
    .byte 0, 0
    .byte 0xFE, 0
    .byte 0xFC, 0
    .byte 0xFA, 0
    .byte 0xF8, 0
    .byte 0xF8, 2
    .byte 0xF8, 4
    .byte 0xF8, 6
    .byte 0xF8, 8
    .byte 0xF8, 0xA
    .byte 0xF8, 0xC
    .byte 0xF8, 0xE
    .byte 0xF8, 0x10
    .byte 0xFA, 0x10
    .byte 0xFC, 0x10
    .byte 0xFE, 0x10
    .byte 0xFF
    .byte 0xFF
    .byte 0xFF
    .byte 0xFF
    .byte 0xFF
    .byte 0xFF
    .byte 0xFF
    .byte 0xFF
    .byte 0xFF
    .byte 0xFF
    .byte 0xFF
    .byte 0xFF
    .byte 0xFF
    .byte 0xFF
    .byte 0x66              
    .align 2
                
main_fn_2__handle_objects: | $3000
    lea       obj_tbl,a0
    move.w    #32*64/4,d7                       | 64 objects
1:  clr.l     (a0)+
    dbf       d7,1b
    movea.l   #add_obj_handler,a0
    lea       main_2_fn_tbl_1,a1
    moveq     #32-1,d7
2:  move.l    a0,(a1)+
    dbf       d7,2b                             | init 1st half fn table
    lea       main_2_fn_tbl_2,a1
    moveq     #25-1,d7
3:  move.l    a0,(a1)+
    dbf       d7,3b                             | init 2nd half fn table
    movea.l   #obj_tbl+_OBJSIZE*0x27,a5         | 1st bullet object
    moveq     #19-1,d7                          | 19 bullets
4:  move.b    #0x00,(_STATE,a5)
    move.b    #0x80,(_ATTR,a5)                  | bank=1
    move.b    #0x1e,(_CODE,a5)
    adda.l    #_OBJSIZE,a5
    dbf       d7,4b                             | init bullet fn table
    jsr       save_PC_to_fn_tbl_and_ret
    tst.b     (scroll_disabled)
    bne       9f
    jsr       save_PC_to_fn_tbl_and_ret
    tst.b     (scroll_disabled)
    bne       main_fn_2__handle_objects
    move.l    a6,-(a7)                          | save main jump table address

    movea.l   #obj_tbl,a5                       | object pointer
    lea       main_2_fn_tbl_1,a6                | object fn
    moveq     #32-1,d7
loc_305E:
    move.l    (a6),a0
    movem.l   d7/a5-a6,-(a7)
    jsr       (a0)
    movem.l   (a7)+,d7/a5-a6
    add.w     #_OBJSIZE,a5                      | next object
    adda.l    #4,a6                             | next object fn
    dbf       d7,loc_305E
    
    adda.l    #_OBJSIZE*7,a5                    | skip solvalou, shots
    lea       main_2_fn_tbl_2,a6
    move.q    #25-1,d7
loc_306D:
    move.l    (a6),a0
    movem.l   d7/a5-a6,-(a7)
    jsr       (a0)
    movem.l   (a7)+,d7/a5-a6
    add.w     #_OBJSIZE,a5                      | next object
    adda.l    #4,a6                             | next object fn
    dbf       d7,loc_306D
    
    move.l    (a7)+,a6                          | restore main jump table address
9:  rts

* d6=obj_tbl offset, a6=handler fn entry
add_obj_handler: | $3079
    jsr       save_PC_to_fn_tbl_and_ret
    moveq     #0,d0
    move.b    (_TYPE,a5),d0                     | valid type?
    beq       9f                                | no, return
    lea       obj_handler_tbl,a0
    subq.w    #1,d0                             | 1st entry is object #1
    lsl.w     #2,d0                             | offset for object
    move.l    (a0,d0.w),(a6)                    | patch table with handler function
9:  rts

move_object_dX_dY: | $3091
    move.w    (_dX,a5),d0
    lsl.w     #1,d0                             | x2
    add.w     d0,(_X,a5)                        | add and update spriteX
    move.w    (_dY,a5),d0
    lsl.w     #1,d0                             | x2
    add.w     d0,(_Y,a5)                        | add and update spriteY
    * fall thru
    
* a5=object ptr, d0=spriteX
check_scroll_offscreen: | $30B4
    move.b    (_X,a5),d0                        | MSB in low byte
    addq.b    #1,d0
    cmp.b     #0x29,d0
    bcc       handle_scroll_offscreen
    move.b    (_Y,a5),d0
    cmp.b     #0x1f,d0
    bcs       exit_caller
handle_scroll_offscreen:
    clr.b     (_STATE,a5)
    clr.b     (_EXTRA,a5)
    clr.b     (_TYPE,a5)
    rts

* a5=object ptr
move_object_dX: | $30D4
    move.w    (_dX,a5),d0
    lsl.w     #1,d0                             | x2
    add.w     d0,(_X,a5)                        | update spriteX
    bra       check_scroll_offscreen
            
* a5=object ptr
scroll_sprite_X: | $30E8
    move.w    (scroll_delta),d0
    neg.w     d0
    lsl.w     #1,d0                             | x2
    add.w     d0,(_X,a5)                        | update spriteX
    bra       check_scroll_offscreen

move_object_dX_dY_2: | $30FC
    move.w    (_dX,a5),d0
    lsl.w     #1,d0                             | x2
    add.w     d0,(_X,a5)                        | update spriteX
    move.w    (_dY,a5),d0
    lsl.w     #1,d0                             | x2
    add.w     d0,(_Y,a5)                        | update spriteY
    rts
    
flying_enemy_hit: | $311F
    move.b    #7,(_COLOUR,a5)
    move.b    #0xff,(_TIMER,a5)
    SET_REENTRY_ADDR_HERE
    addq.b    #1,(_TIMER,a5)                    | inc timer
    moveq     #0,d0
    move.b    (_TIMER,a5),d0
    cmp.b     #8,d0                             | time to adjust sprite size?
    bne       1f                                | no, skip
    subq.b    #1,(_X,a5)                        | dec MSB X
    addq.b    #1,(_Y,a5)                        | inc MSB Y
1:  move.b    d0,d1                             | save timer value
    lsr.b     #2,d0
    cmp.b     #5,d0                             | explosion finished?
    beq       remove_object_type_state
* animate flying enemy explosion
    movea.l   #flying_obj_explosion_sprites,a0
    lsl.w     #1,d0                             | x2
    move.b    (a0,d0.w),(_CODE,a5)
    and.w     #3,d1                             | timer
    lsl.b     #2,d1
    add.b     (1,a0,d0.w),d1                    | 2nd table entry
    move.b    d1,(_ATTR,a5)
    jsr       move_object_dX_dY
    bra       add_obj_handler

* code and size for flying enemy explosion
flying_obj_explosion_sprites: | $316F
    .byte 0x70, 0
    .byte 0x71, 0
    .byte 0x74, 3
    .byte 0x78, 3
    .byte 0x7C, 3

remove_object_type_state: | $3179
    clr.b     (_TYPE,a5)
    clr.b     (_STATE,a5)
    bra       add_obj_handler

handle_bomb_explosion: | $3186
    move.b    #0x0c,(_COLOUR,a5)
    move.b    #0xff,(_TIMER,a5)                 | init timer
    SET_REENTRY_ADDR_HERE
    addq.b    #1,(_TIMER,a5)
    moveq     #0,d0
    move.b    (_TIMER,a5),d0
    move.b    d0,d1
    and.b     #7,d1                             | time for next animation frame?
    bne       loc_31CE                          | no, skip
    lsr.b     #3,d0
    and.b     #7,d0                             | animation frame
    cmp.b     #7,d0                             | done animating?
    beq       bomb_explosion_finished
    cmp.b     #2,d0
    bne       1f
    jsr       adj_for_big_explosion_frame2
1:  cmp.b     #5,d0
    bne       2f
    jsr       adj_for_small_explosion_frame2
2:  movea.l   #bomb_explosion_animation_tbl,a0
    lsl.w     #1,d0
    move.b    (a0,d0.w),(_CODE,a5)
    move.b    (1,a0,d0.w),(_ATTR,a5)
    jsr       scroll_sprite_X
    bra       add_obj_handler

loc_31CE:
    jsr       scroll_sprite_X
    bra       add_obj_handler

bomb_explosion_finished: | $31D7
    move.b    #0xa6,(_CODE,a5)
    move.b    #0x0d,(_COLOUR,a5)
    jsr       save_PC_to_fn_tbl_and_ret
    move.b    (countup_timer_1),d0
    lsr.b     #2,d0
    and.b     #1,d0
    add.b     #0xa6,d0
    move.b    d0,(_CODE,a5)
    jsr       scroll_sprite_X
    bra       add_obj_handler
    
* these are sprite codes, sizes for the bomb explosion
bomb_explosion_animation_tbl: | $31F4
    .byte 0x60
    .byte    0
    .byte 0x61
    .byte    0
    .byte 0x64
    .byte    3
    .byte 0x68
    .byte    3
    .byte 0x6C
    .byte    3
    .byte 0x62
    .byte    0
    .byte 0x63
    .byte    0

adj_for_big_explosion_frame2: | $3202
    subq.b    #1,(_X,a5)                        | MSB
    addq.b    #1,(_Y,a5)                        | MSB
    rts
    
adj_for_small_explosion_frame2: | $320C
    addq.b    #1,(_X,a5)                        | MSB
    subq.b    #1,(_Y,a5)                        | MSB
    rts
    
explode_and_remove_object: | $3216
    move.b    #0x0c,(_COLOUR,a5)
    move.b    #0xff,(_TIMER,a5)
    SET_REENTRY_ADDR_HERE
    addq.b    #1,(_TIMER,a5)
    move.b    (_TIMER,a5),d0
    move.b    d0,d1                             | copy
    and.b     #3,d0
    bne       loc_325D
    lsr.b     #2,d1
    and.w     #7,d1
    cmp.b     #7,d1                             | done exploding?
    beq       remove_object
    cmp.b     #2,d1
    bne       1f
    jsr       adj_for_big_explosion_frame2
1:  cmp.b     #5,d1
    bne       2f
    jsr       adj_for_small_explosion_frame2
2:  movea.l   #bomb_explosion_animation_tbl,a0
    lsl.w     #1,d1                             | entry offset
    lea       (a0,d1.w),a0                      | ptr entry
    move.b    (a0)+,(_CODE,a5)
    move.b    (a0),(_ATTR,a5)
    jsr       scroll_sprite_X
    bra       add_obj_handler

loc_325D: | $325D
    jsr       scroll_sprite_X
    bra       add_obj_handler

remove_object: | $3266
    clr.b     (_TYPE,a5)
    clr.b     (_STATE,a5)
    bra       add_obj_handler

chk_timer_fire_bullet_reinit_timer: | $3271
    move.b    (countup_timer_1),d0
    and.b     #7,d0
    bne       9f
    subq.b    #1,(_TIMER,a5)                    | time to fire?
    bne       9f                                | no, exit
    jsr       init_new_bullet
    jsr       pseudo_random_gen                 | rnd shot timer
    and.b     (_FFREQ,a5),d0                    | scale wirh mask
    addq.b    #1,d0
    move.b    d0,(_TIMER,a5)                    | init timer
9:  rts

init_new_bullet: | $3287
    movea.l   #obj_tbl+_OBJSIZE*0x27,a0         | 1st bullet
    moveq     #19-1,d7                          | 19 bullets
1:  cmp.b     #1,(_STATE,a0)                    | idle?
    beq       found_idle_bullet_slot            | yes, go
    adda.l    #_OBJSIZE,a0                      | next slot
    dbf       d7,1b
    rts

find_idle_and_init_radiating_bullet: | $3297
    movea.l   #obj_tbl+_OBJSIZE*0x27,a0         | bullet table
    moveq     #19-1,d7                          | 19 bullets
1:  move.b    (_STATE,a0),d0
    subq.b    #1,d0
    beq       init_radiating_bullet
    lea       (_OBJSIZE,a0),a0
    dbf       d7,1b
    rts
    
* a0=bullet a5=object firing
set_state_and_copy_obj_coords: | $32A5
    move.b    #2,(_STATE,a0)
    move.w    (_X,a5),(_X,a0)
    move.w    (_Y,a5),(_Y,a0)
    rts

* a0=bullet a5=object firing
found_idle_bullet_slot: | $32BB
    jsr       set_state_and_copy_obj_coords
    move.b    #6,(_TYPE,a0)
    rts

* a0=bullet d2=angle index
init_radiating_bullet: | $32C4
    jsr       set_state_and_copy_obj_coords
    movea.l   #angle_dX_dY_terrazi_torkan_tbl,a2
    jsr       cpy_dY_dX_to_obj
    move.b    #7,(_TYPE,a0)
    rts

brag_zakato_shoot: | $32D9
    move.b    (_X,a5),d4                        | save MSB
    movea.l   #obj_tbl+_OBJSIZE*0x23,a1         | solvalou
    move.b    (_X,a1),d0                        | MSB
    sub.b     d4,d0
    move.b    (_Y,a5),d4                        | save MSB
    move.b    (_Y,a1),d1                        | MSB
    sub.b     d4,d1
    jsr       get_index_for_angle
    sub.b     #32,d2
    lsr.b     #3,d2
    and.w     #0x1f,d2
    moveq     #5-1,d7
1:  move.l    d7,-(a7)
    jsr       find_idle_and_init_radiating_bullet
    move.l    (a7)+,d7
    addq.b    #2,d2
    and.w     #0x1f,d2
    dbf       d7,1b
    rts
    
init_garu_zakato_explosion: | $330A
    moveq     #0,d2                             | start angle
    moveq     #16-1,d7                          | 16 bullets to spawn
1:  move.l    d7,-(a7)
    jsr       find_idle_and_init_radiating_bullet
    move.l    (a7)+,d7
    addq.b    #2,d2
    and.b     #30,d2
    dbf       d7,1b
    movea.l   #obj_tbl+_OBJSIZE*0x3B,a0         | garu_zakato
    lea       (_OBJSIZE,a0),a1                  | next object
    movea.l   a1,a2                             | copy
    moveq     #4-1,d7
2:  move.w    (_X,a0),(_X,a1)
    move.w    (_Y,a0),(_Y,a1)
    lea       (_OBJSIZE,a1),a1
    dbf       d7,2b
    movea.l   #brag_spario_dX_tbl,a0
    movea.l   #brag_spario_dY_tbl,a1
    moveq     #4-1,d7
3:  move.b    (a0)+,d0
    ext.w     d0
    move.w    d0,(_dX,a2)
    move.b    (a1)+,d0
    ext.w     d0
    move.w    d0,(_dY,a2)
    move.b    #9,(_TYPE,a2)                     | Brag Spario
    lea       (_OBJSIZE,a2),a2                  | next object
    dbf       d7,3b
    rts

brag_spario_dX_tbl: | $335D
    .byte 0x20
    .byte    0
    .byte 0xE0
    .byte    0
    
brag_spario_dY_tbl: | $3361
    .byte 0
    .byte 0xE0
    .byte 0
    .byte 0x20

* a2=angle_dX_dY_tbl, a5=object
calc_dX_dY_for_vector_to_solvalou: | $3365
    movea.l   #obj_tbl+_OBJSIZE*0x23,a1         | solvalou
    move.b    (_X,a1),d0                        | solvalou MSB
    sub.b     (_X,a5),d0                        | sub bullet MSB
    move.b    (_Y,a1),d1                        | solvalou MSB
    sub.b     (_Y,a5),d1                        | sub bullet MSB
    jsr       get_index_for_angle
    addq.b    #4,d2
    * fall thru
    
get_dX_dY_and_cpy_to_obj:
    lsr.b     #3,d2
    and.w     #0x1f,d2
    * fall thru
            
* a2=table base addr, a5=object, d2=offset
cpy_dY_dX_to_obj: | $3383
    lsl.w     #1,d2                             | x2
    lea       (a2,d2.w),a2                      | ptr entry
    move.b    (a2)+,d0
    ext.w     d0
    move.w    d0,(_dY,a5)
    move.b    (a2),d0
    ext.w     d0
    move.w    d0,(_dX,a5)
    rts

* a5=object   
gen_random_Y_store_obj: | $338B
    jsr       pseudo_random_gen
    and.w     #31,d0
    cmp.b     #25,d0
    bcc       gen_random_Y_store_obj
    addq.w    #3,d0
    lsl.w     #8,d0
    move.w    d0,(_Y,a5)
    rts
        
gen_rnd_spriteY: | $3398
    movea.l   #obj_tbl+0x23*_OBJSIZE,a4         | solvalou object
1:  jsr       pseudo_random_gen
    and.b     #31,d0
    cmp.b     #25,d0                            | too big?
    bcc       1b                                | yes, try again
    addq.b    #3,d0
    move.b    d0,d1
    sub.b     (_Y,a4),d1
    subq.b    #8,d1
    add.b     #0x10,d1                          | too close to solvalou?
    bcs       1b                                | yes, try again
    move.b    d0,(_Y,a5)                        | spriteY (MSB)
    rts

main_fn_4__spawn_flying_enemies: | $33B3
    tst.b     (scroll_disabled)
    bne       9f
    moveq     #0,d7
    move.b    (num_flying_enemies),d7
    beq       9f
    moveq     #0,d0
    move.b    (flying_enemy_type_tbl_offset),d0
    movea.l   #flying_enemy_type_tbl,a0
    lea       (a0,d0.w),a0
    movea.l   #obj_tbl+_OBJSIZE*0x3a,a1         | flying enemies
    subq.b    #1,d7                             | adjust for 68K
1:  move.b    (a0)+,(_TYPE,a1)
    adda.l    #_OBJSIZE,a1
    dbf       d7,1b
9:  rts

main_fn_3__init_bacura: | $33D0
    tst.b     (scroll_disabled)
    bne       9f
    moveq     #0,d7
    move.b    (num_bacura),d7
    beq       9f
    movea.l   #obj_tbl+_OBJSIZE*0x10,a1         | start of Bacura
    subq.b    #1,d7
1:  move.b    #1,(_TYPE,a1)
    adda.l    #_OBJSIZE,a1
    dbf       d7,1b
9:  rts

main_fn_5__inc_num_bacura: | $33E5
    jsr       save_PC_to_fn_tbl_and_ret
    tst.b     (scroll_disabled)
    bne       9f
    tst.b     (bacura_inc_cnt)
    beq       9f
1:  move.b    #60,(one_second_cntr)
    jsr       save_PC_to_fn_tbl_and_ret
    tst.b     (scroll_disabled)
    bne       main_fn_5__inc_num_bacura
    subq.b    #1,(one_second_cntr)
    bne       9f
    addq.b    #1,(num_bacura)
    subq.b    #1,(bacura_inc_cnt)
    beq       main_fn_5__inc_num_bacura
    bra       1b
9:  rts

handle_08_Giddo_Spario: | $340D
    move.b    #2,(_STATE,a5)
    move.b    #0x80,(_ATTR,a5)                  | bank=1,size=1x1
    jsr       gen_random_Y_store_obj
    movea.l   #angle_dX_dY_sheonite_tbl,a2
    jsr       calc_dX_dY_for_vector_to_solvalou
    move.b    #0,(_PTS,a5)                      | 10 pts
    jsr       save_PC_to_fn_tbl_and_ret
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       giddo_spario_hit                  | yes, go
    move.b    (countup_timer_1),d0
    lsr.b     #1,d0
    move.l    d0,d1                             | copy
    and.w     #3,d0
    move.b    d0,(_CODE,a5)
    lsr.b     #2,d1
    and.w     #3,d1
    add.b     #0x26,d1
    move.b    d1,(_COLOUR,a5)
    jsr       move_object_dX_dY
    bra       add_obj_handler
    
giddo_spario_hit: | $3451
    move.b    #0xff,(_TIMER,a5)                 | init timer
    SET_REENTRY_ADDR_HERE
    addq.b    #1,(_TIMER,a5)
    move.b    (_TIMER,a5),d0
    lsr.b     #1,d0
    cmp.b     #4,d0
    beq       remove_giddo_spario
    addq.b    #4,d0
    move.b    d0,(_CODE,a5)
    jsr       move_object_dX_dY
    bra       add_obj_handler

remove_giddo_spario: | $3476
    clr.b     (_STATE,a5)
    clr.b     (_TYPE,a5)
    bra       add_obj_handler      
    
* installed into object #15
* master andor genesis object
* *** BUG ***
* when the core is bombed, the points for this object
* are also awarded. Since the points for this object
* are never initialised, the points from the last object
* in slot #15 are awarded.
* eg. Area 9 is awarded an extra 200 points from a Zolbak
handle_4B_Andor_Genesis_obj_15: | $3481
    cmp.b     #3,(obj_tbl+_OBJSIZE*0x0E+_STATE) | object 14 (core)
    beq       andor_genesis_destroyed
    move.b    #0x10,d0
    cmp.b     (_X,a5),d0                        | MSB
    beq       1f
    *** TBD sound
    move.w    #0x10,d0
    lsl.w     #1,d0
    add.w     d0,(_X,a5)                        | update spriteX
    bra       cycle_andor_genesis_colour

1:  SET_REENTRY_ADDR_HERE
    tst.b     (andor_genesis_end_flag)
    bne       andor_genesis_leave
    cmp.b     #3,(obj_tbl+_OBJSIZE*0x0E+_STATE) | object 14
    beq       andor_genesis_destroyed
    *** TBD sound
    bra       cycle_andor_genesis_colour

* a5=object 15
andor_genesis_destroyed: | $34BC
    move.b    #0x1D,(andor_genesis_colour)
    move.b    #3,(_TIMER,a5)
    SET_REENTRY_ADDR_HERE
    subq.b    #1,(_TIMER,a5)
    bne       1f
    move.b    #6,(andor_genesis_colour)
    SET_REENTRY_ADDR_HERE
1:  move.b    #0x30,d0
    cmp.b     (_X,a5),d0                        | MSB
    beq       remove_andor_genesis
    move.w    scroll_delta,d0                   | scroll with screen
    neg.w     d0
    lsl.w     #1,d0                             | x2
    add.w     d0,(_X,a5)                        | update spriteX
    rts

andor_genesis_leave: | $34F5
    SET_REENTRY_ADDR_HERE
    cmp.b     #3,(obj_tbl+_OBJSIZE*0x0E+_STATE)
    beq       andor_genesis_destroyed
    move.b    #0xf8,d0
    cmp.b     (_X,a5),d0                        | MSB
    beq       remove_andor_genesis
    move.w    #0xfff8,d0
    lsl.w     #1,d0                             | x2
    add.w     d0,(_X,a5)                        | update spriteX
    *** TBD sound
    bra       cycle_andor_genesis_colour

remove_andor_genesis: | $351B
    clr.b     (_STATE,a5)
    clr.b     (_TYPE,a5)
    bra       add_obj_handler

* installed into object #14
* andor genesis core gun port
handle_4A_Andor_Genesis_obj_14: | $3525
* although the code explicitly references object 14
* we don't need to, and won't here because later routines use a5
    move.b    #2,(_STATE,a5)
    move.b    #0x10,(_CODE,a5)
    move.b    #60,(_PTS,a5)                     | 4,000 pts
    move.w    (obj_tbl+_OBJSIZE*0x0f+_Y),(_Y,a5)  | update spriteY
    jsr       save_PC_to_fn_tbl_and_ret
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       andor_genesis_core_hit            | yes, go
    movea.l   #obj_tbl+_OBJSIZE*0x0f,a0         | object15
    move.b    (_STATE,a0),d0
    subq.b    #1,d0                             | inactive?
    beq       remove_andor_genesis_core         | yes, go
    move.b    (countup_timer_1),d0
    lsr.b     #3,d0
    and.w     #0x0c,d0                          | size=1x1
    add.b     #0x80,d0                          | bank=1
    move.b    d0,(_ATTR,a5)
    move.w    (_X,a0),(_X,a5)                   | update spriteX
    move.b    (andor_genesis_colour),(_COLOUR,a5)
    rts

remove_andor_genesis_core: | $3562
    clr.b     (_STATE,a5)
    clr.b     (_TYPE,a5)
    bra       add_obj_handler

andor_genesis_core_hit: | $356B
    jsr       pre_gun_port_explosion
    SET_REENTRY_ADDR_HERE
    movea.l   #obj_tbl+_OBJSIZE*0x0f,a0         | object15
    move.w    (_X,a0),(_X,a5)                   | update spriteX
    move.w    (_Y,a0),(_Y,a5)                   | update spriteY
    jsr       gun_port_explosion
    cmp.b     #4,(_STATE,a5)
    beq       1f
    rts
1:
* here the core turns into the indestructible Bragza
* which flies up the screen
    SET_REENTRY_ADDR handle_Bragza
    move.w    #0xffd0,(_dX,a5)
    clr.w     (_dY,a5)
    move.b    #8,(_STATE,a5)                    | state=8
    
handle_Bragza: | $35A5
    move.b    (countup_timer_1),d0
    lsr.b     #1,d0
    move.b    d0,d1
    and.w     #3,d0
    add.b     #0xb8,d0
    move.b    d0,(_CODE,a5)
    and.w     #7,d1
    add.b     #0x15,d1
    move.b    d1,(_COLOUR,a5)
    jsr       move_object_dX
    bra       add_obj_handler
    
* installed into object #13
* top-left gun port
handle_4F_Andor_Genesis_obj_13: | $35C2
* although the code explicitly references object 13
* we don't need to, and won't here because later routines use a5
    move.b    #2,(_STATE,a5)
    clr.b     (_ATTR,a5)                        | size=1x1
    move.b    #1,(_TIMER,a5)                    | init timer
    move.b    #0x5c,(_CODE,a5)
    move.b    #48,(_PTS,a5)                     | 1,000 pts
    move.w    (obj_tbl+_OBJSIZE*0x0f+_Y),d0     | object15
    add.w     #0x0200,d0                        | calc spriteY
    move.w    d0,(_Y,a5)                        | update spriteY    
    move.b    (ffreq_mask_andor_genesis),(_FFREQ,a5)
    jsr       save_PC_to_fn_tbl_and_ret
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       tl_gun_port_hit                   | yes, go
    cmp.b     #3,(obj_tbl+_OBJSIZE*0x0e+_STATE)
    beq       tl_gun_port_hit
    movea.l   #obj_tbl+_OBJSIZE*0x0f,a0         | object15
    move.b    (_STATE,a0),d0
    subq.b    #1,d0                             | inactive?
    beq       remove_tl_gun_port                | yes, go
    move.w    (_X,a0),d0                        | object15
    add.w     #0xfe00,d0                        | calc spriteY
    move.w    d0,(_X,a5)                        | update spriteY
    move.b    (andor_genesis_colour),(_COLOUR,a5)
    jsr       chk_timer_fire_bullet_reinit_timer        
    rts

remove_tl_gun_port: | $3615
    clr.b     (_STATE,a5)
    clr.b     (_TYPE,a5)
    bra       add_obj_handler

tl_gun_port_hit: | $361E
    jsr       pre_gun_port_explosion
    SET_REENTRY_ADDR_HERE
    movea.l   #obj_tbl+_OBJSIZE*0x0f,a0         | object15
    move.w    (_X,a0),d0
    add.w     #0xfe00,d0                        | calc spriteX
    move.w    d0,(_X,a5)                        | update spriteX
    move.w    (_Y,a0),d0
    add.w     #0x0200,d0                        | calc spriteY
    move.w    d0,(_Y,a5)                        | update spriteY
    jsr       gun_port_explosion
    cmp.b     #4,(_STATE,a5)
    bne       9f
    bra       remove_tl_gun_port
9:  rts

* installed into object #12
* top-right gun port
handle_50_Andor_Genesis_obj_12: | $364D
* although the code explicitly references object 12
* we don't need to, and won't here because later routines use a5
    move.b    #2,(_STATE,a5)
    clr.b     (_ATTR,a5)                        | size=1x1
    move.b    #1,(_TIMER,a5)                    | init timer
    move.b    #0x5d,(_CODE,a5)
    move.b    #48,(_PTS,a5)                     | 1,000 pts
    move.w    (obj_tbl+_OBJSIZE*0x0f+_Y),d0     | object15
    add.w     #0xfe00,d0                        | calc spriteY
    move.w    d0,(_Y,a5)                        | update spriteY    
    move.b    (ffreq_mask_andor_genesis),(_FFREQ,a5)
    jsr       save_PC_to_fn_tbl_and_ret
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       tr_gun_port_hit                   | yes, go
    cmp.b     #3,(obj_tbl+_OBJSIZE*0x0e+_STATE)
    beq       tr_gun_port_hit
    movea.l   #obj_tbl+_OBJSIZE*0x0f,a0         | object15
    move.b    (_STATE,a0),d0
    subq.b    #1,d0                             | inactive?
    beq       remove_tr_gun_port                | yes, go
    move.w    (_X,a0),d0                        | object15
    add.w     #0xfe00,d0                        | calc spriteY
    move.w    d0,(_X,a5)                        | update spriteY
    move.b    (andor_genesis_colour),(_COLOUR,a5)
    jsr       chk_timer_fire_bullet_reinit_timer        
    rts

remove_tr_gun_port: | $36A0
    clr.b     (_STATE,a5)
    clr.b     (_TYPE,a5)
    bra       add_obj_handler

tr_gun_port_hit: | $36A9
    jsr       pre_gun_port_explosion
    SET_REENTRY_ADDR_HERE
    movea.l   #obj_tbl+_OBJSIZE*0x0f,a0         | object15
    move.w    (_X,a0),d0
    add.w     #0xfe00,d0                        | calc spriteX
    move.w    d0,(_X,a5)                        | update spriteX
    move.w    (_Y,a0),d0
    add.w     #0xfe00,d0                        | calc spriteY
    move.w    d0,(_Y,a5)                        | update spriteY
    jsr       gun_port_explosion
    cmp.b     #4,(_STATE,a5)
    bne       9f
    bra       remove_tr_gun_port
9:  rts

* installed into object #11
* bottom-left gun port
handle_51_Andor_Genesis_obj_11: | $36D8
* although the code explicitly references object 11
* we don't need to, and won't here because later routines use a5
    move.b    #2,(_STATE,a5)
    clr.b     (_ATTR,a5)                        | size=1x1
    move.b    #1,(_TIMER,a5)                    | init timer
    move.b    #0x5e,(_CODE,a5)
    move.b    #48,(_PTS,a5)                     | 1,000 pts
    move.w    (obj_tbl+_OBJSIZE*0x0f+_Y),d0     | object15
    add.w     #0x0200,d0                        | calc spriteY
    move.w    d0,(_Y,a5)                        | update spriteY    
    move.b    (ffreq_mask_andor_genesis),(_FFREQ,a5)
    jsr       save_PC_to_fn_tbl_and_ret
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       bl_gun_port_hit                   | yes, go
    cmp.b     #3,(obj_tbl+_OBJSIZE*0x0e+_STATE)
    beq       bl_gun_port_hit
    movea.l   #obj_tbl+_OBJSIZE*0x0f,a0         | object15
    move.b    (_STATE,a0),d0
    subq.b    #1,d0                             | inactive?
    beq       remove_bl_gun_port                | yes, go
    move.w    (_X,a0),d0                        | object15
    add.w     #0x0200,d0                        | calc spriteY
    move.w    d0,(_X,a5)                        | update spriteY
    move.b    (andor_genesis_colour),(_COLOUR,a5)
    jsr       chk_timer_fire_bullet_reinit_timer        
    rts

remove_bl_gun_port: | $372B
    clr.b     (_STATE,a5)
    clr.b     (_TYPE,a5)
    bra       add_obj_handler

bl_gun_port_hit: | $3734
    jsr       pre_gun_port_explosion
    SET_REENTRY_ADDR_HERE
    movea.l   #obj_tbl+_OBJSIZE*0x0f,a0         | object15
    move.w    (_X,a0),d0
    add.w     #0x0200,d0                        | calc spriteX
    move.w    d0,(_X,a5)                        | update spriteX
    move.w    (_Y,a0),d0
    add.w     #0x0200,d0                        | calc spriteY
    move.w    d0,(_Y,a5)                        | update spriteY
    jsr       gun_port_explosion
    cmp.b     #4,(_STATE,a5)
    bne       9f
    bra       remove_bl_gun_port
9:  rts

* installed into object #10
* bottom-right gun port
handle_52_Andor_Genesis_obj_10: | $3763
* although the code explicitly references object 10
* we don't need to, and won't here because later routines use a5
    move.b    #2,(_STATE,a5)
    clr.b     (_ATTR,a5)                        | size=1x1
    move.b    #1,(_TIMER,a5)                    | init timer
    move.b    #0x5f,(_CODE,a5)
    move.b    #48,(_PTS,a5)                     | 1,000 pts
    move.w    (obj_tbl+_OBJSIZE*0x0f+_Y),d0     | object15
    add.w     #0xfe00,d0                        | calc spriteY
    move.w    d0,(_Y,a5)                        | update spriteY    
    move.b    (ffreq_mask_andor_genesis),(_FFREQ,a5)
    jsr       save_PC_to_fn_tbl_and_ret
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       br_gun_port_hit                   | yes, go
    cmp.b     #3,(obj_tbl+_OBJSIZE*0x0e+_STATE)
    beq       br_gun_port_hit
    movea.l   #obj_tbl+_OBJSIZE*0x0f,a0         | object15
    move.b    (_STATE,a0),d0
    subq.b    #1,d0                             | inactive?
    beq       remove_br_gun_port                | yes, go
    move.w    (_X,a0),d0                        | object15
    add.w     #0x0200,d0                        | calc spriteY
    move.w    d0,(_X,a5)                        | update spriteY
    move.b    (andor_genesis_colour),(_COLOUR,a5)
    jsr       chk_timer_fire_bullet_reinit_timer        
    rts

remove_br_gun_port: | $37B6
    clr.b     (_STATE,a5)
    clr.b     (_TYPE,a5)
    bra       add_obj_handler

br_gun_port_hit: | $37BF
    jsr       pre_gun_port_explosion
    SET_REENTRY_ADDR_HERE
    movea.l   #obj_tbl+_OBJSIZE*0x0f,a0         | object15
    move.w    (_X,a0),d0
    add.w     #0x0200,d0                        | calc spriteX
    move.w    d0,(_X,a5)                        | update spriteX
    move.w    (_Y,a0),d0
    add.w     #0xfe00,d0                        | calc spriteY
    move.w    d0,(_Y,a5)                        | update spriteY
    jsr       gun_port_explosion
    cmp.b     #4,(_STATE,a5)
    bne       9f
    bra       remove_br_gun_port
9:  rts

pre_gun_port_explosion: | $37EE
    move.b    #0x0c,(_COLOUR,a5)
    move.b    #0xff,(_TIMER,a5)                 | init timer
    rts

gun_port_explosion: | $37F8
    addq.b    #1,(_TIMER,a5)
    move.b    (_TIMER,a5),d0
    move.b    d0,d1                             | copy
    lsr.b     #2,d0
    and.w     #7,d0
    subq.b    #5,d0
    addq.b    #3,d0
    bcc       1f
    jsr       adj_gun_port_for_sprite_size
1:  move.b    d1,d0
    and.w     #3,d0
    bne       9f
    lsr.b     #2,d1
    and.w     #7,d1
    cmp.b     #7,d1
    beq       gun_port_explosion_finished
    movea.l   #gun_port_explosion_sprite_tbl,a0
    lsl.w     #1,d1
    move.b    (a0,d1.w),(_CODE,a5)
    move.b    (1,a0,d1.w),(_ATTR,a5)
9:  rts

gun_port_explosion_finished: | $3827
    clr.b     (_CODE,a5)                        | invisible
    move.b    #4,(_STATE,a5)                    | special state
    rts

gun_port_explosion_sprite_tbl: | $382F
    .byte 0x60, 0
    .byte 0x61, 0
    .byte 0x64, 3
    .byte 0x68, 3
    .byte 0x6C, 3
    .byte 0x62, 0
    .byte 0x63, 0

adj_gun_port_for_sprite_size: | $383D
    subq.b    #1,(_X,a5)                        | MSB
    addq.b    #1,(_Y,a5)                        | MSB
    rts
                
cycle_andor_genesis_colour: | $3847
    move.b    (countup_timer_1),d0
    lsr.b     #3,d0
    and.w     #7,d0
    movea.l   #andor_genesis_colour_tbl,a0
    move.b    (a0,d0.w),(andor_genesis_colour)
    rts

andor_genesis_colour_tbl: | $3858
    .byte 2, 3, 4, 5, 6, 5, 4, 3
    
* installed into object #1
* top-left corner piece
handle_41_Andor_Genesis_obj_09: | $3860
    movea.l   #obj_tbl+_OBJSIZE*0x09,a4         | override: object=9
    move.b    #3,(_STATE,a4)                    | indestructible
    move.b    #3,(_ATTR,a4)                     | size=3x3
    move.b    #0x58,(_CODE,a4)
    move.w    (obj_tbl+_OBJSIZE*0x0F+_Y),d0     | object 15
    add.w     #0x0500,d0                        | calc spriteY
    move.w    d0,(_Y,a4)
    jsr       save_PC_to_fn_tbl_and_ret
    movea.l   #obj_tbl+_OBJSIZE*0x09,a4         | override: object=9
    movea.l   #obj_tbl+_OBJSIZE*0x0F,a0         | object15
    move.w    (_X,a0),d0
    add.w     #0xFB00,d0                        | calc spriteX
    move.w    d0,(_X,a4)
    move.b    (andor_genesis_colour),(_COLOUR,a4)
    cmp.b     #1,(_STATE,a0)                    | core state=1?
    bne       9f                                | no, return
    clr.b     (_STATE,a4)
    clr.b     (_TYPE,a4)
    bra       add_obj_handler
9:  rts

* installed into object #2
* top-middle piece
handle_42_Andor_Genesis_obj_08: | $3898
    movea.l   #obj_tbl+_OBJSIZE*0x08,a4         | override: object=8
    move.b    #3,(_STATE,a4)                    | indestructible
    move.b    #3,(_ATTR,a4)                     | size=3x3
    move.b    #0x80,(_CODE,a4)
    move.w    (obj_tbl+_OBJSIZE*0x0F+_Y),d0     | object 15
    add.w     #0x0100,d0                        | calc spriteY
    move.w    d0,(_Y,a4)                        | update spriteY
    jsr       save_PC_to_fn_tbl_and_ret
    movea.l   #obj_tbl+_OBJSIZE*0x08,a4         | override: object=8
    movea.l   #obj_tbl+_OBJSIZE*0x0F,a0         | object15
    move.w    (_X,a0),d0
    add.w     #0xFB00,d0                        | calc spriteX
    move.w    d0,(_X,a4)
    move.b    (andor_genesis_colour),(_COLOUR,a4)
    cmp.b     #1,(_STATE,a0)                    | core state=1?
    bne       9f                                | no, return
    clr.b     (_STATE,a4)
    clr.b     (_TYPE,a4)
    bra       add_obj_handler
9:  rts

* installed into object #3
* top-right corner piece
handle_43_Andor_Genesis_obj_07: | $38CD
    movea.l   #obj_tbl+_OBJSIZE*0x07,a4         | override: object=7
    move.b    #3,(_STATE,a4)                    | indestructible
    move.b    #3,(_ATTR,a4)                     | size=3x3
    move.b    #0x84,(_CODE,a4)
    move.w    (obj_tbl+_OBJSIZE*0x0F+_Y),d0     | object 15
    add.w     #0xFD00,d0                        | calc spriteY
    move.w    d0,(_Y,a4)                        | update spriteY
    jsr       save_PC_to_fn_tbl_and_ret
    movea.l   #obj_tbl+_OBJSIZE*0x07,a4         | override: object=7
    movea.l   #obj_tbl+_OBJSIZE*0x0F,a0         | object15
    move.w    (_X,a0),d0
    add.w     #0xFB00,d0                        | calc spriteX
    move.w    d0,(_X,a4)
    move.b    (andor_genesis_colour),(_COLOUR,a4)
    cmp.b     #1,(_STATE,a0)                    | core state=1?
    bne       9f                                | no, return
    clr.b     (_STATE,a4)
    clr.b     (_TYPE,a4)
    bra       add_obj_handler
9:  rts

* installed into object #4
* left-middle piece
handle_44_Andor_Genesis_obj_06: | $3905
    movea.l   #obj_tbl+_OBJSIZE*0x06,a4         | override: object=6
    move.b    #3,(_STATE,a4)                    | indestructible
    move.b    #3,(_ATTR,a4)                     | size=3x3
    move.b    #0x88,(_CODE,a4)
    move.w    (obj_tbl+_OBJSIZE*0x0F+_Y),d0     | object 15
    add.w     #0x0500,d0                        | calc spriteY
    move.w    d0,(_Y,a4)                        | update spriteY
    jsr       save_PC_to_fn_tbl_and_ret
    movea.l   #obj_tbl+_OBJSIZE*0x06,a4         | override: object=6
    movea.l   #obj_tbl+_OBJSIZE*0x0F,a0         | object15
    move.w    (_X,a0),d0
    sub.w     #0x0100,d0                        | calc spriteX
    move.w    d0,(_X,a4)
    move.b    (andor_genesis_colour),(_COLOUR,a4)
    cmp.b     #1,(_STATE,a0)                    | core state=1?
    bne       9f                                | no, return
    clr.b     (_STATE,a4)
    clr.b     (_TYPE,a4)
    bra       add_obj_handler
9:  rts

* installed into object #5
* centre piece
handle_45_Andor_Genesis_obj_05: | $393A
    movea.l   #obj_tbl+_OBJSIZE*0x05,a4         | override: object=5
    move.b    #3,(_STATE,a4)                    | indestructible
    move.b    #3,(_ATTR,a4)                     | size=3x3
    move.b    #0x8C,(_CODE,a4)
    move.w    (obj_tbl+_OBJSIZE*0x0F+_Y),d0     | object 15
    add.w     #0x0100,d0                        | calc spriteY
    move.w    d0,(_Y,a4)                        | update spriteY
    jsr       save_PC_to_fn_tbl_and_ret
    movea.l   #obj_tbl+_OBJSIZE*0x05,a4         | override: object=5
    movea.l   #obj_tbl+_OBJSIZE*0x0F,a0         | object15
    move.w    (_X,a0),d0
    sub.w     #0x0100,d0                        | calc spriteX
    move.w    d0,(_X,a4)
    move.b    (andor_genesis_colour),(_COLOUR,a4)
    cmp.b     #1,(_STATE,a0)                    | core state=1?
    bne       9f                                | no, return
    clr.b     (_STATE,a4)
    clr.b     (_TYPE,a4)
    bra       add_obj_handler
9:  rts

* installed into object #6
* middle-right piece
handle_46_Andor_Genesis_obj_04: | $396C
    movea.l   #obj_tbl+_OBJSIZE*0x04,a4         | override: object=4
    move.b    #3,(_STATE,a4)                    | indestructible
    move.b    #3,(_ATTR,a4)                     | size=3x3
    move.b    #0x90,(_CODE,a4)
    move.w    (obj_tbl+_OBJSIZE*0x0F+_Y),d0     | object 15
    add.w     #0xFD00,d0                        | calc spriteY
    move.w    d0,(_Y,a4)                        | update spriteY
    jsr       save_PC_to_fn_tbl_and_ret
    movea.l   #obj_tbl+_OBJSIZE*0x04,a4         | override: object=4
    movea.l   #obj_tbl+_OBJSIZE*0x0F,a0         | object15
    move.w    (_X,a0),d0
    sub.w     #0x0100,d0                        | calc spriteX
    move.w    d0,(_X,a4)
    move.b    (andor_genesis_colour),(_COLOUR,a4)
    cmp.b     #1,(_STATE,a0)                    | core state=1?
    bne       9f                                | no, return
    clr.b     (_STATE,a4)
    clr.b     (_TYPE,a4)
    bra       add_obj_handler
9:  rts

* installed into object #7
* bottom-left corner piece
handle_47_Andor_Genesis_obj_03: | $39A1
    movea.l   #obj_tbl+_OBJSIZE*0x03,a4         | override: object=3
    move.b    #3,(_STATE,a4)                    | indestructible
    move.b    #3,(_ATTR,a4)                     | size=3x3
    move.b    #0x94,(_CODE,a4)
    move.w    (obj_tbl+_OBJSIZE*0x0F+_Y),d0     | object 15
    add.w     #0x0500,d0                        | calc spriteY
    move.w    d0,(_Y,a4)                        | update spriteY
    jsr       save_PC_to_fn_tbl_and_ret
    movea.l   #obj_tbl+_OBJSIZE*0x03,a4         | override: object=3
    movea.l   #obj_tbl+_OBJSIZE*0x0F,a0         | object15
    move.w    (_X,a0),d0
    add.w     #0x0300,d0                        | calc spriteX
    move.w    d0,(_X,a4)
    move.b    (andor_genesis_colour),(_COLOUR,a4)
    cmp.b     #1,(_STATE,a0)                    | core state=1?
    bne       9f                                | no, return
    clr.b     (_STATE,a4)
    clr.b     (_TYPE,a4)
    bra       add_obj_handler
9:  rts

* installed into object #8
* bottom-middle piece
handle_48_Andor_Genesis_obj_02: | $39D9
    movea.l   #obj_tbl+_OBJSIZE*0x02,a4         | override: object=2
    move.b    #3,(_STATE,a4)                    | indestructible
    move.b    #3,(_ATTR,a4)                     | size=3x3
    move.b    #0x98,(_CODE,a4)
    move.w    (obj_tbl+_OBJSIZE*0x0F+_Y),d0     | object 15
    add.w     #0x0100,d0                        | calc spriteY
    move.w    d0,(_Y,a4)                        | update spriteY
    jsr       save_PC_to_fn_tbl_and_ret
    movea.l   #obj_tbl+_OBJSIZE*0x02,a4         | override: object=2
    movea.l   #obj_tbl+_OBJSIZE*0x0F,a0         | object15
    move.w    (_X,a0),d0
    add.w     #0x0300,d0                        | calc spriteX
    move.w    d0,(_X,a4)
    move.b    (andor_genesis_colour),(_COLOUR,a4)
    cmp.b     #1,(_STATE,a0)                    | core state=1?
    bne       9f                                | no, return
    clr.b     (_STATE,a4)
    clr.b     (_TYPE,a4)
    bra       add_obj_handler
9:  rts

* installed into object #9
* bottom-right corner piece
handle_49_Andor_Genesis_obj_01: | $3A0E
    movea.l   #obj_tbl+_OBJSIZE*0x01,a4         | override: object=1
    move.b    #3,(_STATE,a4)                    | indestructible
    move.b    #3,(_ATTR,a4)                     | size=3x3
    move.b    #0x9C,(_CODE,a4)
    move.w    (obj_tbl+_OBJSIZE*0x0F+_Y),d0     | object 15
    add.w     #0xFD00,d0                        | calc spriteY
    move.w    d0,(_Y,a4)                        | update spriteY
    jsr       save_PC_to_fn_tbl_and_ret
    movea.l   #obj_tbl+_OBJSIZE*0x01,a4         | override: object=1
    movea.l   #obj_tbl+_OBJSIZE*0x0F,a0         | object15
    move.w    (_X,a0),d0
    add.w     #0x0300,d0                        | calc spriteX
    move.w    d0,(_X,a4)
    move.b    (andor_genesis_colour),(_COLOUR,a4)
    cmp.b     #1,(_STATE,a0)                    | core state=1?
    bne       9f                                | no, return
    clr.b     (_STATE,a4)
    clr.b     (_TYPE,a4)
    bra       add_obj_handler
9:  rts

* copyright message 
* - NAMCO ORIGINAL
* - program by EVEZOO
* scores 10 pts because _PTS is zero
handle_53_Easter_Egg: | $3A46
    tst.b     (attract_mode_stage)              | attract mode?
    bne       remove_easter_egg                 | yes, go
    move.b    #2,(_STATE,a5)
    clr.b     (_ATTR,a5)                        | bank=0, size=1x1
    clr.b     (_CODE,a5)                        | invisible sprite
    SET_REENTRY_ADDR_HERE
    cmp.b     #3,(_STATE,a5)                    | hit?
    beq       check_copyright_strings           | yes, go
    jsr       scroll_sprite_X       
    bra       add_obj_handler

check_copyright_strings: | $3A75
    move.b    #0x80,(_TIMER,a5)                 | init timer
    *** here is where the Z80 code checked the copyright strings
    *** and displayed a message if they had been modified
    *** obviously no point doing that now
    jsr       display_easter_egg
    SET_REENTRY_ADDR_HERE
    subq.b    #1,(_TIMER,a5)                    | dec timer
    beq       1f
    rts
1:  jsr       wipe_easter_egg
    
remove_easter_egg: | $3AA5
    clr.b     (_STATE,a5)
    clr.b     (_TYPE,a5)
    bra       add_obj_handler
    
display_easter_egg: | $3AC9
    lea       str_NAMCO_ORIGINAL,a0
    jsr       cpl_and_display_string_16
    move.w    #0x1921,d0                        | screen col,row
    moveq     #19,d7
    moveq     #BANK_FG_COLORRAM,d2
    move.w    #0x1a,d1
    jsr       display_char_B_times
    lea       str_program_by_EVEZOO,a0          | default
.ifne OPT_TCDEV_EASTER_EGG
    .ifdef __neogeo__
    lea       str_NEOGEO_by_tcdev,a0
    .endif
    .ifdef __amiga__
    lea       str_AMIGA_by_tcdev_jotd,a0
    .endif
.endif
    bra       cpl_and_display_string_24

str_NAMCO_ORIGINAL:
    .byte 0xD0, 0xCF, 0xCE, 0xCD, 0xCC, 0xCB, 0xCA                | "NAMCO" (gfx)
    .byte 0xDB, 0xE7, 0xE4, 0xED, 0xEF, 0xED, 0xE8, 0xF5, 0xEA    | " ORIGINAL"
str_program_by_EVEZOO:
    .byte 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xBA, 0xB8, 0xBB, 0xC3, 0xB8, 0xC9, 0xBD, 0xDB, 0xC8, 0xB1, 0xDB
    .byte 0xF1, 0xE0, 0xF1, 0xDC, 0xE7, 0xE7, 0xDB, 0xDB          | "     program by EVEZOO  "
.ifdef __neogeo__
str_NEOGEO_by_tcdev:
    .byte 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xE8, 0xF1, 0xE7, 0xEF, 0xF1, 0xE7, 0xDB, 0xC8, 0xB1, 0xDB, 0xB6
    .byte 0xC7, 0xC6, 0xC5, 0xB4, 0xDB, 0xDB, 0xDB, 0xDB          | "     NEOGEO by tcdev    "
.endif
.ifdef __amiga__
str_AMIGA_by_tcdev_jotd:
    .byte 0xDB, 0xF5, 0xE9, 0xED, 0xEF, 0xF5, 0xDB, 0xC8, 0xB1, 0xDB, 0xB6, 0xC7, 0xC6, 0xC5, 0xB4, 0xDB
    .byte 0xD6, 0xDB, 0xC0, 0xBB, 0xB6, 0xC6, 0xDB, 0xDB          | " AMIGA by tcdev & jotd  "
.endif
    
cpl_and_display_string_16: | $3B48
    movea.l   #str_decrypt_buf,a1
    moveq     #16-1,d7
1:  move.b    (a0)+,d0
    not.b     d0
    move.b    d0,(a1)+
    dbf       d7,1b
    move.w    #0x1921,d0                        | screen col,row
    lea       str_decrypt_buf,a0                | string
    moveq     #16,d7                            | length
    moveq     #BANK_FG_VIDEORAM,d2
    jsr       display_string
    rts 
    
cpl_and_display_string_24: | $3B62
    movea.l   #str_decrypt_buf,a1
    moveq     #24-1,d7
1:  move.b    (a0)+,d0
    not.b     d0
    move.b    d0,(a1)+
    dbf       d7,1b
    move.w    #0x1722,d0                        | screen col,row
    lea       str_decrypt_buf,a0                | string
    moveq     #24,d7                            | length
    moveq     #BANK_FG_VIDEORAM,d2
    jsr       display_string
    rts 

wipe_easter_egg: | $3B7C
    move.w    #0x1921,d0                        | screen col,row
    moveq     #16,d7
    moveq     #BANK_FG_VIDEORAM,d2
    move.w    #0x24,d1                          | space
    jsr       display_char_B_times
    move.w    #0x1921,d0                        | screen col,row
    moveq     #16,d7
    moveq     #BANK_FG_COLORRAM,d2
    move.w    #0x24,d1                          | space
    jsr       display_char_B_times
    move.w    #0x1722,d0                        | screen col,row
    moveq     #24,d7
    moveq     #BANK_FG_VIDEORAM,d2
    bra       display_char_B_times    

* table of flying enemy types
flying_enemy_type_tbl: | $3C03
    .byte 0, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xB, 0xB, 0xB, 0xB, 0xB, 0xB, 0x55, 0x55, 0x55
    .byte 0x55, 0x55, 0x55, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0xF, 0xF, 0xF, 0xF, 0xF, 0xF, 0xC
    .byte 0xC, 0xC, 0xC, 0xC, 0xC, 0xB, 0xB, 8, 8, 8, 8, 8, 8, 0xD, 0xD, 0xD
    .byte 0xD, 0xD, 0xD, 0xE, 0xE, 0xE, 0x12, 0x12, 0x12, 0x13, 0x13, 0x13, 0x14, 0x14, 0x14, 0x14
    .byte 0x14, 0x14, 0xE, 0xE, 0xE, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x14, 0x14, 0x14, 0x11, 0x11
    .byte 0x11, 0x11, 0x11, 0x11, 0x16, 0x16, 0x16, 0x16, 0x17, 0x17, 0x17, 0x17, 0xF, 0xF, 8, 8
    .byte 8, 8, 0x55, 0x55, 0x10, 0x10, 8, 8, 8, 8, 0x11, 0x11, 0x14, 0x14, 0x15, 0x15
    .byte 0x15, 0x15, 8, 8, 8, 8, 0xE, 0xE, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F

    .align 4        
obj_handler_tbl: | $3C83
    .long     handle_01_Bacura
    .long     null_fn                           | NOT USED
    .long     null_fn                           | NOT USED
    .long     null_fn                           | NOT USED
    .long     null_fn                           | NOT USED
    .long     handle_06_Bullet
    .long     handle_07_Garu_Zakato_Bullet
    .long     handle_08_Giddo_Spario
    .long     handle_09_Brag_Spario
    .long     handle_0A_Toroid
    .long     handle_0B_Toroid_shoots
    .long     handle_0C_Zoshi
    .long     handle_0D_Zoshi
    .long     handle_0E_Zoshi
    .long     handle_0F_Torkan
    .long     handle_10_Kapi
    .long     handle_11_Terrazi
    .long     handle_12_Zakato
    .long     handle_13_Zakato
    .long     handle_14_Zakato
    .long     handle_15_Zakato
    .long     handle_16_Brag_Zakato
    .long     handle_17_Brag_Zakato
    .long     handle_18_Garu_Zakato
    .long     null_fn                           | NOT USED
    .long     null_fn                           | NOT USED
    .long     handle_1B_Derota
    .long     null_fn                           | NOT USED
    .long     handle_1D_Sol_Tower
    .long     handle_1E_Barra
    .long     handle_1F_Zolbak
    .long     handle_20_Garu_Barra
    .long     handle_21_Garu_Derota
    .long     null_fn                           | NOT USED
    .long     null_fn                           | NOT USED
    .long     null_fn                           | NOT USED
    .long     null_fn                           | NOT USED
    .long     handle_26_Logram
    .long     null_fn                           | NOT USED
    .long     null_fn                           | NOT USED
    .long     null_fn                           | NOT USED
    .long     null_fn                           | NOT USED
    .long     null_fn                           | NOT USED
    .long     handle_2C_Grobda_stationary
    .long     handle_2D_Boza_Logram
    .long     handle_2E_Domogram
    .long     null_fn                           | NOT USED
    .long     null_fn                           | NOT USED
    .long     handle_31_right_sheonite
    .long     handle_32_left_sheonite
    .long     null_fn                           | NOT USED
    .long     null_fn                           | NOT USED
    .long     handle_35_Grobda_fwd
    .long     handle_36_Grobda_crosshairs_fwd
    .long     null_fn                           | NOT USED
    .long     handle_38_Grobda_fwd_crosshairs_stop_fwd
    .long     handle_39_Grobda_targeted_back_stop
    .long     handle_3A_Grobda_fwd_crosshairs_darts_fwd
    .long     handle_3B_Grobda_fwd_targeted_back_fwd
    .long     handle_3C_Grobda_targeted_fast_fwd
    .long     handle_3D_Grobda_stationary_in_water
    .long     handle_3E_Grobda_fwd_in_water
    .long     handle_3F_Grobda_crosshairs_fwd_in_water
    .long     handle_40_Grobda_fwd_targeted_back_fwd_in_water
    .long     handle_41_Andor_Genesis_obj_09
    .long     handle_42_Andor_Genesis_obj_08
    .long     handle_43_Andor_Genesis_obj_07
    .long     handle_44_Andor_Genesis_obj_06
    .long     handle_45_Andor_Genesis_obj_05
    .long     handle_46_Andor_Genesis_obj_04
    .long     handle_47_Andor_Genesis_obj_03
    .long     handle_48_Andor_Genesis_obj_02
    .long     handle_49_Andor_Genesis_obj_01
    .long     handle_4A_Andor_Genesis_obj_14
    .long     handle_4B_Andor_Genesis_obj_15
    .long     null_fn                           | NOT USED
    .long     null_fn                           | NOT USED
    .long     null_fn                           | NOT USED
    .long     handle_4F_Andor_Genesis_obj_13
    .long     handle_50_Andor_Genesis_obj_12
    .long     handle_51_Andor_Genesis_obj_11
    .long     handle_52_Andor_Genesis_obj_10
    .long     handle_53_Easter_Egg
    .long     handle_54_Bonus_Flag
    .long     handle_55_Jara
    .long     handle_56_Jara
    .long     null_fn                           | NOT USED

* points per object
* - object table holds index to value
object_value_tbl: | $3D31
    .byte 1, 0, 0                               | 10 (offset=0)
    .byte 2, 0, 0                               | 20 (offset=3)
    .byte 3, 0, 0                               | 30 (offset=6)
    .byte 5, 0, 0                               | 50 (offset=9)
    .byte 7, 0, 0                               | 70 (offset=12)
    .byte 0x10, 0, 0                            | 100 (offset=15)
    .byte 0x15, 0, 0                            | 150 (offset=18)
    .byte 0x20, 0, 0                            | 200 (offset=21)
    .byte 0x25, 0, 0                            | 250 (offset=24)
    .byte 0x30, 0, 0                            | 300 (offset=27)
    .byte 0x40, 0, 0                            | 400 (offset=30)
    .byte 0x50, 0, 0                            | 500 (offset=33)
    .byte 0x60, 0, 0                            | 600 (offset=36)
    .byte 0x70, 0, 0                            | 700 (offset=39)
    .byte 0x80, 0, 0                            | 800 (offset=42)
    .byte 0x90, 0, 0                            | 900 (offset=45)
    .byte 0, 1, 0                               | 1,000 (offset=48)
    .byte 0x50, 1, 0                            | 1,500 (offset=51)
    .byte 0, 2, 0                               | 2,000 (offset=54)
    .byte 0x50, 2, 0                            | 2,500 (offset=57)
    .byte 0, 4, 0                               | 4,000 (offset=60)
pts_10000: | $3D70
    .byte 0, 0x10, 0                            | 10,000 (offset=63)

* (dX,dY) pairs for angles
angle_dX_dY_sheonite_tbl: | $3D73
    .byte 0, 0x40
    .byte 0xC, 0x3F
    .byte 0x18, 0x3B
    .byte 0x24, 0x35
    .byte 0x2D, 0x2D
    .byte 0x35, 0x24
    .byte 0x3B, 0x18
    .byte 0x3F, 0xC
    .byte 0x40, 0
    .byte 0x3F, 0xF4
    .byte 0x3B, 0xE8
    .byte 0x35, 0xDC
    .byte 0x2D, 0xD3
    .byte 0x24, 0xCB
    .byte 0x18, 0xC5
    .byte 0xC, 0xC1
    .byte 0, 0xC0
    .byte 0xF4, 0xC1
    .byte 0xE8, 0xC5
    .byte 0xDC, 0xCB
    .byte 0xD3, 0xD3
    .byte 0xCB, 0xDC
    .byte 0xC5, 0xE8
    .byte 0xC1, 0xF4
    .byte 0xC0, 0
    .byte 0xC1, 0xC
    .byte 0xC5, 0x18
    .byte 0xCB, 0x24
    .byte 0xD3, 0x2D
    .byte 0xDC, 0x35
    .byte 0xE8, 0x3B
    .byte 0xF4, 0x3F

* (dX,dY) pairs for angles
angle_dX_dY_terrazi_torkan_tbl: | $3DB3
    .byte 0, 0x30
    .byte 9, 0x2F
    .byte 0x12, 0x2C
    .byte 0x1B, 0x28
    .byte 0x22, 0x22
    .byte 0x28, 0x1B
    .byte 0x2C, 0x12
    .byte 0x2F, 9
    .byte 0x30, 0
    .byte 0x2F, 0xF7
    .byte 0x2C, 0xEE
    .byte 0x28, 0xE5
    .byte 0x22, 0xDE
    .byte 0x1B, 0xD8
    .byte 0x12, 0xD4
    .byte 9, 0xD1
    .byte 0, 0xD0
    .byte 0xF7, 0xD1
    .byte 0xEE, 0xD4
    .byte 0xE5, 0xD8
    .byte 0xDE, 0xDE
    .byte 0xD8, 0xE5
    .byte 0xD4, 0xEE
    .byte 0xD1, 0xF7
    .byte 0xD0, 0
    .byte 0xD1, 9
    .byte 0xD4, 0x12
    .byte 0xD8, 0x1B
    .byte 0xDE, 0x22
    .byte 0xE5, 0x28
    .byte 0xEE, 0x2C
    .byte 0xF7, 0x2F

* (dX,dY) pairs for angles
angle_dX_dY_tbl: | $3DF3
    .byte 0, 0x20
    .byte 6, 0x1F
    .byte 0xC, 0x1E
    .byte 0x11, 0x1B
    .byte 0x17, 0x17
    .byte 0x1B, 0x11
    .byte 0x1E, 0xC
    .byte 0x1F, 6
    .byte 0x20, 0
    .byte 0x1F, 0xFA
    .byte 0x1E, 0xF4
    .byte 0x1B, 0xEF
    .byte 0x17, 0xE9
    .byte 0x11, 0xE5
    .byte 0xC, 0xE2
    .byte 6, 0xE1
    .byte 0, 0xE0
    .byte 0xFA, 0xE1
    .byte 0xF4, 0xE2
    .byte 0xEF, 0xE5
    .byte 0xE9, 0xE9
    .byte 0xE5, 0xEF
    .byte 0xE2, 0xF4
    .byte 0xE1, 0xFA
    .byte 0xE0, 0
    .byte 0xE1, 6
    .byte 0xE2, 0xC
    .byte 0xE5, 0x11
    .byte 0xE9, 0x17
    .byte 0xEF, 0x1B
    .byte 0xF4, 0x1E
    .byte 0xFA, 0x1F

angle_dX_dY_toroid_tbl: | $3E33
    .byte 0, 0x18
    .byte 5, 0x18
    .byte 9, 0x16
    .byte 0xD, 0x14
    .byte 0x11, 0x11
    .byte 0x14, 0xD
    .byte 0x16, 9
    .byte 0x18, 5
    .byte 0x18, 0
    .byte 0x18, 0xFB
    .byte 0x16, 0xF7
    .byte 0x14, 0xF3
    .byte 0x11, 0xEF
    .byte 0xD, 0xEC
    .byte 9, 0xEA
    .byte 5, 0xE8
    .byte 0, 0xE8
    .byte 0xFB, 0xE8
    .byte 0xF7, 0xEA
    .byte 0xF3, 0xEC
    .byte 0xEF, 0xEF
    .byte 0xEC, 0xF3
    .byte 0xEA, 0xF7
    .byte 0xE8, 0xFB
    .byte 0xE8, 0
    .byte 0xE8, 5
    .byte 0xEA, 9
    .byte 0xEC, 0xD
    .byte 0xEF, 0x11
    .byte 0xF3, 0x14
    .byte 0xF7, 0x16
    .byte 0xFB, 0x18
            
area_offset_in_map_tbl: | $3EB3
    .byte 0x24, 0, 0x54, 0xE, 0x40, 0x1A, 0x64, 4, 0x2A, 0x5C, 0xE, 4, 0x38, 0x54, 0x1A, 0
    
strHIGH_SCORE: | $3EC3
    .byte 0x11, 0x12, 0x10, 0x11, 0x24, 0x1C, 0xC, 0x18, 0x1B, 0xE

strCOPYRIGHT: | $3ECD
    .byte 0x2D, 0x2E, 0x28, 0x24, 1, 9, 8, 2, 0x24, 0x17, 0xA, 0x16, 0xC, 0x18, 0x24, 0x15
    .byte 0x1D, 0xD, 0x50

strNAMCO: | $3E0E
    .byte 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35
    
_end_of_xevious_main_rom:

    .bss
    
* RAM and variables

* $7800-

main_2_fn_tbl_1:                        ds.l  32          | 32 objects
                                        ds.l  4           | solvalou
main_30_fn_tbl:                         ds.l  3           | player shots
main_2_fn_tbl_2:                        ds.l  25          | 25 objects

* $7900-

    .align 0x1000
* 64 objects, 32 bytes per object
obj_tbl:                                ds.b  _OBJSIZE*64

* $8000-$83FF

watermark_0x8000:
vb_semaphore_main:                      ds.b  1
countup_timer_1:                        ds.b  1
vb_semaphore_sub:                       ds.b  1
    .align 2
pseudo_random_seed:                     ds.w  1
bg_scroll_x_shadow:                     ds.w  1
scroll_cntr:                            ds.w  1
area_offset_in_map:                     ds.b  1
    .align 2
scroll_delta:                           ds.w  1
dswa:                                   ds.b  1
dswb:                                   ds.b  1
P1_inputs:                              ds.b  1
P2_inputs:                              ds.b  1   | must follow P1_inputs
start_pressed:                          ds.b  1
pulsing_colour_1:                       ds.b  1
curr_player:                            ds.b  1
two_player_game:                        ds.b  1
is_real_game:                           ds.b  1
RAM_high_score:
high_score_msb:                         ds.b  3
    .align 2
attract_mode_stage:                     ds.w  1
num_credits:                            ds.b  1
scroll_disabled:                        ds.b  1
num_flying_enemies:                     ds.b  1
flying_enemy_type_tbl_offset:           ds.b  1
num_bacura:                             ds.b  1
sheonite_end_flag:                      ds.b  1
andor_genesis_end_flag:                 ds.b  1
shot_flag:                              ds.b  1
shot_timer_init_value:                  ds.b  1
shot_timer:                             ds.b  1
andor_genesis_colour:                   ds.b  1
countdown_timer_1:                      ds.b  1
    .align 2
next_domogram:                          ds.w  1
pulsing_colour_2:                       ds.b  1
solvalou_exploding:                     ds.b  1
new_high_score_entry_index:             ds.b  1
name_entry_char_cnt:                    ds.b  1
    .align 2
name_entry_curr_char_screen_offset:     ds.w  2
name_entry_ptr_curr_char:               ds.l  1
*** SPRITERAM_1_SHADOW was here ***
* current player state information
* - needs to be at least 64 ($40) bytes
* - other needs to be the same
* need to read msb,Ks as a word
    .align 2
curr_player_score_msb:                  ds.b  1
curr_player_score_Ks:                   ds.b  1
curr_player_score_lsb:                  ds.b  1
curr_player_solvalou_left:              ds.b  1
    .align 2                            
area_obj_ptr:                           ds.l  1
area:                                   ds.w  1
enemy_AI_level:                         ds.b  1
    .align 2                            
next_bonus_life_Ks:                     ds.w  1
solvalou_number:                        ds.b  1
bonus_life_none:                        ds.b  1
* this value is set from the object table
* in the SUB CPU as the map is generated
* used for both Derota & Garu Derota
* area01=$0F, area03=$03, area05=$07,$0F, area06=$07
ffreq_mask_derota:                      ds.b  1
* this value is set from the object table
* in the SUB CPU as the map is generated
* area01=$07, area12=$03
ffreq_mask_kapi:                        ds.b  1
* this value is set from the object table
* in SUB CPU as map is generated
* area01=$07 area12=$03
ffreq_mask_terrazi:                     ds.b  1
* this value is set from the object table
* in SUB CPU as map is generated
* area01=$FF,$1F area05=$0F
ffreq_mask_logram:                      ds.b  1
* this value is set from the object table
* in SUB CPU as map is generated
* area01=$1F area12=$0F
ffreq_mask_zoshi:                      ds.b 1
* this value is set from the object table
* in SUB CPU as map is generated
* area01=$1F area05=$0F area07=$07
ffreq_mask_boza_logram:                 ds.b  1
* this value is set from the object table
* in SUB CPU as map is generated
* area01=$1F area05=$0F area06=$FF,$0F area07=$3F
* area08=$FF, area10=$3F, area12=$0F, area16=$1F
ffreq_mask_domogram:                    ds.b  1
* this value is set from the object table
* in SUB CPU as map is generated
* area04=$2F area09=$0F area14=$0F
ffreq_mask_andor_genesis:               ds.b  1
gnd_stop_firing_row:                    ds.b  1
curr_player_filler:                     ds.b  64
* other player state information
* - needs to be at least 64 ($40) bytes
other_player_score_msb:                 ds.b  3
other_player_solvalou_left:             ds.b  1
other_player_filler:                    ds.b  64
*** SPRITERAM_2_SHADOW was here ***
    .align 4                            
main_fn_tbl_RAM:                        ds.l  32
*** SPRITERAM_3_SHADOW was here ***

* $8400-
                                        
watermark_0x8400:
bacura_inc_cnt:                         ds.b  1
one_second_cntr:                        ds.b  1
* buffer for decrypting easter egg messsages
str_decrypt_buf:                        ds.b  32

* $8500-

* name_buffer MUST follow RAM_test_result_final_score
RAM_test_result_final_score:            ds.b  3
name_buffer:                            ds.b  10
                                        ds.b  3
high_score_1st_msb:                     ds.b  3
high_score_1st_name:                    ds.b  10
                                        ds.b  3
high_score_2nd_msb:                     ds.b  3
high_score_2nd_name:                    ds.b  10
                                        ds.b  3
high_score_3rd_msb:                     ds.b  3
high_score_3rd_name:                    ds.b  10
                                        ds.b  3
high_score_4th_msb:                     ds.b  3
high_score_4th_name:                    ds.b  10
                                        ds.b  3
high_score_5th_msb:                     ds.b  3
high_score_5th_name:                    ds.b  10
                                        ds.b  3
maincpu_inited:                         ds.b  1

* $9380-

* 12 entries, 64 bytes per entry
domogram_tbl:                           ds.b  64*12

    .align 0x800
fg_colorram:                            ds.b  0x800
bg_colorram:                            ds.b  0x800
fg_videoram:                            ds.b  0x800
bg_videoram:                            ds.b  0x800

* hitbox routines use sprite shadow register values
* - but for efficiency they're in OSD format
* - so maintain a 'raw' copy of X{8:1] & Y[7:0]
* - layout is 64x Y,X pairs
sprite_shadow_msb:                      ds.b  64*2
